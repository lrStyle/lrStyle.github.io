
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Ren Li&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ren Li&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ren Li&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ren Li&#39;s blog">
  
    <link rel="alternative" href="/atom.xml" title="Ren Li&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ren Li&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Think and write down</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-cs224n/background" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/06/cs224n/background/" class="article-date">
  <time datetime="2018-11-06T21:07:19.846Z" itemprop="datePublished">2018-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/06/cs224n/background/">基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="梯度下降（gradient-decent）"><a href="#梯度下降（gradient-decent）" class="headerlink" title="梯度下降（gradient decent）"></a>梯度下降（gradient decent）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script></p>
<ul>
<li>什么是梯度：在多元函数中，梯度可理解为求各个变量的偏导数，最终各个偏导组合成梯度向量，即代表该函数在该点变化最快的方向。<br>eg: \(f(x,y)=x^2+y^2\), 梯度向量为(2x,2y)，在点(1,1)处的梯度即为(2,2)，即沿(2,2)这个方向函数变化最快。</li>
</ul>
<h3 id="Vanilla-Gradient-Descent（普通梯度下降）"><a href="#Vanilla-Gradient-Descent（普通梯度下降）" class="headerlink" title="Vanilla Gradient Descent（普通梯度下降）"></a>Vanilla Gradient Descent（普通梯度下降）</h3><p>1、求解梯度向量<br>2、一点点沿着梯度的方向迭代更新函数值，使函数最终下降到局部最小值处。<br>$$<br>\theta^{new}_j=\theta^{old}-\alpha\nabla_{\theta}J(\theta)=\theta^{old}_j-\alpha\frac {\partial}{\partial \theta^{old}_j}J(\theta)<br>$$<br>注：\(\alpha\)是步长（setp size），步长太小求解速度慢，步长太大则会造成抖动。<br>解决方法：距离谷底较远时，步幅大些比较好（加快速度）；接近谷底时，步幅小些比较好（以免跨过界）。距离谷底的远近可以通过梯度的数值大小间接反映，接近谷底时，坡度会减小，因此可设置步长与梯度数值大小正相关。</p>
<h3 id="Stochastic-Gradient-Descent（SGD，随机梯度下降）"><a href="#Stochastic-Gradient-Descent（SGD，随机梯度下降）" class="headerlink" title="Stochastic Gradient Descent（SGD，随机梯度下降）"></a>Stochastic Gradient Descent（SGD，随机梯度下降）</h3><p>VGD中，每次更新都需要遍历所有data，当数据量太大，更新一次梯度会花费大量时间，因此并不可行。<br>解决这个问题的基本思路：只通过一个随机选取的数据(xn,yn)来获取梯度（通常损失函数都是很多项的变量加和得到的，这时只取一项计算其梯度，用来估计整体的梯度），这种方法叫随即梯度下降。<br>虽然这样估计梯度非常粗糙，但事实证明这种方法效果还不错。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/11/06/cs224n/background/" data-id="cjo6b5dhd002m4sqxe11w377y" class="article-share-link" data-share="baidu" data-title="基础知识">Share</a>
      

      
        <a href="http://yoursite.com/2018/11/06/cs224n/background/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cs224n/">cs224n</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cs224n/lecture 2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/05/cs224n/lecture 2/" class="article-date">
  <time datetime="2018-11-05T21:32:18.948Z" itemprop="datePublished">2018-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/05/cs224n/lecture 2/">lecture 2_Word Vectors</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

<h2 id="How-to-represent-the-meaning-of-a-word-in-computer"><a href="#How-to-represent-the-meaning-of-a-word-in-computer" class="headerlink" title="How to represent the meaning of a word in computer"></a>How to represent the meaning of a word in computer</h2><h3 id="离散表示（discrete-representation）"><a href="#离散表示（discrete-representation）" class="headerlink" title="离散表示（discrete representation）"></a>离散表示（discrete representation）</h3><ul>
<li>把单词作为一个个原子符号（atomic symbol）来表征：hotel, conference, walk…</li>
<li>对应到计算机中，使用<strong>独热编码（one-hot encoding）</strong>来存储：<code>[0 0 0 0 1 0 0 0]</code></li>
<li>存在的问题：<br>1、向量规模过大：每个单词都对应一个单独的位，若要存储所有单词，则需要a very very long vector。<br>2、难以计算单词间的相似性：这是一种localist representation, 每个one-hot representation是独立存在的，no inherent notion of similarity, 两两间并没有天然的相似性关系。<br>3、因此与其去研究an approach to work out similarity relationship between one-hot representations，不如直接探究<strong>an approach where representation of word encodes its meaning inherently</strong>，这样就能直观去计算单词间的similarity，这就是分布表示（distributed representation）的设计初衷。</li>
</ul>
<h3 id="分布表示（distributed-representation）"><a href="#分布表示（distributed-representation）" class="headerlink" title="分布表示（distributed representation）"></a>分布表示（distributed representation）</h3><ul>
<li><strong>核心思想：</strong>通过单词的上下文（context）来理解词意。如<code>banking</code>这个单词，我们让计算机知道经常和它一起出现的其他单词，就相当于明白了单词的用法(怎样将单词放到正确的上下文中)，就相当于理解了单词的meaning。<br><img src="/images/cs224n/2_distributed representation.png" width="500" height="120" align="center"></li>
<li><strong>具体方法：</strong>用向量定义词语的含义。通过调整一个单词及其上下文单词的向量，使得根据两个向量可以推测两个单词的相似度，就可以根据中心词向量预测上下文/根据上下文向量预测中心词。这就是我们常说的<strong>word2vec</strong>!</li>
<li>注：区分distributed和distributional<br>distributed meaning：一种词义表示，和one-hot相对，one-hot将词义独立地存储在本地（<code>[0 0 0 0 1 0 0 0]</code>向量中），distributed则存储在一个大的稠密的向量空间中。<br>distributional similarity：一种通过上下文来理解词义的方法，与denotational相对。<br>We use distributional similarity to <strong>build</strong> distributed meaning.</li>
</ul>
<h2 id="word2vec模型"><a href="#word2vec模型" class="headerlink" title="word2vec模型"></a>word2vec模型</h2><h3 id="Skip-grams-SG"><a href="#Skip-grams-SG" class="headerlink" title="Skip-grams(SG)"></a>Skip-grams(SG)</h3><p><img src="/images/cs224n/2_Skipgram_prediction.png" width="300" height="150" alt="Skipgram_prediction" align="center/"><br><img src="/images/cs224n/2_Skipgram_model.png" width="450" height="300" alt="Skipgram_model" align="center/"></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>通过中心词预测上下文。</p>
<h4 id="定义预测单词上下文的模型"><a href="#定义预测单词上下文的模型" class="headerlink" title="定义预测单词上下文的模型"></a>定义预测单词上下文的模型</h4><p>\(p(context|w_t)\)，表示在给定中心词\(w_t\)的条件下，正确预测出上下文单词的概率。<br><strong>再具体点：</strong>\(p(w_{t-1}|w_t)\)，\(p(w_{t-2}|w_t)\)，\(p(w_{t+1}|w_t)\)，\(t, t+1, t-1\)都是表示单词在文中出现的序号。<br>最终形式：<br>$$ p(w_{t+j}|w_t)=p(o|c)=\frac {exp(u_0^Tv_c)} {\sum_{w=1}^v exp(u_w^Tv_c)} $$<br>\(t, t+j\)是单词在文中的位置.<br>\(o, c\)则是单词在单词表中的序号，相当于在更为一般地表征两个单词的关联（与具体文本无关）。<br>\(v_c\)是中心词的词向量，\(u_0\)是上下文单词的词向量。<br><strong>公式理解：</strong>首先是\(u_0^Tv_c\)，这是一个点积操作，可用来粗糙地衡量单词间相似性（单词越相似，向量值越相近，乘积越大）；其次是softmax操作，用来把值转换成概率：<br>$$\frac {exp(u_0^Tv_c)} {\sum_{w=1}^v exp(u_w^Tv_c)} $$<br>最终即得出了由中心词预测上下文单词的概率。</p>
<h4 id="定义损失函数（Loss-Function）"><a href="#定义损失函数（Loss-Function）" class="headerlink" title="定义损失函数（Loss Function）"></a>定义损失函数（Loss Function）</h4><p>1、首先对模型全部相乘，表示文本整体的预测正确率：<br>$$ J^`(\theta)=\prod_{t=1}^T \prod_<br>{ \begin{align}<br>-m\le j \le m\\<br>j \neq 0<br>\end{align} }<br>p(w_{t+j}|w_t)$$<br>目标：整体正确率最大，maximize the function，<br>2、做Negtive Log Likelihood处理，使maximize-&gt;minimize，即得到最终的损失函数。<br>$$ J(\theta)=-\frac {1}{T} \sum_{t=1}^T \sum_<br>{ \begin{align}<br>-m&amp; \le j \le m\\<br>j \neq 0<br>\end{align} }<br>p(w_{t+j}|w_t)\\<br>p(w_{t+j}|w_t)=\frac {exp(u_0^Tv_c)} {\sum_{w=1}^v exp(u_w^Tv_c)}<br>$$<br>最终目标：使损失函数最小。</p>
<h4 id="怎样求损失函数最小值：梯度下降（gradient-descent）"><a href="#怎样求损失函数最小值：梯度下降（gradient-descent）" class="headerlink" title="怎样求损失函数最小值：梯度下降（gradient descent）"></a>怎样求损失函数最小值：梯度下降（gradient descent）</h4><p>注1：具体求解过程见lecture slide。<br>注2：求梯度时对\(u_o和v_c\)都要求偏导，最后组合成梯度向量。且求的是向量的导数，和实数求偏导有一定区别。<br>注3：当数据量过大时，可使用SGD随机梯度下降来加快速度（一个窗口计算一次梯度，用来估计整体梯度）。</p>
<h4 id="怎样训练模型"><a href="#怎样训练模型" class="headerlink" title="怎样训练模型"></a>怎样训练模型</h4><p>模型中的参数就是每个单词对应的word vector向量，将所有参数组合成一个的大向量\(\theta\)，即作为损失函数的自变量。<br><img src="/images/cs224n/2_theta.png" width="150" height="150" alt="theta举例（里面单词是随便举的例子）" align="center"><br>总共V个单词，每个单词对应两个词向量，词向量每个d维，因此\(\theta\)总长度为2dV。<br>为何每个单词对应两个词向量：作为中心词时一个，作为上下文单词时一个，这样更方便数学处理。</p>
<h3 id="Continuous-Bag-of-Words-CBOW"><a href="#Continuous-Bag-of-Words-CBOW" class="headerlink" title="Continuous Bag of Words(CBOW)"></a>Continuous Bag of Words(CBOW)</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>通过上下文预测中心词<br>To be continued</p>
<h2 id="遗留问题："><a href="#遗留问题：" class="headerlink" title="遗留问题："></a>遗留问题：</h2><p>SG模型中，计算每个上下文词向量的值时，context matrix是一样的？ 那计算出的结果不就一样了？<br>如何迭代\(\theta\)来更新梯度？把\(\theta\)初始化成什么样子？</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/11/05/cs224n/lecture 2/" data-id="cjo6b5dhc002i4sqxmhzuview" class="article-share-link" data-share="baidu" data-title="lecture 2_Word Vectors">Share</a>
      

      
        <a href="http://yoursite.com/2018/11/05/cs224n/lecture 2/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cs224n/">cs224n</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cs224n/lecture 1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/02/cs224n/lecture 1/" class="article-date">
  <time datetime="2018-11-02T12:33:38.275Z" itemprop="datePublished">2018-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/02/cs224n/lecture 1/">lecture 1_Introduction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="关于人类语言-human-language"><a href="#关于人类语言-human-language" class="headerlink" title="关于人类语言(human language)"></a>关于人类语言(human language)</h2><h3 id="人类语言的特点"><a href="#人类语言的特点" class="headerlink" title="人类语言的特点"></a>人类语言的特点</h3><ul>
<li><strong>语言就是符号：</strong>人类语言本质是一个符号系统（symbol system），无论是汉字还是英文字母，都是一种符号，用来承载、传递我们想要表达的意思（meaning）。</li>
<li><strong>语言的载体：</strong>sound, vision(writting), gesture，不论是哪一种载体，都是一种连续的交流方式。</li>
<li><strong>大脑是一种符号处理器</strong>（symbolic processors）：我们可以把大脑处理语言看成是<strong>连续模式的激活过程</strong>（continious pattern of activation）。</li>
<li>因此我们可以得到启发：探索一种<strong>连续的编码模式</strong>来表达思想(explore a continous encoding patten of thought)。这也是很多NLP算法的处理思想，同时也解决了sparsity的问题。</li>
</ul>
<h2 id="关于NLP"><a href="#关于NLP" class="headerlink" title="关于NLP"></a>关于NLP</h2><h3 id="NLP-levels"><a href="#NLP-levels" class="headerlink" title="NLP levels"></a>NLP levels</h3><p><img src="/images/cs224n/NLP_levels.png" width="500" height="270" alt="NLP levels" align="center"></p>
<ul>
<li><strong>两大来源：</strong>通过语音或者文本。语音：语音分析（phonetic）或音韵分析（phonological）；文本：OCR识别（Optical Character Recognition，光学字符识别）或分词处理（tokenization）。通过上述方法来获取NLP的输入。</li>
<li><strong>形态分析</strong>（morphological）：对单词进行形态分析：前缀（prefix）、后缀（suffix）等。</li>
<li><strong>句法分析</strong>（syntactic）：分析句子结构、语法结构（structure of sentence）。</li>
<li><strong>语义理解</strong>（semantic interpretation）：work out the meaning of sentences.</li>
<li><strong>语篇处理</strong>（discourse processing）：因为大多数句子含义需要通过上下文（context）来推测，不能仅仅只分析当前句子，因此就有了the field of discourse processing。<br>注：cs224n课只重点讲syntatic &amp; semantic analysis 这两块，以及一部分speech signal analysis。</li>
</ul>
<h3 id="NLP-Applications"><a href="#NLP-Applications" class="headerlink" title="NLP Applications"></a>NLP Applications</h3><ul>
<li>较低级：spell checking, keyword search, finding synonyms</li>
<li>中级：extracting information。个人比较感兴趣的方向，让计算机可以阅读文本，理解在讲些什么，至少知道讲的是哪方面内容；从文本中识别、抽取某方面内容；或者为文本阅读难度分级（work out the reading level of school text）,识别文本的目标受众（intended audience of document）；情感分析（positive or negetive）。</li>
<li>高级：机器翻译、对话机器人、智能问答、机器撰写（exploit the knowledge of world）</li>
</ul>
<h3 id="Why-is-NLP-hard"><a href="#Why-is-NLP-hard" class="headerlink" title="Why is NLP hard"></a>Why is NLP hard</h3><ul>
<li><strong>语言本身的困难性</strong>：Ambiguilty of language, and moreover, humen always do not say everything（为了高效表达，语言使用中会出现很多省略）.</li>
<li><strong>表征语言很困难</strong>：Complexity of representing, using linguistic/situational/world knowledge.</li>
<li><strong>解释语言很困难</strong>：Real meaning of the language depends on real world, common sense, and contextual knowledge.</li>
</ul>
<h2 id="关于deep-learning"><a href="#关于deep-learning" class="headerlink" title="关于deep learning"></a>关于deep learning</h2><h3 id="传统机器学习的问题"><a href="#传统机器学习的问题" class="headerlink" title="传统机器学习的问题"></a>传统机器学习的问题</h3><ul>
<li>Most traditional machine learning algorithms work well because of human-designed representations and input featured.</li>
<li>“Machines” are only used to optimize weights that best make a final prdiction. </li>
<li>Moreover, manually designed featured are often over-specified(lack of generalization), incomplete and take a long time to design and validate.</li>
</ul>
<h3 id="What-is-deep-learning"><a href="#What-is-deep-learning" class="headerlink" title="What is deep learning"></a>What is deep learning</h3><ul>
<li>Subfield of machine learning and part of representation learning.</li>
<li>Deep learning algorithms attempt to learn (multiple levels of) representations and an output themselves. </li>
<li>We only input the raw data.</li>
<li>In a lot of times, deep learning means neural networks (the dominant model family).</li>
</ul>
<h3 id="deep-learning-in-NLP"><a href="#deep-learning-in-NLP" class="headerlink" title="deep learning in NLP"></a>deep learning in NLP</h3><p>核心思想：用vector去表征语言，用神经网络去组织、计算vector。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/11/02/cs224n/lecture 1/" data-id="cjo6b5dhc002k4sqxt6zj6b60" class="article-share-link" data-share="baidu" data-title="lecture 1_Introduction">Share</a>
      

      
        <a href="http://yoursite.com/2018/11/02/cs224n/lecture 1/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cs224n/">cs224n</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-uwtsd_modules/Distributed &amp; Cluster Computing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/18/uwtsd_modules/Distributed & Cluster Computing/" class="article-date">
  <time datetime="2018-10-18T21:29:42.408Z" itemprop="datePublished">2018-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/18/uwtsd_modules/Distributed & Cluster Computing/">Distributed &amp; Cluster Computing</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><ul>
<li>Interface-Based Programming<br>An interface only defines a signature of properties and methods(method name, type of each parameter, type of return value).<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> property1</span><br><span class="line">    &#123;</span><br><span class="line">        get;</span><br><span class="line">        set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>A class is used to implement the interface by providing the actual code for those methods.</p>
<ul>
<li>Interface Name Form<br>Microsoft dictates that all interface names start with the <code>I</code> characters, that they not include underscore character, and that they use Pascal casing when the name contains mutiple words(first letter of each word is uppercase). </li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/10/18/uwtsd_modules/Distributed & Cluster Computing/" data-id="cjo6b5dhe002o4sqxze7jruxw" class="article-share-link" data-share="baidu" data-title="Distributed &amp; Cluster Computing">Share</a>
      

      
        <a href="http://yoursite.com/2018/10/18/uwtsd_modules/Distributed & Cluster Computing/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/uwtsd-modules/">uwtsd_modules</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Paper Notes/Personal Recommendation Using Deep Recurrent Neural Networks in NetEase" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/Paper Notes/Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/" class="article-date">
  <time datetime="2018-09-13T07:49:59.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/Paper Notes/Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/">Personal Recommendation Using Deep Recurrent Neural Networks in NetEase读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a href="http://cfm.uestc.edu.cn/~zhangdongxiang/papers/ICDE16_industry_231.pdf" target="_blank" rel="noopener">论文地址点这里</a></p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>  </p>
<h2 id="论文内容概述"><a href="#论文内容概述" class="headerlink" title="论文内容概述"></a>论文内容概述</h2><p>本文结合RNN和FNN两种神经网络提出了一种新的个性推荐方法，希望解决传统的CF方法无法进行实时推荐的问题，最终在网易的考拉电商网站上取得了良好的效果。</p>
<h3 id="简介-INTRODUCTION"><a href="#简介-INTRODUCTION" class="headerlink" title="简介(INTRODUCTION)"></a>简介(INTRODUCTION)</h3><ul>
<li><p><strong>传统CF模型存在的问题</strong><br>因为是基于用户购物习惯的推荐，使用的是历史信息，未能利用用户当前的浏览历史，因此无法进行实时推荐。</p>
</li>
<li><p><strong>如何进行实时推荐</strong><br>首先要考虑访问电商网站的用户属性，包括基本属性(浏览器、IP地址、个人基本信息、购买历史等)和动态属性(用户所浏览页面的信息)，而基于后者，我们就可以猜测用户在本次访问中究竟想要购买什么，从而完成实时推荐。</p>
</li>
<li><p>之后作者对系统主要面临的挑战、所构建DRNN的特点和其他一些技术作了介绍，即完成了本节内容。</p>
</li>
</ul>
<h3 id="推荐模块概述-OVERVIEW-OF-RECOMMENDATION-MODULE"><a href="#推荐模块概述-OVERVIEW-OF-RECOMMENDATION-MODULE" class="headerlink" title="推荐模块概述(OVERVIEW OF RECOMMENDATION MODULE)"></a>推荐模块概述(OVERVIEW OF RECOMMENDATION MODULE)</h3><ul>
<li><p><strong>系统流程</strong><br>服务器首先接收用户请求并聚合为一个会话信息，之后将其输入到推荐系统中，经过RNN和FNN计算后输出推荐结果，并在页面中显示。</p>
</li>
<li><p><strong>数据格式</strong><br>数据收集：假设用户\(u_i\)访问网站，会生成日志文档\(D_j^l\)和会话文档\(D_i^s\)两种文档，两者关系为\(D_i^s=\{D_0^l,D_1^l,\cdots,D_{k-1}^l\}\)，即一个会话文档对应多个日志文档。<br>数据简化：又因为每个日志文档都可简化为一个URL地址\(p_j\)，因此可得\(D_i^s=\{p_0,p_1,\cdots,p_{n-1}\}\)。<br>最终的输入数据：访问网站的每个用户\(u_i\)都会对应一个\(D_i^s\)，即构成了神经网络的输入数据。</p>
</li>
</ul>
<h3 id="DRNN具体介绍-DEEP-RECURRENT-NEURAL-NETWORK"><a href="#DRNN具体介绍-DEEP-RECURRENT-NEURAL-NETWORK" class="headerlink" title="DRNN具体介绍(DEEP RECURRENT NEURAL NETWORK)"></a>DRNN具体介绍(DEEP RECURRENT NEURAL NETWORK)</h3><ul>
<li><p><strong>RNN的特点</strong><br>RNN即循环神经网络，相比其他神经网络最大的特点是：其考虑了前后两个状态之间的关联，可以更好地处理序列信息。在本文的场景中，一个session可抽象为一系列的网页序列，因此利用RNN来进行推荐直观上是非常合适的。</p>
</li>
<li><p><strong>基本RNN模型</strong><br>在单个隐藏层的RNN中，隐藏层节点除了的输入和输出外，还会有一个自连接环，可以根据时间来不断地更新它的值。<br>更新函数：\(a(i)=f(Ux(i)+Wa(i-1))\)，\(a(i)\)表示在状态\(i\)下的节点值，\(x(i)\)表示输入值，\(U,W\)为相应的转移矩阵，\(f(x)\)为激活函数。<br>公式理解：隐藏层节点每次更新除了会考虑输入值外，还会考虑该节点在前一状态下的值，因此RNN的结果可以反映时间序列的相应信息。</p>
</li>
<li><p><strong>有限状态的DRNN</strong><br>当RNN具有多个隐藏层时，即构成了DRNN。考虑DRNN中第\(i\)层的某个状态\(t\)，其不仅会连接同层的状态\(t+1\)，还会连接到第\(i+1\)层的状态\(t\)，即构成了新的更新函数：<br>$$ f(x)=\left\{<br>\begin{align}<br>&amp;f(W_ia_i(t-1)+Z_i(a_{i-1}(t)+b_i(t)))&amp;,&amp; i&gt;1 \\<br>&amp;f(W_ia_i(t-1)+Z_i(V_t+\theta (p_t)))&amp;,&amp; i=1<br>\end{align}<br>\right.<br>$$</p>
</li>
<li><p><strong>引入历史状态节点的DRNN</strong><br>问题背景：受限于内存，我们不可能保存用户所有产生的状态；但如果使用\(n\)状态的滑动窗口，则只能选择最新的\(n\)个数据训练模型，会降低预测精度。因此作者引入了历史状态节点(history state)的概念。<br>当用户访问的页面数\(x\)超过一定数量\(n\)时，我们将前\(x-n\)个状态组合起来作为历史状态节点，有<br>$$\bar{V}=\sum_{i=0}^{x-n}\varepsilon_iV_i$$<br>$$\varepsilon_i=\frac {\theta(p_i)} {\sum_{j=i}^{x-n}\theta(p_j)} $$<br>公式理解：根据用户在页面的停留时间对前\(x-n\)个页面作加权平均，近似表征用户的历史信息，是一个既在一定程度上保证了模型精度，计算开销又不至于太大的折中方案。</p>
</li>
<li><p><strong>与协同过滤算法的结合</strong><br>问题背景：虽然协同过滤算法无法提供实时的推荐，但如果用户遵循以往购买习惯，其推荐效果还是很好的。因此作者引入了FNN模型来模拟CF算法，作为RNN的补充。<br>另外使用FNN还有两点好处：</p>
<ul>
<li>FNN和RNN共享相同的输出层，因此可以将二者的输出融合起来作为最终结果，来表征用户购买某件商品的概率。</li>
<li>可以使用随机最速下降法(SGD)来训练RNN和FNN结合的权重，而不用人为地决定哪个网络更为重要，减轻了模型调参的工作量。</li>
</ul>
</li>
<li><p><strong>如何生成训练数据</strong><br>用户从进入网站开始到最终购买商品，会经历一定数量的页面，个性推荐的本质目标就是减少这之间页面的数量。对于一次购买行为\(I\)，其对应的页面路径为\(p_0,\cdots,p_{n-1}\rightarrow I\)。若对其进行优化，不一定非要优化成\(p_0\rightarrow I\)这样(当然这是最优情况)，只要能减少用户的页面访问数量，都可以算作优化。因此我们的训练数据还可以是\(p_0,p_1\rightarrow I\)、 \(p_0,p_1,p_2\rightarrow I\)等，这样一次购买行为就可以产生\(n\)组训练数据，大大增加了我们的训练量。</p>
</li>
<li><p><strong>模型的实现</strong><br>作者使用了Caffe框架来实现模型，整个网络包含三层隐含层，且同一层次的神经元共享相同的权重和偏置矩阵。此外，模型的RNN部分包含4个状态的输入，FNN包含1个状态的输入。</p>
</li>
</ul>
<h3 id="模型调优-MODEL-OPTIMIZATIONS"><a href="#模型调优-MODEL-OPTIMIZATIONS" class="headerlink" title="模型调优(MODEL OPTIMIZATIONS)"></a>模型调优(MODEL OPTIMIZATIONS)</h3><p>这一节作者介绍了其为了改进模型性能所做的工作，并提出了一种自动调优框架，使得模型具有了更高的精度和更快的学习速度。</p>
<ul>
<li><p><strong>自动代码生成器</strong><br>问题背景：模型中包括了很多参数，调整这些参数需要更改甚至重写Caffe脚本，非常繁琐。因此作者构建了一个代码生成器，其主要任务是接收参数值，输出对应的Caffe脚本。<br>主要思想：首先将参数分为<strong>基本参数</strong>(损失函数、学习速率等)和<strong>网络结构参数</strong>(每层的神经元数)，调整基本参数只需更改相应的值，而调整网络结构参数则需要改写Caffe脚本，因此我们只需重点关注网络结构参数即可。<br>三种网络结构参数：文中提出了长、宽、高三种网络结构参数，分别对应隐含层数量、状态数以及隐含层与状态层的连接数，并编写了相应的代码生成算法，具体可见文中的Algorithm 1。</p>
</li>
<li><p><strong>模型调优</strong><br>为了求得表现更好的模型参数，作者采用了遗传算法这种启发式算法进行模型调优。<br>染色体结构：\(C=(w,l,h,a_1,a_2,\cdots,a_L,\cdots)\)，直观的理解就是将所有参数结合在了一起。<br>适应度函数：\(fit=accuracy+\frac {1} {1+loss}\)，\(accuracy\)为模型预测精度，\(loss\)为损失率。<br>注：虽然遗传算法最终求得的是局部最优解，但因为参数调优本就是一个非常复杂、难以建模的过程，所以作者认为这样的解已经足够好了。</p>
</li>
</ul>
<h3 id="模型实验-EXPERIMENTS"><a href="#模型实验-EXPERIMENTS" class="headerlink" title="模型实验(EXPERIMENTS)"></a>模型实验(EXPERIMENTS)</h3><p>这一节作者对模型进行了全面的测试和分析，并分别研究几个重要因素对模型的影响。</p>
<ul>
<li><p><strong>评价指标</strong><br>作者采用了预测正确率作为模型主要的评价指标，公式为\(accuracy=\frac {f(S)} {|S|}\)，\(S\)代表训练样本总数，\(f(S)\)代表正确预测的样本数。</p>
</li>
<li><p><strong>batch size的影响</strong><br>在使用默认参数训练模型时，增大batch size可以提高模型精度，但对于内存的消耗也更大。而一个有趣的现象是，使用调优框架后再训练模型，batch size对精度的影响就不再显著了，可见调优框架确实使得模型的表现更为优异了。</p>
</li>
<li><p><strong>FNN的影响</strong><br>由Fig.11、Fig.12可得，FNN的使用显著提升了模型精度，尤其是同时使用调优框架和FNN的模型，精度提升了约10%，而且这还是在模型只推荐1个物品的情况下(即购买概率最大的那个物品)，若模型返回10个物品，模型精度可以达到50%以上。<br>同时，使用FNN并不会影响模型的收敛速率，即模型精度的提升并不会增加计算开销，这也是很重要的一点。</p>
</li>
<li><p><strong>历史状态节点的影响</strong><br>在使用默认参数训练模型时，使用历史状节点态可提高模型10%的精度；而使用了调优框架后，只能提升2%的精度，即调优过程降低了不同网络结构对模型的影响，这也侧面表明了作者所提出调优框架的优异性能。</p>
</li>
<li><p><strong>模型最终效果</strong><br>在DRNN和FNN结合的情况下，模型最终的预测精度达到了33.13%，页面路径压缩到了原先的72.41%，相当于用户从点进网站到最终购买商品，少浏览了30%的页面，效果还是显而易见的，毕竟用户每多浏览一个自己不感兴趣的页面，其离开网站的概率就会越大，这也就是推荐系统的作用所在，即帮助用户更快地进行选择。</p>
</li>
</ul>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><h3 id="关于推荐系统"><a href="#关于推荐系统" class="headerlink" title="关于推荐系统"></a>关于推荐系统</h3><ul>
<li>本文提出了基于RNN和FNN的推荐系统，最主要的原因是传统的CF算法基于用户间购物历史的相似度来做推荐，考虑的更多是用户的购物习惯，这就使其无法把握用户突发的、低频的购买需求。</li>
<li>比如我平常很爱买衣服，网购的大部分物品都是衣服，但有一天突然想吃零食，就会在网站上浏览零食的相关页面，这时系统给我推荐的若还是衣服，就会影响用户体验，也不利于提高网站的销量，因此实时推荐是很有必要的。</li>
<li>但同时，在生活大部分情况中，一个人还是会遵循其所形成的习惯去购物，这时基于购物习惯的推荐便能表现出很好的效果，因此CF算法也是很有必要的。</li>
<li>综上，论文中使用RNN和FNN两种算法共同完成推荐，这种思路是合理的，也是符合我们的直观认知的。</li>
</ul>
<h3 id="关于RNN算法"><a href="#关于RNN算法" class="headerlink" title="关于RNN算法"></a>关于RNN算法</h3><ul>
<li>RNN与其他网络最大的不同在于其隐含层节点的自连接性，在其更新函数中，不仅包括正常的输入值，还包括上一时刻中节点自身的值，这就像使得节点具有了“记忆”，这个记忆表征了时间序列中前后节点的关联，因此RNN适合处理时间序列或状态间具有一定联系的情况。</li>
<li>对应到本文，用户在网站上购物必然会浏览一系列页面，而这些页面是否是有关联的呢？我认为是有的。比如我要买一个钱包，在第一个页面中没有浏览到我喜欢的款式，那我下一个访问的页面也会是关于钱包的，甚至我之后的浏览可能都会围绕钱包来展开，因此我们就可从用户初始的浏览内容来推测其实时的购买兴趣，这也就是作者应用RNN进行实时推荐的原因。</li>
</ul>
<h3 id="关于历史状态节点-history-state"><a href="#关于历史状态节点-history-state" class="headerlink" title="关于历史状态节点(history state)"></a>关于历史状态节点(history state)</h3><ul>
<li>本文的一个创新在于引入了历史状态节点，来解决状态数过多、计算开销过大的问题。根据用户在页面上停留的时间，将多出的历史状态作加权平均，构成一个新的节点，这样既可以保留历史信息，又不会造成计算开销的大量增加，是一种比较折衷的方案。</li>
<li>这也提示我们，在数据量过大的情况下，与其直接将一部分数据丢弃掉，不如将这部分数据做整合，采用加权平均或其他的提取信息的方法，构成新的节点来参与运算，在模型精度和计算开销之间取得平衡。</li>
</ul>
<h3 id="关于训练数据的生成"><a href="#关于训练数据的生成" class="headerlink" title="关于训练数据的生成"></a>关于训练数据的生成</h3><ul>
<li>本文针对用户一次的购买行为，将各种可能的路径优化方案都作为了训练数据送入模型进行训练，这样可以增加我们的训练量。因为对于有监督学习来说，带标签的数据是有限的，如何充分利用有限的标签数据去训练模型需要我们去研究，本文给了我们一种可行的思路。</li>
</ul>
<h3 id="关于模型调优"><a href="#关于模型调优" class="headerlink" title="关于模型调优"></a>关于模型调优</h3><ul>
<li>本文提出了一种模型调优框架，大致可分为“生成参数”和“生成代码”两部分。</li>
<li>首先将模型的相关参数整合成染色体，再利用遗传算法的杂交、变异等操作，生成下一代染色体，之后将参数传入代码生成器中生成对应的Caffe脚本，训练模型后，将结果回带到遗传算法的适应度函数中进行评估和自然选择，一轮轮地迭代，最终即可得出最优的参数组合。</li>
<li>因为建模的复杂性和组合爆炸等问题，模型调优一直是机器学习的一个难点，在这种情况下，利用一些启发式算法进行智能调优不失为一个好的方法，这也是文章给我们的一个启示。</li>
</ul>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><h3 id="关于模型的更新问题"><a href="#关于模型的更新问题" class="headerlink" title="关于模型的更新问题"></a>关于模型的更新问题</h3><ul>
<li>在文章中提到，顾客每完成一次购物，就相当于得到了一个”ground truth”，可以用来训练、调整模型，这样模型随着网站的运行就会不断优化和改进。</li>
<li>如果顾客这次购物是在遵循自己以往的购物习惯，那么将结果用来继续训练模型是没有问题的，因为这个行为在今后还会多次发生，这样可以使得模型更了解顾客的购买习惯，从而更好地完成推荐。</li>
<li>但如果这是一次”unexpected”的购物行为，就像平常都喜欢买衣服的我只是突然想吃点零食，如果模型把这个突发的低频需求当作了用户的购买习惯，在今后也多次向用户进行推荐，可能会造成用户的厌烦。</li>
<li>因此我认为在模型的持续更新中，应该考虑到用户购买行为的属性，即对利用了RNN方式完成的推荐，要降低其对模型的后续影响。</li>
<li>方案实现：可以通过减少训练样本数量的方式，对于通过RNN推荐完成的购买，不要将<br>$$<br>  p_0 \rightarrow I \\<br>  p_0,p_1 \rightarrow I \\<br>  \cdots \\<br>  p_0,\cdots,p_{n-1} \rightarrow I<br>$$<br>所有的路径样本都送入训练，可以只送入后半段或后1/4的样本，让推荐发生的条件更为“苛刻”一些，从而使得模型不会在用户一进入网站就推荐一些低频、不经常需求的产品。</li>
</ul>
<h3 id="将社群属性加入到模型中"><a href="#将社群属性加入到模型中" class="headerlink" title="将社群属性加入到模型中"></a>将社群属性加入到模型中</h3><ul>
<li>论文在”Related Work”中提到CF推荐和基于内容的推荐相结合，会在社交网络上表现得更好，因此我认为可以将这种思路应用到本文，即在推荐系统中加入一定的社群属性。</li>
<li>问题背景：在实际生活中，我们会更倾向于接受来自朋友的推荐，而非来自商家的推荐。尤其是本文的电商网站——网易考拉，是一个主打海淘的平台，用户对一些国外的品牌可能了解并不多，这时如果有来自自己社交圈的推荐，无疑会增加购买的概率。</li>
<li>方案实现：可以考虑改进文中的FNN部分的方法，即首先通过用户填写的基本信息或其他网易系应用中的用户资料(如网易音乐、游戏等)，对用户进行社群判别和分类，为每个用户构建一个“熟人圈”。在进行FNN推荐时，模型不仅推荐历史相似的用户购买的产品，也推荐来自熟人圈购买的产品，以将社群属性加入到推荐模型中。</li>
</ul>
<h3 id="关于推荐理由"><a href="#关于推荐理由" class="headerlink" title="关于推荐理由"></a>关于推荐理由</h3><ul>
<li>问题背景：目前用户对于推荐系统的态度，不仅是想“知其然”，也想“知其所以然”，即除了推荐的物品本身，用户也会想知道系统为什么会给自己推荐这个物品，因此如果能给推荐物品附上推荐理由，无疑会提升网站的用户体验。</li>
<li>方案实现：因为本文是将两种神经网络的输出层共享，以类似加权平均的方式进行融合(见文章第三节D部分)，来计算出用户购买某件物品的概率的，因此可以将最终结果的各个部分分离出来，从大到小排序，通过分析值最大的一项或几项来构造我们的推荐理由。</li>
<li>具体形式：推荐理由的形式可以为“根据你以前购买过的xxx牛仔裤，我们猜你还喜欢这个”、“根据你刚刚浏览过的xxx钱包，我们猜你会喜欢这个”等等，以一种猜测、活泼的口吻对用户进行提示，以增加用户的购买欲望。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/Paper Notes/Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/" data-id="cjo6b5dh700284sqx3khj8004" class="article-share-link" data-share="baidu" data-title="Personal Recommendation Using Deep Recurrent Neural Networks in NetEase读书笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/Paper Notes/Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper-Notes/">Paper Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Paper Notes/Efficient Estimation of Word Representations in Vector Space" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/Paper Notes/Efficient Estimation of Word Representations in Vector Space/" class="article-date">
  <time datetime="2018-09-13T07:49:59.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/Paper Notes/Efficient Estimation of Word Representations in Vector Space/">Notes of Efficient Estimation of Word Representations in Vector Space读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a href="https://arxiv.org/pdf/1301.3781.pdf?" target="_blank" rel="noopener">论文地址点这里</a></p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script> 

<h2 id="论文内容概述"><a href="#论文内容概述" class="headerlink" title="论文内容概述"></a>论文内容概述</h2><p>这是谷歌发布的关于词向量的经典论文，针对传统模型无法表征单词间关联性的问题，本文提出了两种连续的词向量模型，并针对模型实现了分布式学习模块，最后基于词向量的线性运算设计了一种评价模型精度的方法，取得了良好的效果。</p>
<h3 id="简介-INTRODUCTION"><a href="#简介-INTRODUCTION" class="headerlink" title="简介(INTRODUCTION)"></a>简介(INTRODUCTION)</h3><ul>
<li><p><strong>传统NLP技术的特点</strong><br>传统NLP技术主要是基于单词间没有相似性的思想，将词汇以单词表索引的形式来表示。这样做虽然有很多好处，如简单、健壮、使用大量数据训练的简单模型的效果好于使用少量数据训练的复杂模型等；但同样也有很多限制，如语料数据库没有足够的数据、无法表征单词间的关联等。因此作者认为原先的技术很难再取得突破，需要去发掘新的技术。</p>
</li>
<li><p><strong>论文主要工作</strong><br>1、从大量单词和短语数据中学习出高质量的词向量，并且要保持一个合适的向量维度。<br>2、使用了一种评估词向量精度的技术，期望不仅相似的单词可以趋向接近，同时单词间能具有更多维的相似度。<br>3、使用单词偏移技术对词向量做简单的代数运算，以更好地挖掘词向量间的相似性规则。<br>4、设计了一个综合测试集来探究句法和语义的规律性，并研究了词向量维度和训练数据量这两个因素对训练时间和模型精度的影响。</p>
</li>
</ul>
<h3 id="模型框架-Model-Architectures"><a href="#模型框架-Model-Architectures" class="headerlink" title="模型框架(Model Architectures)"></a>模型框架(Model Architectures)</h3><p>在本节中，作者使用了NNLM和RNNLM两种神经网络来学习连续的单词表示方法，并且对不同神经网络的训练复杂度进行了分析。</p>
<ul>
<li><p><strong>训练复杂度公式</strong><br>作者首先提出了分析训练复杂度的公式：\(O=E\times T\times Q\)，其中E为训练的趟数，T为训练集中单词的数量，Q为表征模型复杂度的变量，下文还会对Q具体分析。</p>
</li>
<li><p><strong>前馈神经网络语言模型(NNLM)</strong><br>基本结构：整个网络分为输入层、映射层、隐含层和输出层，输入层将前N个单词编码为1-of-V的向量，V为词表大小，这N个单词共享相同的映射矩阵，阵映射到映射层，之后再从映射层转换到隐含层，经过一系列计算后输出最终结果。<br>模型复杂度：\(Q=N\times D+N\times D\times H+H\times V\)，因为N是一个较小的量，因此\(N\times D\)也比较小；另外对单词表用二叉树做优化，可使得\(V\)下降到\(log_2(V)\)，这样\(H\times V\)也会减小，最终模型的复杂度主要就集中在\(N\times D\times H\)，即映射层-&gt;隐含层这部分。<br>注：对于单词表的表示，还可以继续用哈夫曼树做优化，减少高频单词的编码长度，从而进一步降低输出层的计算量。</p>
</li>
<li><p><strong>循环神经网络语言模型(RNNLM)</strong><br>模型特点：RNN最大的特点是其自连接性，即状态的更新不仅取决于输入，还取决于上一时刻自己本身的状态，这个特性就使得RNN具有了一种“短时”的记忆，可以更好地表示前后文本之间的关联。<br>模型复杂度：RNNLM中没有映射层，因此模型复杂度简化为\(Q=H\times H+H\times V\)。和上文同理，\(V\)可以优化为\(log_2(V)\)，因此模型的复杂度主要集中在\(H\times H\)。</p>
</li>
<li><p><strong>神经网络的平行训练模型</strong><br>为了提升在大规模数据集上训练模型的效率，作者在DistBelief框架的基础上实现了一个分布式计算模型，允许多个副本并行地学习训练，而且所有副本会同步进行梯度更新，作者在下文会分析模型的具体效果。  </p>
</li>
</ul>
<h3 id="新的对数线性模型-New-Log-linear-Models"><a href="#新的对数线性模型-New-Log-linear-Models" class="headerlink" title="新的对数线性模型(New Log-linear Models)"></a>新的对数线性模型(New Log-linear Models)</h3><p>在本节中，作者提出了两个连续词向量模型，希望能使用一种更简单的模型来训练更大量的数据，以通过增加训练量来提升训练效果。</p>
<ul>
<li><p><strong>连续词袋模型(Continuous Bag-of-Words Model)</strong><br>基本结构：模型与前馈NNLM比较相似，但是去掉了非线性隐含层，并且所有单词直接共享整个映射层，而非只是映射矩阵。通过这种方法，所有的单词被映射到同一位置，对这些向量进行平均后即为最终的映射结果。<br>模型特点：1、所有的单词最终都被映射到同一位置，因此单词的顺序就不再起作用了；2、为了对单词进行分类，模型会同时使用上下文的一部分单词进行计算；3、模型的作用是根据上下文来推测中间可能出现的单词；4、与传统词袋模型的不同在于其对于上下文的表示是连续。<br>模型复杂度：\(Q=N\times D+D\times log_2(V)\)</p>
</li>
<li><p><strong>连续Skip-gram模型(Continuous Skip-gram Model)</strong><br>模型特点：1、模型的结构类似上述CBOW模型，可以说是“镜像对称”的；2、Skip-gram模型的作用也和CBOW模型相反，其是根据中间的单词，来推测单词的上下文信息；3、考虑到大部分距离较远的单词之间的关联性都较小，因此作者减少了远距离单词的训练样本数量，以降低其权重。<br>模型复杂度：\(Q=C\times (D+D\times log_2(V))\)，C指单词最大化距离，使用模型时会随机选取\([1,C]\)中的一个值作为取词窗口的长度。  </p>
</li>
</ul>
<h3 id="结果分析-Results"><a href="#结果分析-Results" class="headerlink" title="结果分析(Results)"></a>结果分析(Results)</h3><ul>
<li><p><strong>核心思想</strong><br>考虑明显具有相同相似关系的两对单词，如”biggest”、”big”和”smallest”、”small”，计算\(X=D(biggest)-D(big)+D(small)\)，若词向量模型训练成功，应有\(X\)与\(D(smallest)\)是向量空间中距离最近的点。</p>
</li>
<li><p><strong>实验设计</strong><br>作者从句法和语义的角度列出若干相似的类别，分别在每个类别中加入若干单词对，将这些单词对随机两两组合，基于上述公式，计算是否是距离最近的点，若是，即为一次正确的实验结果，最终统计总体正确率来评价模型的优劣。</p>
</li>
<li><p><strong>提升模型精度</strong><br>作者研究了训练数据量和词向量维度两个因素对CBOW模型精度的影响，发现如果只单纯提升某一个因素，对模型精度的影响都是有限的，因此需要同时提升两个因素才能取得比较好的效果。</p>
</li>
<li><p><strong>各模型的对比</strong><br>对比1：在相同训练量和向量维度的条件下，作者对比了RNNLM、NNLM、CBOW和Skip-gram四种模型的精确度，由Table 3可知，CBOW和Skip-gram两种模型的表现明显好于RNNLM、NNLM模型。<br>对比2：作者研究了增大训练量和增大向量维度对CBOW和Skip-gram两种模型的影响，发现只将训练量增大两倍和只将向量维度增大两倍，取得的效果是差不多的，增加的训练时间也比较接近；同时可以发现，两倍数据训练一趟比单倍数据训练三趟的效果要好。<br>对比3：作者将文中的模型与已公布的其他向量模型做了对比，综合表现最好的依旧是Skip-gram。<br>对比4：作者使用了之前提到的分布式计算框架，将向量维度提升到了1000，使用谷歌新闻数据集进行训练，在这种情况下Skip-gram模型的精度依旧是最高的，而且达到了65.6%。<br>对比5：介绍了微软的一个挑战赛，给定挖去一个词的句子和五个候选词，求哪个词和句子最匹配。作者将句子填词问题反向转化为了由词去预测句子的问题，预测出原句的概率最大的那个词，就是所求的词。作者利用Skip-gram+RNNLMs的组合模型，取得了所有模型中最好的效果。</p>
</li>
</ul>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><h3 id="关于连续词向量模型"><a href="#关于连续词向量模型" class="headerlink" title="关于连续词向量模型"></a>关于连续词向量模型</h3><ul>
<li>本文的工作主要围绕着连续词向量模型，因为传统的词向量表示是将单词视作一个个离散的符号，这样做的缺点是无法提供足够的信息来体现词语之间的关联，比如虽然Italy和Rome两个单词看起来一点也不像，但其实两者之间是有联系的(Rome是Italy的首都)，而如何研究出这种潜在的联系，便是本文的主要讨论内容。  </li>
<li>作者的思路是通过词向量来表征这种潜在的联系，首先使用了两种神经网络来生成词向量，但因为隐含层的计算开销过大，使得模型无法训练大量数据集，也无法提升词向量的维度；因此作者从简化模型的角度，提出CBOW和Skip-gram两种模型，并且使用了分布式训练框架，这使得模型能够针对大量数据集进行训练，从而获得更好的训练效果。  </li>
<li>训练出向量模型后，作者为了检测向量模型的效果，基于“相似度高的向量距离近”的思想，提出了一种检测算法，对向量进行代数运算并计算之间的距离，如果相似度高的向量计算出的距离确实小，就说明模型是合理的，作者即通过这个思路分析了各个模型的优劣。</li>
</ul>
<h3 id="关于词向量的线性运算"><a href="#关于词向量的线性运算" class="headerlink" title="关于词向量的线性运算"></a>关于词向量的线性运算</h3><ul>
<li>文中所用的检测词向量精度的方法是基于词向量的线性运算，即“意大利-罗马+巴黎=法国”这样的计算规则，通过这个算式，我们可以很明显地感受到词之间所具有的某种关联，利用这种关联就可以大大扩展词向量的应用范围。  </li>
<li>但具体为什么会有这种性质呢？我认为可能的原因：词向量的假设是基于上下文的分布来推导词义，而“意大利-罗马+巴黎=法国”可以转换为“意大利+巴黎=法国+罗马”，而只有意大利和巴黎共同的上下文与法国和罗马共同的上下文是相似的，才会有这样的相等关系。而仔细考虑一下，这两对词的上下文确实是有可能比较像的，比如一篇介绍欧洲国家的文章，这些词所在的语境肯定是很相近的，这也就是我们把这些词作为相似词的原因。</li>
</ul>
<h3 id="关于训练数据量"><a href="#关于训练数据量" class="headerlink" title="关于训练数据量"></a>关于训练数据量</h3><ul>
<li>本文还有一个比较重要的思想是：简化模型，提升学习效率，利用更大的训练量来求得更好的训练效果。作者一开始就是因为神经网络模型的计算量太大，因此舍弃了隐含层，简化模型，从而提出了CBOW和Skip-gram这两个模型。</li>
<li>这样做虽然可能会损失一部分隐含层所提升的精度，但计算开销大大降低了，结合分布式学习模型，可以极大地提升训练量和向量维度的上限，从而弥补因简化模型而损失的精度。实验结果证明了这样的方案是可行的，这也为我们今后如何改善模型精度提供了一个思路。</li>
</ul>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><h3 id="关于CBOW模型的语义问题"><a href="#关于CBOW模型的语义问题" class="headerlink" title="关于CBOW模型的语义问题"></a>关于CBOW模型的语义问题</h3><ul>
<li>在CBOW模型中，所有的单词最终都会映射到同一位置，模型是不考虑单词顺序的。我认为这样做主要是因为CBOW模型的作用是从上下文中推测相关的单词，即模型关注的是文章中是否出现单词，并不关注单词出现的顺序，因此舍弃顺序也是合理的。  </li>
<li>但这样做也会有一定问题，即一些语句虽然单词组成一样，但语义却有明显不同。如“李丽是谁的姐姐”和“李丽的姐姐是谁”，这两句话的词袋模型是完全一致的，但如果不考虑语法结构，我们很难得出正确的结果。因此在这种情况下，我们可以将词袋模型和句法分析相结合，来求出句子的真正含义。</li>
</ul>
<h3 id="CBOW模型和Skip-gram模型与神经网络相结合"><a href="#CBOW模型和Skip-gram模型与神经网络相结合" class="headerlink" title="CBOW模型和Skip-gram模型与神经网络相结合"></a>CBOW模型和Skip-gram模型与神经网络相结合</h3><ul>
<li>文章最后提到神经网络词向量和其他技术的结合可能会有很好的效果，作者在微软的挑战赛中也通过Skip-gram+RNNLMs取得了很高的预测精度，说明这个结合思路是可行的。  </li>
<li>因为首先CBOW和Skip-gram都未考虑单词的顺序，会带来一定的语义问题；同时RNN模型本身具有自连接性质，这可以使其对前后的单词的关联性有更好的“记忆”，因此两者结合可能会有互补的效果。关于实现，可以将两者的词向量模型以一定权重进行组合，得出新的词向量，以探究其在相关问题中的表现效果。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/Paper Notes/Efficient Estimation of Word Representations in Vector Space/" data-id="cjo6b5dh600264sqxqz7dhyzf" class="article-share-link" data-share="baidu" data-title="Notes of Efficient Estimation of Word Representations in Vector Space读书笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/Paper Notes/Efficient Estimation of Word Representations in Vector Space/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper-Notes/">Paper Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Paper Notes/On Availability For Blockchain based Systems" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/Paper Notes/On Availability For Blockchain based Systems/" class="article-date">
  <time datetime="2018-09-13T07:49:59.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/Paper Notes/On Availability For Blockchain based Systems/">On Availability For Blockchain based Systems读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a href="https://research.csiro.au/data61/wp-content/uploads/sites/85/2016/08/OnAvailabilityForBlockchain-BasedSystems-SRDS2017-authors-copy.pdf" target="_blank" rel="noopener">论文地址点这里</a></p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>  

<h2 id="论文内容概述"><a href="#论文内容概述" class="headerlink" title="论文内容概述"></a>论文内容概述</h2><p>这是一篇偏重实验的论文，通过研究影响交易提交时间的因素，探讨了目前区块链的可靠性问题，并提出了一种交易终止策略来解决这个问题。</p>
<h3 id="简介-INTRODUCTION"><a href="#简介-INTRODUCTION" class="headerlink" title="简介(INTRODUCTION)"></a>简介(INTRODUCTION)</h3><ul>
<li><p><strong>区块链的可靠性问题</strong><br>可靠性保证不透明：从应用的角度上来说，并不清楚区块链技术是如何保证系统的可靠性的，而且多数区块链系统只能以一定概率保证交易信息的不变性。<br>提交时间不稳定：客户端不可预知交易成功提交所需的时间。从Fig.1中可看出，61.5%的交易在3分钟内就提交了，但13.8%的交易4.5分钟还没提交(延迟了50%)，提交时间的差异可能系统可用性的下降。</p>
</li>
<li><p><strong>论文主要研究内容</strong>  </p>
<ul>
<li>导致交易无法成功提交的因素</li>
<li>以太坊中的transaction inclusion机制</li>
<li>以太坊中gas price和gas limit两个参数对提交时间的影响</li>
<li>以太坊中block gas limit的影响</li>
<li>交易终止机制</li>
</ul>
</li>
</ul>
<h3 id="背景知识-BACKGROUND"><a href="#背景知识-BACKGROUND" class="headerlink" title="背景知识(BACKGROUND)"></a>背景知识(BACKGROUND)</h3><ul>
<li><p><strong>区块链基本知识</strong><br>区块链可认为是一个分布式的公共账本，记载了交易信息和资产信息。区块链中的每个用户本地都存储着一个账本的副本，并运行着一个客户端，负责和整个网络同步更新账本信息。</p>
</li>
<li><p><strong>区块链中的链指什么</strong><br>区块链系统的交易信息存储在区块(block)中，从第二个区块开始，每个区块都有前一区块的哈希值，即相当于把各个区块链起来了，最终各个区块按时间顺序链接起来呈现一套完整的数据(区块链大账本)。 </p>
</li>
<li><p><strong>区块链加密技术</strong><br>区块链采用了非对称加密技术，和传统对称加密最大不同是，加密和解密不再是同一把钥匙，而是分为公钥和私钥。只有特定的用户具有私钥，可以对交易信息进行加密和数字签名；而所有的用户都具备公钥，可以对交易信息解密，并通过数字签名验证交易签署者的身份。 </p>
</li>
<li><p><strong>共识算法</strong><br><strong>问题背景：</strong>因为区块链是分布式存储的，所有节点都需要对区块链中块的内容和次序达成“共识”，为了解决这个问题就提出了共识算法。<br><strong>工作量证明算法(POW)：</strong>这是目前最广泛使用的共识算法，其基本原理是：一个节点将交易信息打包到区块中，并添加一个随机数，再做哈希和运算，之后将块发布到网络中。其他节点接收到块后，根据块中包含的参数进行大量的计算(俗称挖矿)，计算出的结果如果小于哈希和，即完成了这部分工作，得出的结果值就相当于对其工作量的“证明”。拥有“证明”后节点不仅会获得一定奖励，也拥有了创建区块的权利，新创建的区块会加到主链末端，其他节点可在其后面继续添加新区块，其后每添加一个区块，就相当于做了一次确认，当其后的区块达到了一定数量后(比特币是6个，以太坊是12个)，就相当于和网络中其他节点达成“共识”了，这个区块即正式被记录在案了。<br><strong>核心思想：</strong>工作量证明机制的核心思想是工作方要得出结果具有一定难度，但验证方检查结果却非常容易，因此很容易验证工作方是不是做了相应工作。既保证了工作完成后奖励的价值(需要付出大量的计算代价)，激励节点去积极打包交易信息，同时验证的简单性也保证了共识算法的效率和可靠。</p>
</li>
<li><p><strong>分叉问题(fork)</strong><br><strong>基本概念：</strong>考虑一种小概率情况，两个节点恰好同时完成了计算，创建了区块，并向全网进行了广播，这种情况就叫做分叉。形象的理解就是区块链主链的末端被连了两个块，像是分叉了一样。<br><strong>分叉的影响：</strong>正常情况下，网络中所有的节点达成共识，所生成的区块链就是一条主链，内容、次序都是确定的；而在分叉的情况下，区块链会向两个不同的方向延申(因为每一个区块都是依赖于上一个区块产生的)，主链的内容、次序就不确定了，各节点即无法正常地查询交易和资产信息。<br><strong>解决办法：</strong>所有节点都从当前最长的链开始工作。因为有统计结论，链中的区块数越多，越不容易发生分叉现象。</p>
</li>
</ul>
<h3 id="比特币交易的提交-COMMIT-OF-BITCOIN-TRANSACTIONS"><a href="#比特币交易的提交-COMMIT-OF-BITCOIN-TRANSACTIONS" class="headerlink" title="比特币交易的提交(COMMIT OF BITCOIN TRANSACTIONS)"></a>比特币交易的提交(COMMIT OF BITCOIN TRANSACTIONS)</h3><p>在本节中，作者讨论了影响比特币提交时间的因素，并进行了实验验证。</p>
<ul>
<li><p><strong>影响交易提交时间的因素</strong><br><strong>交易手续费(transaction fee)：</strong>手续费的多少会影响节点打包交易信息的积极性，从而影响交易提交的时间。<br><strong>交易是否按顺序到达：</strong>如果一个交易比其所引用的父交易先到达，则被称为orphan。只有父交易提交后，子交易才能提交，否则子交易就会一直在mempool中等待。<br><strong>锁定时间(locktimes)：</strong>这是一个用户可设置的参数，可使得某个交易在特定顺序的区块产生之前一直处于不可用状态。  </p>
</li>
<li><p><strong>实验过程</strong><br><strong>实验任务：</strong>观测交易的产生并记录其提交所花费的时间。为了探究不同网络环境下的情况，作者在2016年11月和2017年4月分别进行了两次实验（第二次实验的网络负载较大）。<br><strong>观测窗口：</strong>为了充分收集包含在区块链中的交易信息，作者定义了观测窗口：从实验开始前的第一个区块到实验结束24h后的一个区块，这之间的交易即处于观测窗口中，都会被记录下来。</p>
</li>
<li><p><strong>实验结果</strong><br>作者主要研究的交易有两类：<strong>Straight-accepts</strong>和<strong>Oranphans</strong>。<br>实验结果1（针对到达顺序因素）：由Fig.2可知两次实验中，Oranphans的提交时间都比Straight-accepts的时间要长，且在第二次实验中尤为明显，可见到达的顺序对提交时间有着显著的影响，按顺序到达的交易比无序到达的交易时间要短很多。<br>实验结果2（针对交易手续费因素）：由Fig.3可知，交易手续费和提交时间之间并没有显著关联。<br>实验结果3（针对locktimes因素）：通过作者分析可知，绝大多数交易并未使用locktimes这个参数，且Oranphans和Straight-accepts这两类交易结束锁定的时间差异也很大，最终作者认为locktimes并非是Oranphans延迟的主要因素。  </p>
</li>
</ul>
<h3 id="以太坊交易的提交-COMMIT-OF-ETHEREUM-TRANSACTIONS"><a href="#以太坊交易的提交-COMMIT-OF-ETHEREUM-TRANSACTIONS" class="headerlink" title="以太坊交易的提交(COMMIT OF ETHEREUM TRANSACTIONS)"></a>以太坊交易的提交(COMMIT OF ETHEREUM TRANSACTIONS)</h3><p>在本节中，作者介绍了以太坊不能保证提交的原理，并实验研究了gas price、gas limit、network三个因素对提交时间的影响。</p>
<ul>
<li><p><strong>以太坊中交易事务的生命周期</strong><br>1、交易声明：交易发生并声明。<br>2、交易打包进区块：发布节点将交易信息打包到区块中。<br>3、区块链接到主链：节点完成打包计算，将区块链接到主链。<br>4、交易正式提交：其后链接了一定数量的区块后，即正式提交。<br>注：因为分叉现象或其他原因，步骤2并不能保证交易最终一定被提交，这就产生系统的可靠性问题。</p>
</li>
<li><p><strong>实验过程</strong><br>实验任务：研究交易从打包到最终提交所花费的时间以及分支合并后会丢失多少已打包的交易。<br>创建监听节点：作者改写了一个客户端节点作为监听节点，以检测交易声明和区块声明。<br>记录时间：监听节点会记录交易声明的时间和区块到达的时间，以计算交易提交的延迟时间。<br>计算方法：根据交易声明的时间和包含此交易的第一个区块到达的时间，我们计算这之间的时间差，结果就是Fig.5中的<br><code>1st inclusion</code>；当第一个块变为叔块时，我们可根据包含此交易的第二个区块到达的时间，计算出<code>2nd inclusion</code>；同理，<br><code>3rd inclusion</code>也是这么计算的；此外，我们根据最后一个区块的到达时间，可以计算出<code>12 confirmations</code>和<code>36 confirmations</code>。将上述计算出的结果绘成图表，就是文中的Fig.5。</p>
</li>
<li><p><strong>实验结果</strong><br>实验结果1（各类提交时间的对比）：从Fig.5中可知，相比1st/2nd/3rd inclusion，12/36 conclusion的提交时间更长，而36 conclusion尤为明显，这说明交易数量越多，交易提交所花费的时间越长。<br>实验结果2（针对gas price因素）：从Fig.6中可知，总体趋势是gas price越高，延时越短，但gas price高于25Gwei后对延时的影响就非常小了。这也侧面解释为什么大部分交易定价在[20,25)的区间内(性价比最高)。<br>实验结果3（针对maximum gas因素）：虽然有个别交易因maximum gas过高而有明显的延时，但作者依旧认为maximum gas和提交时间之间没有很强的关联性。<br>实验结果4（针对network delays因素）：虽然没有得出明确的结论，但作者分析了in-order和out-of-order交易在提交延迟和数量方面的数据后，认为网络延迟对交易的传播是有负面影响的。</p>
</li>
</ul>
<h3 id="BLOCK-GAS-LIMIT对以太坊的影响-IMPACT-OF-THE-BLOCK-GAS-LIMIT-IN-ETHEREUM"><a href="#BLOCK-GAS-LIMIT对以太坊的影响-IMPACT-OF-THE-BLOCK-GAS-LIMIT-IN-ETHEREUM" class="headerlink" title="BLOCK GAS LIMIT对以太坊的影响(IMPACT OF THE BLOCK GAS LIMIT IN ETHEREUM)"></a>BLOCK GAS LIMIT对以太坊的影响(IMPACT OF THE BLOCK GAS LIMIT IN ETHEREUM)</h3><ul>
<li><p><strong>产生原因</strong><br>出台gas limit per block的原因是希望通过限制每个区块消耗的gas总量，防止DDoS攻击。如果交易所需的气体超过了限制值，交易就无法被包含到块中，这就使得大规模的分布式拒绝服务攻击难以发生。</p>
</li>
<li><p><strong>问题背景</strong><br>在没有限制之前，签署合约花费了150万的气体，因此作者认为限制会对合约相关的交易产生负面影响，但对单纯的资金转移交易应该影响不大，之后作者即针对这个观点进行了分析。</p>
</li>
<li><p><strong>分析结果</strong><br>由Fig.10可知，在50万气体的限制下，有46.21%的合约类交易无法正常进行；在200万气体的限制下，也有18.78%的合约类交易无法产生。因为气体限额的存在，大量的合约类交易无法进行，这也验证了作者之前的观点。</p>
</li>
</ul>
<h3 id="以太坊的交易终止机制-TRANSACTION-ABORT-IN-ETHEREUM"><a href="#以太坊的交易终止机制-TRANSACTION-ABORT-IN-ETHEREUM" class="headerlink" title="以太坊的交易终止机制(TRANSACTION ABORT IN ETHEREUM)"></a>以太坊的交易终止机制(TRANSACTION ABORT IN ETHEREUM)</h3><p>这一节主要对应了作者在摘要中提到的观点：终止机制的缺失会使大量交易处于既未终止也未提交的”pending”状态，严重影响系统的可靠性。为解决这个问题，作者提出了一种交易终止的机制，并进行了实验考察。</p>
<ul>
<li><p><strong>终止原理</strong><br><strong>竞争法：</strong>如果先前的交易\(Tx_i\)在规定的时间内未提交，账户可以重新发布一个具有相同nonce序号的交易\(Tx_i^{\prime}\)，赋予其更高的手续费，并将交易的接收方设为自己。一旦\(Tx_i^{\prime}\)成功提交，\(Tx_i\)就会自动过期了，即终止了其状态。<br><strong>重传法：</strong>账户重新发布一个与\(Tx_i\)内容相同的交易\(Tx_i^{\prime\prime}\)，但设置较高的手续费，这样虽然\(Tx_i^{\prime\prime}\)交易信息和\(Tx_i\)是一样的，但数字签名和哈希值却不一样(因为手续费不一样)，这样其他节点会把其当作一个新的交易。只要交易\(Tx_i\)和\(Tx_i^{\prime\prime}\)任何一个成功提交了，另外一个即过期了(因为nonce是一样的)，这样也可以达到终止的目的。</p>
</li>
<li><p><strong>实验模拟的三种情况</strong><br>1、交易在规定时间内没有被打包<br>2、因为手续费不足，用户决定撤回之前发布的交易<br>3、因为账户余额不足，交易无法被正常提交，即进入”pending”状态</p>
</li>
<li><p><strong>对情况1的实验</strong><br>实验原理：为了降低交易被打包的概率，作者减少了交易的手续费，分别为市场均价的0%、10%、…、90%，并设置了10min的截止时间。如果截止时间内原交易未提交，就按照上文提到的竞争法进行终止。<br>实验结果1：大部分交易都成功提交了，甚至30%-90%市场价的交易全部成功提交。出现这样的情况，我猜测可能是因为设置的终止时间太长了，即虽然手续费低，但只要时间足够长，交易还是有可能成功提交的。<br>实验结果2：在0-20%市场价的交易中，有16个没有成功提交，但最后都成功终止了，终止成功率为100%。</p>
</li>
<li><p><strong>对情况2的实验</strong><br>实验原理：这种情况考虑的是客户端希望撤回原先的交易，因此相比情况1，设置的截止时间要短一些（因为如果再设置很长时间的话，就失去模拟用户自行撤回的意义了），实验中是取所有交易提交时间的中位点，即3min。<br>实验结果1：截止时间缩短后，未提交的交易数明显增多，总共有53个交易没有提交，甚至0-20%市场价的交易全部没有提交成功，这也验证了我在实验1中的猜想。<br>实验结果2：虽然未提交的交易数量大大增加，但依旧每个交易都成功终止了，成功率为100%。</p>
</li>
<li><p><strong>对情况3的实验</strong><br>实验原理：首先作者创建了两个交易：\(Tx_1(bonce=n+1,value=\frac {k} {1000})\)和\(Tx_1(bonce=n+1,value=\frac {999k} {1000})\)，k为当前账户的余额。其次为了模拟余额不足这种情况，作者采用了一种很巧妙的方式：先发送\(Tx_2\)，隔5s后再发送\(Tx_1\)，这样可以使得\(Tx_2\)顺利发出，因为先发\(Tx_1\)的话，一旦其被顺利打包，\(Tx_2\)就会因为余额不够而无法发送到网络中了。采用这种方式，\(Tx_2\)就有可能比\(Tx_1\)先发到网络中，又因为\(Tx_1 nonce&lt;Tx_2 nonce\)，所以\(Tx_1\)必然会比\(Tx_2\)先打包，这样\(Tx_2\)就会因余额不够而停滞在网络中，即成功模拟了因余额不足所导致的”pending”状态。<br>实验结果：作者进行了100次实验，终止成功率依然是100%，结合前两次实验的结果，说明终止机制的效果还是非常好的。</p>
</li>
</ul>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><h3 id="对于区块链的理解"><a href="#对于区块链的理解" class="headerlink" title="对于区块链的理解"></a>对于区块链的理解</h3><ul>
<li>区块链的本质是一个去中心化的分布式账本。我认为区块链就是一个账本，记载了所有交易信息和资产信息，但和传统金融记录方式的不同在于，区块链账本并非存储在某一个中心，其在每一个用户的本地都有存储的副本，相当于每个用户都是一个中心。  </li>
<li>去中心化带来的好处：首先是不用考虑中心的故障问题，就像双11，你再想买一个东西，淘宝服务器一旦瘫痪就不行了，所有的交易都依赖于这个第三方的中心；其次是不用担心信息泄露的问题，还是淘宝的例子，你要买东西、卖家要卖东西，都要提供个人信息，交易完成后也会产生交易信息，这些都被存在淘宝的服务器中，在当今这个强调个人隐私的时代，这是非常让人困扰的；第三是安全，区块链技术具有不可篡改性，我们不用担心因第三方中心的原因导致我们的资产受损失(如银行破产)。  </li>
<li>去中心化带来的问题：最大的问题是我们如何在各个节点间同步数据。在中心化系统中，中心说什么就是什么，其他人只需和中心保持同步即可；而在去中心化系统中，我们需要和全网进行同步，难度增大了很多，为了解决这个问题，也就出现了共识机制，大家共同记账，一定数量的节点达成共识后，就可正式在网络中进行同步了；而为了提高大家记账的积极性，就出现了工作量证明算法，对于成功记账的人会有奖励，大家都去积极记账了，账本自然就可以不断地维护、更新了。</li>
</ul>
<h3 id="对于区块链可靠性的理解"><a href="#对于区块链可靠性的理解" class="headerlink" title="对于区块链可靠性的理解"></a>对于区块链可靠性的理解</h3><ul>
<li>本文对于区块链可靠性的研究主要围绕“交易提交时间”这个概念，一个交易产生了，最好的情况是在规定时间内顺利打包，加入到区块链主链中。但因为复杂的网络环境、交易手续费或其他种种因素，一个交易的提交很可能会产生延迟，甚至会出现交易既没有提交、又没有销毁的”pending”状态。  </li>
<li>这就需要我们去探讨两个方面的问题：到底有哪些因素会影响交易的提交时间？交易如果没有顺利提交我们应该采取什么办法？前者就是文章第三、第四节主要研究的内容，通过具体的实验分析了各种可能影响因素；后者则是作者在第六节研究的内容，提出了一种交易终止机制并进行了实验测试。</li>
</ul>
<h3 id="对于交易终止机制的理解"><a href="#对于交易终止机制的理解" class="headerlink" title="对于交易终止机制的理解"></a>对于交易终止机制的理解</h3><ul>
<li>文中提到了两种交易终止的方法：竞争法和重传法，虽然有些区别，但本质思想都是一样的，都是利用了“nonce相等”的原理来终止原来的交易。  </li>
<li>文中还提到，虽然以太坊不像比特币那样把每一个块都链接起来，但其每个块都有唯一的顺序号nonce，而且主链上的区块必须是按顺序的，因此我们就可以利用nonce号来使某次交易过期，从而达到终止的目的。</li>
</ul>
<h3 id="其他一些感想"><a href="#其他一些感想" class="headerlink" title="其他一些感想"></a>其他一些感想</h3><ul>
<li>论文中还有一点使我印象很深刻，就是整篇文章都贯穿着实验的思想，作者进行了大量的实验去研究某些因素的影响，对所提出的终止机制也进行了具体的实验探究，实验过后还有对实验结果的合理分析，这些都使得整篇文章的逻辑结构很清晰，值得我在今后的科研工作中去学习。</li>
</ul>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><h3 id="对比特币实验中无序现象产生的原因进行研究"><a href="#对比特币实验中无序现象产生的原因进行研究" class="headerlink" title="对比特币实验中无序现象产生的原因进行研究"></a>对比特币实验中无序现象产生的原因进行研究</h3><ul>
<li>在第三节中，作者研究了到达顺序对交易提交时间的影响，最终得出了结论：顺序到达的交易比无序到达的交易的延时要短。</li>
<li>作者虽然分析出了现象，但对产生这种现象的原因并没有深入研究，我认为如果对无序现象产生的原因进行研究，也会有助于改善区块链系统的可靠性问题。</li>
<li>方案实现：可参考文中第三节引言部分提到的几种情况，我认为可以主要研究节点转发策略和节点负载这两个因素，转发策略的不同可能会打乱原先的交易分发顺序，从而使得交易无法按顺序到达其他节点；而节点负载主要会影响交易传播的速度，不同节点的传播速度如果不同，也可能会导致交易失序。有了初步的分析，我们可设计实验来具体研究：首先选择一定量的矿工节点，将其按照不同的转发策略和不同的节点负载进行分组，转发策略可通过观察客户端版本、研究底层转发行为的实现代码等方式得出，而节点负载可通过观测相应网络指标得到。之后可以对两种因素进行控制变量分析，从而研究其对交易到达顺序的影响。</li>
</ul>
<h3 id="对比特币实验2中部分Orphans数据未统计的情况进行改进"><a href="#对比特币实验2中部分Orphans数据未统计的情况进行改进" class="headerlink" title="对比特币实验2中部分Orphans数据未统计的情况进行改进"></a>对比特币实验2中部分Orphans数据未统计的情况进行改进</h3><ul>
<li>在比特币的实验2中，因为高网络负载的原因，有20%的Orphans交易最后未被打包到块中，观测样本因此少了20%，作者也认为这对实验结果是一个很大的限制，因此我认为可根据这一点做下改进。  </li>
<li>方案实现：我考虑了两种思路，思路一：选择网络负载比实验2小但比实验1大的一个时间点，按照同样的方式做实验3，这样既可观测到不同网络环境下的实验结果，也可以减小网络负载对Orphans交易的影响，不至于使实验观测到的样本减少太多；思路二：保持实验1和实验2的网络条件不变，增加观测窗口的时长，分别进行实验3和实验4。由Fig.2可知计算的是累积比例，因此增加观测窗口相当于延长了一段X轴，Orphans Exp 2这条线最终就有机会到达1，而对其他三条曲线则不会有影响(它们已经很接近1了)，因此就可收集到更多的Orphans数据。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/Paper Notes/On Availability For Blockchain based Systems/" data-id="cjo6b5dhb002g4sqxvrcukuog" class="article-share-link" data-share="baidu" data-title="On Availability For Blockchain based Systems读书笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/Paper Notes/On Availability For Blockchain based Systems/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper-Notes/">Paper Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/MOOC_C语言程序设计笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/Algorithm/MOOC_C语言程序设计笔记/" class="article-date">
  <time datetime="2018-09-13T07:49:58.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/Algorithm/MOOC_C语言程序设计笔记/">MOOC_C语言笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="第一节-基础知识"><a href="#第一节-基础知识" class="headerlink" title="第一节_基础知识"></a>第一节_基础知识</h2><ul>
<li><strong>STL：</strong>C++中的标准模板库</li>
<li><p><strong>define和typedef</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 9999  <span class="comment">//宏定义，多用来替代常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; MAP; <span class="comment">//为复杂的类型定义取别名，简化程序，也便于修改。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型取值范围</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字节数</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">-2^31~2^31-1(-21亿~21亿)</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-2^63~2^63-1(很大)</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3.4x10^-38~3.4x10^38(绝对值)</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1.7x10^-308~1.7x10^308(绝对值)</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127</td>
</tr>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">1</td>
<td style="text-align:center">true/false</td>
</tr>
</tbody>
</table>
<ul>
<li><p>double类型比较相等：相减-&gt;是否小于一个很小的数(0.00001)。<br>比大小：直接&gt; &lt; 比较即可。</p>
</li>
<li><p>求字节数：sizeof(int)/sizeof(n)</p>
</li>
<li><p>反斜杠\，转义字符、win下地址路径；正斜杠/，网址路径。</p>
</li>
<li><p>字符型和整型数据可以相互转换，整型-&gt;字符型：只留最右边8位，再转成ASCII码。</p>
</li>
<li><p>常用ASCII码：<br>‘0’-‘9’：48-57<br>‘A’-‘Z’：65-90<br>‘a’-‘z’：97-122</p>
</li>
<li><p>十六进制常量：0x打头,0xFFA，1个十六进制位对应4个二进制位。<br>表示二进制：转化为16进制。00101011-&gt;0x2b</p>
</li>
<li><p>八进制整型常量：0打头，0677,1个八进制位对应3个二进制位。</p>
</li>
<li><p><strong>位运算</strong><br>单独对某些比特进行操作<br><strong>与&amp;</strong>：将某些位置0、获取变量中的某一位<br>eg：判断n的第7位是否为为0，n&amp;0x80==ox80？</p>
</li>
</ul>
<p><strong>或|</strong>：将某些位置1</p>
<p><strong>异或^</strong>：相同为0不同为1。将某些位按位取反，其他位不变：取反的与1异或，其他与0异或。</p>
<p><strong>非~</strong>：按位取反。</p>
<p><strong>左移&lt;&lt;</strong>：左移n位即乘2的n次方，但比乘法要快很多。</p>
<p><strong>右移&gt;&gt;</strong>：除2的n次方，且向小取整。高位补符号位。</p>
<h2 id="第二节-数据结构"><a href="#第二节-数据结构" class="headerlink" title="第二节_数据结构"></a>第二节_数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>初始化：类型名 数组名[数量]={x1,x2,x3,x4..} 或 用for循环初始化。<br>数组越界编译器不会报错，会根据内存地址去访问，数组名即相当于内存地址。<br><strong>编程技巧：可用数组取代复杂的switch case分支结构</strong></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><strong>字符串三种形式</strong><br>1、字符串常量，双引号括起来””。<br>2、存放在char数组中，以’\0’结尾，多占一个数组元素。<br>3、string对象，c++标准模板库中的类。<br>注：char数组比string快，但char数组没法传字符串值，只能传数组首地址。因此在一些需要传值的场合，用string更合适。</li>
</ul>
<p>字符串在内存占的字节数等于字符数目加1(‘\0’的存在 )<br><strong>读入字符串</strong>：cin或scanf，读到空格为止。空格后内容在下一次cin读入。<br><strong>读一行</strong>：cin.getline(char buf[],int bufSize)，读入不超过bufsize-1个字符</p>
<h3 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> ID;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> fGPA;</span><br><span class="line">    Student* frd;<span class="comment">//成员可以是结构体的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s1 = &#123;<span class="number">1234</span>,<span class="string">"TOM"</span>,...&#125;;<span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1.ID;</span><br><span class="line">Student* s2;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2-&gt;ID; / <span class="built_in">cout</span>&lt;&lt;(*s2).ID;指针访问成员</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>局部变量：</strong>定义在函数内部、语句块内部的变量。<br><strong>全局变量：</strong>定义在函数外部(main函数外)，在所有函数中均可使用。默认初始化为0.<br><strong>静态变量：</strong>全局变量和static定义的变量。生存期一直持续到整个程序结束。<br><strong>PS：</strong>若未初始化，静态变量默认赋值为0，非静态变量值为随机的。</p>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> x1:</span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">//有无中括号都可以</span></span><br><span class="line">    <span class="keyword">case</span> x2:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三节-函数与输入输出"><a href="#第三节-函数与输入输出" class="headerlink" title="第三节_函数与输入输出"></a>第三节_函数与输入输出</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数定义：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">return</span> xx ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数声明：(无函数体，常写在开头)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;<span class="comment">//一维数组作形参，不用写大小。int a[]与int *a等价。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fan3</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>])</span><span class="comment">//二维数组作形参，行数不用写，列数必须写</span></span></span><br></pre></td></tr></table></figure>
<p>函数的形参是实参的<strong>拷贝</strong>，形参的改变不会影响实参。(除非形参是数组、引用或对象)<br>string类型也是传值<br>数组作形参传的是首地址，并非整个数组。</p>
<h3 id="printf、scanf格式化输入输出"><a href="#printf、scanf格式化输入输出" class="headerlink" title="printf、scanf格式化输入输出"></a>printf、scanf格式化输入输出</h3><p>比cin/cout效率高，尽量使用。<br>%：类型占位符</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">int类型</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">char类型</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">float类型</td>
</tr>
<tr>
<td style="text-align:center">%lf</td>
<td style="text-align:center">double类型</td>
</tr>
<tr>
<td style="text-align:center">%.xlf</td>
<td style="text-align:center">输出x位小数</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;   //头文件</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"这是字符型数据%c，这是int型数据%d"</span>，ch,i);  <span class="comment">//格式化输出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);  <span class="comment">//记得加&amp;，返回值是接收变量的个数</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,c); <span class="comment">//读入字符串，检测到/0结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值为EOF(-1)时说明输入结束</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(xxx) != EOF)&#123;</span><br><span class="line">    <span class="comment">//循环读入数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.peek()   <span class="comment">//看一个字符不取走</span></span><br><span class="line"><span class="built_in">cin</span>.putback(c)  <span class="comment">//把字符放回输入流头部</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>函数读空格和换行：</span><br><span class="line">如果是%d、%f数值类型，会自动跳过多余的空格和换行，如果是%c会读入空格和换行。</span><br></pre></td></tr></table></figure>
<h3 id="freopen重定向"><a href="#freopen重定向" class="headerlink" title="freopen重定向"></a>freopen重定向</h3><p>将输入由键盘重定向为文件(不用每次都输入测试数据)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">"c:\\xxx.txt"</span>，<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(...)!=EOF)&#123;</span><br><span class="line">    <span class="comment">//从txt文件中输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="cin函数"><a href="#cin函数" class="headerlink" title="cin函数"></a>cin函数</h3><p>cin &gt;&gt; n &gt;&gt; m;<br>返回True(成功接收所有输入)或false()<br>while(cin &gt;&gt; n){<br>    //循环读入数据<br>}<br>注：cin读入的格式由后面的变量决定，若为char即读入一个字符，int则读入一个整数(遇到空格/换行为止)</p>
<h2 id="第四节-指针"><a href="#第四节-指针" class="headerlink" title="第四节_指针"></a>第四节_指针</h2><ul>
<li><strong>指针</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指针变量，<span class="number">4</span>个字节，内容表示一个内存地址。</span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">//p类型：int *，*p的类型：int</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> *pc = &amp;c1; <span class="comment">//pc指向变量c1</span></span><br><span class="line"><span class="comment">//*：间接引用运算符。&amp;：取地址运算符。</span></span><br><span class="line"><span class="comment">//&amp;x：变量x的地址，就是指向x的指针，类型是 T*。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>指针的意义：不需要通过变量，即可自由访问内存空间。</p>
<ul>
<li><p><strong>指针互相赋值</strong><br>不同类型的指针，如果不经过强制类型转换，不能直接相互赋值。 (每个指针类型还代表着一次向内存读/写多少字节)<br>char <em>c = ‘A’;<br>int </em>p = (int <em>)c;
</em>p=122; //此时’A’后面三个字节的值也会被改变。</p>
</li>
<li><p><strong>指针的运算</strong></p>
</li>
</ul>
<ol>
<li>指针比大小：比p1和p2地址的大小</li>
<li>指针相减：p1-p2=(地址p1-地址p2)/sizeof(T)</li>
<li>p+n=p+n*sizeof(T)，结果还是指针。</li>
<li>p[n]=*(p+n)</li>
</ol>
<ul>
<li><p><strong>空指针</strong><br>指向地址0的指针，int *pn=NULL;</p>
</li>
<li><p><strong>指针和字符串</strong><br>字符串常量、字符数组的类型都是char*。</p>
</li>
<li><p><strong>void指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以用任何类型的指针对<span class="keyword">void</span>指针进行赋值</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">但*p、P+n、p++等均无意义</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>void*自动匹配</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>函数</span><br><span class="line">void* memset(void* dest,int ch,int n)：将dest开始的n个字节都设置为ch(取其最低位字节)，初始化数组。</span><br><span class="line"><span class="comment">//对char数组赋值时，结尾要加'\0'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>函数</span><br><span class="line">void* memcpy(void* dest,void* src,int n)：将n个字节拷贝src-&gt;dest。</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a1[<span class="number">10</span>]=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">char</span> a2[<span class="number">10</span>]=<span class="string">""</span>;</span><br><span class="line"><span class="built_in">memset</span>(a1, <span class="string">'a'</span>, <span class="keyword">sizeof</span>(a1)<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(a2, a1, <span class="keyword">sizeof</span>(a2));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出aaaaaaaaaa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向函数入口地址的指针</span></span><br><span class="line"><span class="keyword">int</span> (*Pf)(<span class="keyword">int</span>,<span class="keyword">char</span>)</span><br><span class="line">pf = fun_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第五节-基本STL"><a href="#第五节-基本STL" class="headerlink" title="第五节_基本STL"></a>第五节_基本STL</h2><ul>
<li><strong>库函数和头文件</strong><br>库函数：编译器自带的函数<br>头文件：包含许多库函数的声明</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">//sort(数组名+n1,数组名+n2)，对数组[n1,n2)区间排序，默认从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">15</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;</span><br><span class="line">sort(a,a+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))  <span class="comment">//从小到大排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="comment">//#include &lt;functional&gt;头文件</span></span><br><span class="line">sort(a,a+<span class="number">7</span>,greater&lt;T&gt;())  </span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序规则</span></span><br><span class="line"><span class="keyword">bool</span> cmp(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a1,<span class="keyword">const</span> <span class="keyword">int</span> &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 &gt; a2;</span><br><span class="line">    <span class="comment">//若a1应排在a2前面，则返回true。否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">15</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;</span><br><span class="line">sort(a,a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cmp());</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul>
<li><strong>前提条件</strong><br>所有的二分查找，都是应用在<strong>有序</strong>列表中的。</li>
<li><p><strong>binary_search函数</strong><br>两种使用方法：<br><code>bool binary_search(数组名+n1,数组名+n2,值)</code><br><code>bool binary_search(数组名+n1,数组名+n2,值,排序规则结构名())</code>，查找时的规则必须和排序时的规则一致。<br>对排好序的数组进行二分查找，返回值true：找到，false：没找到。<br><strong>查找的本质：</strong>查找x，即找到一个元素y，使得“x必须排在y前面”和“y必须排在x前面”都不成立（和 == 的含义不一样），这样就算找到了；没有找到元素y，就是没找到。<br>所以不存在的元素同样有可能查的到（eg：按个位排序，查找的元素只要个位相等就能查到，十位/百位不一定会相等），因此查找的结果要视具体排序规则来分析。</p>
</li>
<li><p><strong>lower_bound函数</strong><br><code>T* lower_bound(数组名+n1,数组名+n2,值)</code><br>返回序号p，使得[n1,p)中元素都小于查找值。<br>若比所有元素都小/大，则指向n1/n2。<br>为避免返回序号为n1时的歧义，查前要确保值在数组范围内。</p>
</li>
<li><p><strong>upper_bound函数</strong><br><code>T* upper_bound(数组名+n1,数组名+n2,值)</code><br>返回指针p，使得[p,n2)中元素都大于查找值。</p>
</li>
</ul>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>在log(n)内快速添加、删除、查找元素<br>应用了平衡二叉树的四种<strong>排序容器</strong>：<code>multiset</code>、<code>set</code>、<code>multimap</code>、<code>map</code></p>
<h3 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h3><ul>
<li><p><strong>主要作用</strong><br>自动对集合内元素排序(默认从小到大)，且允许元素重复，在一些需要动态增加、删除元素的排序场景下使用很方便。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //头文件</span></span></span><br><span class="line"><span class="built_in">multiset</span>&lt;T&gt; st;</span><br><span class="line">T a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">multiset</span>&lt;T&gt; st2(a,a+<span class="number">5</span>); <span class="comment">//用数组初始化</span></span><br><span class="line">st.insert(a); <span class="comment">//插入元素a，自动排序。插入的是复制值，并非引用。</span></span><br><span class="line">st.erase(a);  <span class="comment">//删除元素a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合，用迭代器</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  <span class="comment">//定义迭代器，类似指针</span></span><br><span class="line"><span class="keyword">for</span> (it = st.begin(); it != st.end(); it++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="comment">//end()为末尾指针，指向最后一个元素的后面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it = st.find(a);   <span class="comment">//查找元素a，返回迭代器,没找到返回end()</span></span><br><span class="line"></span><br><span class="line">st.lower_bound(a);  <span class="comment">//返回迭代器it,使得[begin(),it)中元素都比a小，注意是前闭后开区间</span></span><br><span class="line"></span><br><span class="line">st.upper_bound(a)  <span class="comment">//返回迭代器it,使得[it,end())中元素都比a大</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义排序规则的multiset</strong><br>1、自定义规则结构体Rule，实现<code>bool operator()(const &amp; T,const &amp; T)</code>函数<br>2、定义容器multiset&lt;T,Rule&gt;<br>3、定义迭代器muliset&lt;T,Rule&gt;::iterator</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义规则结构体Rule方法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> &amp; T,<span class="keyword">const</span> &amp; T)</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h3><p>与multiset容器区别：不能有重复元素，其他都一样。<br>a和b重复的含义：a排在b前面、b排在a前面都不成立<br>注：因为不能重复，所以插入元素有可能不成功。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">set</span>&lt;T&gt;::iterator,<span class="keyword">bool</span>&gt; result = <span class="built_in">set</span>.insert(n);  </span><br><span class="line"><span class="comment">//result.second==true，插入成功；否则失败。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="multimap容器"><a href="#multimap容器" class="headerlink" title="multimap容器"></a>multimap容器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">键值对形式，<span class="built_in">multimap</span>中的元素都是pair形式。</span><br><span class="line">按first进行排序，一般不自定义排序。</span><br><span class="line"></span><br><span class="line">pair模板：pair&lt;T1,T2&gt;</span><br><span class="line">等价于</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    T1 first;  <span class="comment">//关键字</span></span><br><span class="line">    T2 second; <span class="comment">//值 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="built_in">multimap</span>&lt;T1,T2&gt; mp;</span><br><span class="line">mp.insert(make_pair(T1变量,T2变量))  <span class="comment">//make_pair为转换pair模板的函数</span></span><br><span class="line">multima&lt;T1,T2&gt;::iterator it  <span class="comment">//迭代器</span></span><br></pre></td></tr></table></figure>
<h3 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h3><p>和multimap区别：不能有关键字重复的元素<br>可以使用[first]查找second值；若first不存在，则创建一个。<br>插入可能失败(first重复)。</p>
<h3 id="camath数学库"><a href="#camath数学库" class="headerlink" title="camath数学库"></a>camath数学库</h3><ol>
<li>abs(int x)：整数绝对值</li>
<li>fabs(double x)：浮点数绝对值</li>
<li>sqrt(double x)：求平方根</li>
<li>ceil(double x)：不小于x的最小整数(上取整)</li>
<li>sin(double x)/cos(double x)：x(弧度)的正/余弦</li>
</ol>
<h3 id="cstring字符串库"><a href="#cstring字符串库" class="headerlink" title="cstring字符串库"></a>cstring字符串库</h3><p>函数都是根据’\0’来判断字符串是否结束的。</p>
<ol>
<li>形参常为char c[]，实参可以为char数组或字符串常量。</li>
<li>int strcmp(char c1[],char c2[])：比较字符串，相等返回0，c1小返回负数。</li>
<li>char* strcpy(char dest[],char src[])：拷贝字符串src-&gt;dest，返回dest首地址。</li>
<li>int strlen(char c[])：求字符串长度</li>
<li>char<em> strchr(char </em>str,char c)：str中查字符c是否在str中，返回指向位置的指针，未查到为NULL。</li>
<li>char<em> strstr(char </em>str1,char *str2)：str1中查子串str2位置，返回指向位置的指针，未查到为NULL。</li>
<li>cbar<em> strtok(char </em>str1,char* str2)：str1中抽取被str2分隔的子串。(将str1中的分隔符用’/0’代替了)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = strtok(str1, str2);</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		p = strtok(<span class="literal">NULL</span>, str2);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="ctype-h字符库"><a href="#ctype-h字符库" class="headerlink" title="ctype.h字符库"></a>ctype.h字符库</h3><ol>
<li>bool isdigit(int c)：判断c是否是数字字符</li>
<li>bool isalpha(int c)：判断c是否是字母字符</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/Algorithm/MOOC_C语言程序设计笔记/" data-id="cjo6b5dgp00194sqxnrcuj7mw" class="article-share-link" data-share="baidu" data-title="MOOC_C语言笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/Algorithm/MOOC_C语言程序设计笔记/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深度学习与Tensorflow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/深度学习与Tensorflow/" class="article-date">
  <time datetime="2018-09-13T07:49:58.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/深度学习与Tensorflow/">深度学习与TensorFlow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="深度学习概述"><a href="#深度学习概述" class="headerlink" title="深度学习概述"></a>深度学习概述</h2><h3 id="人工智能AI"><a href="#人工智能AI" class="headerlink" title="人工智能AI"></a>人工智能AI</h3><p>人工智能AI是计算机科学的一个分支，早在20世纪50年代就被提出了，著名的“图灵测试”就是AI发展的终极目标：如果某台机器运行的逻辑程序可以表现出与人类无法分辨的智能，则认为计算机有了思维，能够进行思考。从实用的角度讲，AI的目标是要让计算机自动完成那些需要人类智慧才能完成的工作。</p>
<h3 id="深度学习的起因"><a href="#深度学习的起因" class="headerlink" title="深度学习的起因"></a>深度学习的起因</h3><ul>
<li><p><strong>AI初期：专家系统</strong><br>AI发展初期，主要的思路是将人类总结的知识用一系列规范的、形式化的规则来表示，然后通过自动化的程序来代替人类处理问题，以知识为基础的<strong>专家系统</strong>（Knowledge-based expert system）就是这方面的典型代表。<br>专家系统是将专家的经验写成规则，再依照规则推理的方式来模拟专家的思维。专家系统没有获得太大的成功，原因在于系统会明显受到规则数量的限制，规则是有限的，而问题发生时的状况是无限的，用有限的规则处理无限的可能，注定很容易失败。</p>
</li>
<li><p><strong>专家系统-&gt;机器学习</strong><br>因此，“演绎法”的规则推理暂时行不通，“归纳法”就成了另一条出路，基于概率统计的机器学习（Machine Learning）逐渐成为了主流方法，其直接将大量真实世界产生的数据样本交给算法处理，让算法自己在数据中寻找和学习特定的规律，自己“归纳”知识。这种从数据中学习规律的过程也叫做“模式识别”。</p>
</li>
<li><p><strong>机器学习-&gt;深度学习</strong><br>但这之后机器学习也遇到了一些问题，例如，对于朴素贝叶斯、逻辑回归等经典机器学习算法，本质是计算输入样本和输出目标之间的<strong>隐含规律/相关性</strong>，但计算相关性其实是一个后续问题，在这之前我们首先要确定各个影响因素，而如何表示各个影响因素会严重影响相关性的判断。如要辨别一段语言中演讲者是男人、女人还是小孩，简单机器学习算法的判断依据很可能是音量而非音色和音调。因此设计合适的<strong>特征表示</strong>在机器学习中是一项非常重要的工作，被称为<strong>特征工程</strong>。但长期以来，合适特征的选取都非常困难，不仅费事费力，更需要人们提供大量的先验知识以弥补对数据本身挖掘不足而产生的缺陷。因此若要拓展机器学习的适用范围，必须要降低对特征工程的依赖性。因此也就出现了深度学习。<br>深度学习是一种<strong>表示学习</strong>（Representation Learning）方法，所谓表示学习，就是要让算法在少量人为先验知识的情况下，能够自己从数据中抽取合适的特征。而表示学习目前受到重视的另一个原因是对于人工智能，其目标就是让机器有能力理解我们所在的世界，只有当它学会如何感知和辨别数据背后的各种隐含因素时才能达到这个目标。<br>深度学习最主要的模型是<strong>深度神经网络</strong>，其思想是通过一些列非线性变换操作把从原始数据中提取的简单特征进行组合，从而得到更高层、更抽象的特征表示，这也对应着我们思维理解的过程。如对于文本分析，先认识各个字母，再认识由字母组成的单词，其次是词组、句子、段落，逐渐由简单向抽象映射。一般有<strong>三个</strong>以上隐含层的神经网络就称为深度神经网络。</p>
</li>
<li><p><strong>CPU和GPU</strong><br>促进深度学习的另一个因素是GPU的广泛使用。GPU的主要功能是渲染画面，涉及到坐标变换、栅格化、平面渲染等大量的浮点数计算操作。相比来说，CPU是面向通用计算的产品，GPU则是面向大规模浮点数并行计算的，因此GPU训练计算神经网络的效率会更高。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/深度学习与Tensorflow/" data-id="cjo6b5dg1000p4sqx5y8gbnwd" class="article-share-link" data-share="baidu" data-title="深度学习与TensorFlow">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/深度学习与Tensorflow/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MachineLearning/">MachineLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-微机接口技术与应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/微机接口技术与应用/" class="article-date">
  <time datetime="2018-09-13T07:49:58.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/微机接口技术与应用/">微机接口技术与应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

<blockquote>
<p>在微机系统中，微处理器的强大功能必须通过外部设备才能实现，而外设与微处理器之间的信息交换及通信又是靠接口实现的，所以，微机应用系统的研究和微机系统的产品的开发，从硬件角度来讲，就是接口技术的演进和开发。微机的应用随着外设的不断更新早已深入各个领域。</p>
</blockquote>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li><p><strong>CPU架构分类</strong><br>目前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，另一个是以IBM、ARM为首的精简指令集CPU。<br>Intel、AMD的CPU是X86、x64架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构<br>而对于Intelx86架构的CPU，最具代表性的就是1978年所推出的<code>Intel 8086</code>和之后推出的<code>Intel 8088</code>，被称为x86架构的鼻祖。<br>8086：16位处理器芯片，内部总线和外部总线都为16位，本笔记中的接口都是基于<strong>8086架构的</strong>。<br>8088：准16位处理器芯片，内部总线16位，外部总线8位</p>
</li>
<li><p><strong>总线位数</strong><br>内部总线：CPU位数，CPU一次处理的数据总线宽度，通用寄存器长度，ALU运算字长。<br>外部总线：系统总线位数，与内存交换数据的宽度，即数据总线。<br>注：内、外都是相对CPU而言的。<br>三总线：数据总线、地址总线、控制总线。<br>8086中，数据总线16位，地址总线20位，寻址空间<code>2^{20}=1MB</code>。</p>
</li>
<li><p><strong>主板芯片组</strong><br>CPU与周边设备沟通的桥梁，分为南桥和北桥。<br>南桥：PCI桥，CPU与外设的I/O。<br>北桥：HOST桥，离CPU更近，速率更快，用于CPU和内存、显卡、PCI桥交换数据。</p>
</li>
</ul>
<h3 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h3><p>接口指CPU与外设间信息交换的输入输出电路，CPU<->接口<->外设。<br>接口实现了外设与微机间的信息交换。</-></-></p>
<ul>
<li><p><strong>三类接口芯片</strong><br>通用接口芯片：并行接口、串行接口等。<br>面向微机专用接口芯片：不直接与外设连接，只是帮CPU分担工作，DMA控制器、中断控制器等。<br>面向外设专用接口芯片：显示器接口、键盘接口等。</p>
</li>
<li><p><strong>设立接口原因</strong><br>CPU与外设两者的工作速度不兼容<br>CPU与外设两者的信号不兼容<br>有利于外设的标准化</p>
</li>
<li><p><strong>接口电路一般结构</strong><br><img src="/images/接口技术及应用/接口电路一般结构.png" width="340" height="200" alt="接口电路一般结构" align="center"><br>DB, AB, CB即数据总线、地址总线、控制总线。<br>接口内主要有三类寄存器：命令口（CPU向其中写命令，只写）、状态口（CPU从其中读取接口的状态信息，只读）、数据口（CPU与外设间的交换信息，可读可写）。</p>
</li>
<li><p><strong>CPU与接口交换数据方式</strong><br><strong>程序控制方式：</strong>CPU主动。<strong>无条件传送方式</strong>（同步传送），外设一直是准备好的，传送前CPU不需要了解外设的状态，适合一些较简单的外设，如LED显示器；<strong>查询传送方式</strong>（条件传送），传数据前CPU先检测外设状态（状态字），外设没准备好，CPU就一直等待。<br><strong>中断方式：</strong>外设主动，CPU被动。外设做好准备时，主动向CPU发出中断请求，CPU响应中断。<br><strong>DMA方式：</strong>DMA控制外设与存储器间的数据传送，传送过程由特定硬件完成，无需CPU介入。</p>
</li>
</ul>
<h2 id="第二章-I-O端口地址译码技术"><a href="#第二章-I-O端口地址译码技术" class="headerlink" title="第二章 I/O端口地址译码技术"></a>第二章 I/O端口地址译码技术</h2><h3 id="端口地址"><a href="#端口地址" class="headerlink" title="端口地址"></a>端口地址</h3><p>I/O端口(Port)：指I/O接口电路中能被CPU直接访问的<strong>寄存器</strong>，CPU与外设间不能直接交换信息，必须通过端口。</p>
<ul>
<li><p><strong>端口编址方式</strong><br>采用小端模式，低字节在低地址，高字节在高地址。<br><strong>统一编址：</strong>端口地址和存储器地址是统一的，可直接用内存指令访问端口，无需专门的I/O指令。因此指令会比较长，且寻址速度慢。<br><strong>独立编址：</strong>端口地址和存储器地址独立，根据不同指令访问不同的地址（通过专门的I/O指令访问端口），<strong>8086中就是这种方式</strong>。</p>
</li>
<li><p><strong>8086中端口地址分配</strong><br>地址空间：<code>000-3FFH</code>，A0-A9共10根地址线，可访问1024个端口。<code>3FFH=15+15*16+3*16*16=1023</code>。<br>系统板上的I/O接口芯片：地址<code>000-0FFH</code>，单字节地址。较为简单的接口，定时器、中断控制器等。<br>扩展槽上的I/O接口卡：地址<code>100-3FFH</code>，双字节地址。若干个集成电路合在一起，较为复杂，显卡、声卡、网卡等。</p>
</li>
<li><p><strong>端口地址译码方式</strong><br>三种译码方式：全译码、部分译码和地址开关译码。<br><strong>全译码：</strong>所有I/O地址线A0~A9全部作为译码的输入参与译码。<br><strong>部分译码：</strong>将地址线分为两部分：<code>端口地址=芯片地址（高位）+片内地址（低位）</code>，只有高位地址线参加译码，可分为片间寻址与片内端口寻址。<strong>片间寻址：</strong>高位地址信号与控制信号组合，经译码电路产生接口的片选信号\(\small \overline{CS}\)。控制信号如：读信号\(\small \overline{IOR}\)、写信号\(\small \overline{IOW}\)等。<strong>片内端口寻址：</strong>低位地址信号不参加译码，直接连到接口芯片中，进行端口寻址。<br><img src="/images/接口技术及应用/部分译码.png" width="230" height="140" alt="部分译码示意图" align="center"><br><strong>地址开关译码：</strong>在部分译码方法的基础上，加上地址开关来改变端口地址。</p>
</li>
<li><p><strong>地址译码电路设计</strong><br><strong>固定式译码：</strong>接口中用到的端口地址不能更改，分为门电路译码和译码器译码。<strong>门电路译码：</strong>对单一端口地址进行译码，使用与门、与非门等各种门电路；<strong>译码器译码：</strong>对多个端口地址译码，使用各种译码器元件。<br><strong>可选式译码：</strong>采用开关式端口地址译码。通过开关改变接口卡的端口地址（无需改动线路）。如果要求端口地址能适应不同的地址分配场合，或为系统以后扩充留有余地，则采用开关式端口地址译码，电路可由地址开关、译码器、比较器或异或门几种元器件组合而成。<br>地址译码电路设计原则如下：<br><img src="/images/接口技术及应用/地址译码电路设计原则.png" width="545" height="265" alt="地址译码电路设计原则" align="center"></p>
</li>
</ul>
<h3 id="接口I-O指令"><a href="#接口I-O指令" class="headerlink" title="接口I/O指令"></a>接口I/O指令</h3><p>8086中通过AL寄存器与外设交换信息。</p>
<ul>
<li><strong>端口为单字节地址：</strong>可直接使用地址。<br><code>in AL, 60H</code>：将60H端口中的8位数据-&gt;AL；<br><code>out 61H, AL</code>：将AL中数据-&gt;61H端口。</li>
<li><strong>端口为双字节地址：</strong>不能直接使用地址，通过DX寄存器承接。<br><code>mov DX,300H  in AL,DX</code>：将300H端口中的8位数据-&gt;AL（地址为16位，数据还是8位）。<br><code>mov DX,301H  out DX,AL</code>：将AL中数据-&gt;301H端口。<br>注：in/out都是相对CPU而言的。</li>
</ul>
<h2 id="第三章-定时-计数技术"><a href="#第三章-定时-计数技术" class="headerlink" title="第三章 定时/计数技术"></a>第三章 定时/计数技术</h2><ul>
<li><strong>什么是定时与计数</strong><br>定时：确定时间间隔。<br>计数：统计个数。<br>在计算中定时就是对时钟脉冲(CLK)进行计数，定时和计数本质是一样的。</li>
</ul>
<h3 id="定时计数接口82C54"><a href="#定时计数接口82C54" class="headerlink" title="定时计数接口82C54"></a>定时计数接口82C54</h3><ul>
<li><p><strong>可编程定时计数器</strong><br><img src="/images/接口技术及应用/可编程定时计数器.png" width="300" height="210" alt="可编程定时计数器内部结构图" align="center/"><br><strong>初值寄存器CR：</strong>设定计数初值<br><strong>计数执行单元CE：</strong>执行计数操作，CPU不能访问<br><strong>计数输出锁存器OL：</strong>CPU从中读取当前计数值<br><strong>控制寄存器：</strong>决定82C54工作方式<br><strong>CLK：</strong>CPU时钟信号信号<br><strong>GATE：</strong>门控信号，控制83C54是否工作<br><strong>OUT：</strong>输出端<br>注：寄存器都是<strong>16位</strong>的，但因为数据线只有8位，所以一次只能读写8位数据。<br><strong>工作原理：</strong><br>对CLK信号进行减1计数<br>1、将控制字写入控制寄存器，确定82C54工作方式<br>2、将计数初始值写入初值寄存器。<br>3、从计数初值开始，在GATE控制下，每当CLK信号出现一次，计数值减1。<br>4、当计数值减到0，从OUT端输出规定的信号。<br>注：CLK信号出现时，计数器是否减1，由门控信号GATE控制</p>
</li>
<li><p><strong>定时计数接口82C54</strong><br>82C54具有三个独立的16位计数器（0#~2#通道），每个通道就是一个独立的可编程定时计数器。<br>每个通道有6种工作方式；<br>可以进行二进制或十进制计数，计数方式为减1计数。<br>注：82C54、8254、8253都是一个意思</p>
</li>
<li><p><strong>82C54内部结构</strong><br><img src="/images/接口技术及应用/定时计数接口82C54.png" width="310" height="200" alt="82C54内部结构图" align="center/"></p>
<ul>
<li><strong>数据总线缓冲器：</strong><br>8位，双向，用于暂存数据。<br>1、初始化时向其写入控制字；<br>2、向某一通道写入计数初值；<br>3、从某一通道读当前计数初值。</li>
<li><strong>控制逻辑：</strong><br>接收CPU发来的RD、WR、CS、A1、A0信号，经过逻辑控制电路产生出对82C54要执行的操作。 </li>
<li><strong>控制字寄存器：</strong><br>接收8位的方式命令字（控制字）</li>
</ul>
</li>
<li><p><strong>82C54外部引脚</strong><br><img src="/images/接口技术及应用/82C54外部引脚.png" width="460" height="190" alt="82C54外部引脚" align="center/"><br>\(\small \rm \textbf{D0}\cdots \textbf{D7}\)：双向，8位数据线<br>\(\small \rm \overline{\textbf{WR}}\)：输入，写信号<br>\(\small \rm \overline{\textbf{RD}}\)：输入，读信号<br>\(\small \rm \overline{\textbf{CS}}\)：输入，接口片选信号<br>\(\small \rm \textbf{A0 A1}\)：输入，片内地址选择<br><code>00</code>：通道0<br><code>01</code>：通道1<br><code>10</code>：通道2<br><code>11</code>：方式命令字<br>\(\small \rm \textbf{OUT}\)：输出信号</p>
</li>
</ul>
<h3 id="82C54初始化编程"><a href="#82C54初始化编程" class="headerlink" title="82C54初始化编程"></a>82C54初始化编程</h3><ul>
<li><p><strong>方式命令字格式</strong><br><img src="/images/接口技术及应用/82C54方式命令字.png" width="500" height="60" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">D7 D6：控制字是针对哪个计数器的</span><br><span class="line">    00：计数器0</span><br><span class="line">    01：计数器1</span><br><span class="line">    10：计数器2</span><br><span class="line">    11：非法。</span><br><span class="line">D5 D4：设置读写格式，由计数初值的位数决定，8位-01，16位-11。</span><br><span class="line">    00：计数器锁存命令</span><br><span class="line">    01：只读写低字节</span><br><span class="line">    10：只读写高字节</span><br><span class="line">    11：先读写低字节，后读写高字节。</span><br><span class="line">D3 D2 D1：指定82C54的工作模式</span><br><span class="line">    000：方式0</span><br><span class="line">    ...</span><br><span class="line">    101：方式5。</span><br><span class="line">D0：指定计数模式</span><br><span class="line">    0：二进制</span><br><span class="line">    1：十进制，即BCD码，将每个十进制位转化为4位二进制，求和还是按十进制来算。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编程流程</strong><br><strong>原则: 先写方式命令字、再写计数初值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;端口地址为60H~63H，选择1#，工作方式2，计数初值33H，BCD码制。初始化程序段为：</span><br><span class="line">MOV AL,01010101B     ;写入方式命令字</span><br><span class="line">OUT 63H,AL           ;片内地址为11</span><br><span class="line">MOV AL,33H           ;写入计数初值</span><br><span class="line">OUT 61H,AL           ;片内地址为01（使用1号通道）</span><br><span class="line"></span><br><span class="line">;若计数初值为5533H，其他不变，则程序段为：</span><br><span class="line">MOV AL,01110101B   ;写入控制命令字</span><br><span class="line">OUT 63H,AL         </span><br><span class="line">MOV AL,33H         ;写入计数初值低字节</span><br><span class="line">OUT 61H,AL         </span><br><span class="line">MOV AL,55H         ;写入计数初值高字节</span><br><span class="line">OUT 61H,AL</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="82C54六种工作方式"><a href="#82C54六种工作方式" class="headerlink" title="82C54六种工作方式"></a>82C54六种工作方式</h3><p>方式0：计数结束产生中断<br>方式1：可重复编程的单脉冲<br>方式2：分频器<br>方式3：方波发生器<br>方式4：软件触发的选通信号发生器<br>方式5：硬件触发的选通信号发生器<br><strong>重点是方式2和方式3</strong><br><img src="/images/接口技术及应用/82C54工作方式.png" width="315" height="125" align="center/"></p>
<ul>
<li><p><strong>6种方式不同之处</strong><br>启动计数的触发方式不同。<br>门控信号GATE对计数操作控制不同。<br>是否有初值重装功能。<br>OUT引脚输出波形不同</p>
</li>
<li><p><strong>方式0（计数结束产生中断）</strong><br><img src="/images/接口技术及应用/82C54方式0.png" width="310" height="160" align="center/"><br><strong>触发方式：</strong>软启动。写入控制字后，立即启动，OUT-&gt;低电平，但写入初值后才开始计数。<br>注：写入初值后要等下一个clk才开始计数，一低一高算一个clk。<br><strong>GATE信号：</strong>高电平时计数，低电平时暂停计数。<br><strong>初值重装：</strong>不具有<br><strong>OUT波形：</strong>只计数一次，计数时为低电平，计数结束输出持续的高电平，在写入初值\((n+1)\cdot T_{clk}\)时间后发生0到1跳变。</p>
</li>
<li><p><strong>方式1（可重复编程的单脉冲）</strong><br><img src="/images/接口技术及应用/82C54方式1.png" width="310" height="160" align="center/"><br><strong>触发方式：</strong>硬件启动，写入控制字后，OUT-&gt;高电平；检测到GATE上升沿，OUT-&gt;低电平，开始计数。<br><strong>GATE信号：</strong>可重复触发计数，检测到GATE上升后就重新计数。<br><strong>初值重装：</strong>不具有。<br><strong>OUT波形：</strong>宽度为\(n\cdot T_{clk}\)的负脉冲。<br><strong>用途：</strong>单脉冲发生器，宽度由程序设置的n决定。 </p>
</li>
<li><p><strong>方式2 周期性负脉冲输出（分频器）</strong><br><img src="/images/接口技术及应用/82C54方式2.png" width="350" height="165" align="center/"><br><strong>触发方式：</strong>写入控制字后，OUT-&gt;高电平，但写入初值后才开始计数。<br><strong>GATE信号：</strong>高电平时计数，低电平时暂停计数。<br><strong>初值重装：具有</strong>，在计数过程中若重新写入计数初值，对正在进行的计数过程没有影响，但在计到1输出一个CLK宽度的负脉冲后，计数器将按新的计数初值开始计数。<br><img src="/images/接口技术及应用/82C54方式2初值重装.png" width="360" height="90" align="center/"><br><strong>OUT波形：</strong>产生连续的负脉冲，宽度为\(T_{clk}\)，周期为\(n\cdot T_{clk}\)。<br><strong>用途：</strong>分频器，放大\(T_{clk} \rightarrow n\cdot T_{clk}\)，可用来提供周期性脉冲信号/时终信号。<br>注：分频器意思是高频-&gt;低频就行，波形不一定要相同。</p>
</li>
<li><p><strong>方式3 方波发生器</strong><br><img src="/images/接口技术及应用/82C54方式3.png" width="350" height="165" align="center/"><br>（和方式2类似，只不过输出的是方波）<br><strong>触发方式：</strong>写入控制字后，OUT-&gt;高电平，但写入初值后才开始计数。<br><strong>GATE信号：</strong>高电平时计数，低电平时暂停计数。<br><strong>初值重装：具有</strong>，和方式2原理一样。<br><strong>OUT波形：</strong>产生连续的负脉冲，宽度为\(\frac {n} {2}\cdot T_{clk}\)，周期为\(n\cdot T_{clk}\)。<br>注：当n是奇数时，输出不对称方波，前\(\frac {n+1} {2}\)个计数期间，OUT输出高电平；后\(\frac {n-1} {2}\)个计数期间，OUT输出低电平。<br><strong>用途：</strong>方波发生器，也可分频。</p>
</li>
</ul>
<h2 id="第四章-并行接口"><a href="#第四章-并行接口" class="headerlink" title="第四章 并行接口"></a>第四章 并行接口</h2><p>串/并接口指<strong>接口和外设</strong>间的连线是单根还是多根，接口和CPU间肯定是多根线。</p>
<ul>
<li><strong>并行接口特点</strong><br>通过多根信号线同时传送多位数据，且传送时一般不需要特定的数据传送格式；<br>并行接口多用于距离短，数据量大，速率高的实时传输场合；<br>并行接口布线成本高，且有线路间互相干扰、时钟同步等问题，因此并行传输技术发展受限。<br>常用并行接口：<br><img src="/images/接口技术及应用/常见并行接口.png" width="390" height="175" alt="常见并行接口" align="center/"></li>
</ul>
<h3 id="可编程并行接口8255"><a href="#可编程并行接口8255" class="headerlink" title="可编程并行接口8255"></a>可编程并行接口8255</h3><p>上一章介绍的82C54属于非通道接口，其主要功能为驱动外设，而非在CPU和外设间传数据；<br>本章介绍的8255是通道接口，主要功能就是在CPU和外设间传数据。</p>
<ul>
<li><p><strong>8255特点</strong><br>有三个输入输出端口：端口A，端口B，端口C。<br>每个端口可编程设定为输入端口或输出端口，并可设定不同的工作方式。<br>端口C可作为一个独立的端口使用，但常常是配合A口和B口工作，为A、B端口的提供联络信号。</p>
</li>
<li><p><strong>8255的内部结构</strong><br><img src="/images/接口技术及应用/8255内部结构.png" width="400" height="300" alt="8255内部结构" align="center/"><br>三个并行输入输出端口（A口、B口、C口）分为两组进行控制，分别对应一个控制寄存器：<br>A组：A口、C口高4位<br>B组：B口、C口低4位</p>
</li>
<li><p><strong>8255的外部引脚</strong><br><img src="/images/接口技术及应用/8255外部引脚.png" width="460" height="185" alt="8255外部引脚" align="center/"><br><strong>片选地址A1 A0：</strong><br><code>00</code>：A端口<br><code>01</code>：B端口<br><code>10</code>：C端口<br><code>11</code>：方式命令字</p>
</li>
</ul>
<h3 id="8255初始化编程"><a href="#8255初始化编程" class="headerlink" title="8255初始化编程"></a>8255初始化编程</h3><p>8255A有两个控制字（方式命令字，C口按位复位/置位命令字）和一个状态字，设置方法也不同。</p>
<ul>
<li><p><strong>方式命令字</strong><br><img src="/images/接口技术及应用/8255方式命令字.png" width="510" height="210" alt="8255方式命令字" align="center/"><br>D7：<code>1</code>时表示方式命令字，<code>0</code>时表示C口按位复位/置位命令字<br>其余位按A、B组分为两组，进行不同的控制。</p>
</li>
<li><p><strong>C口按位复位/置位命令字</strong><br>在方式1和方式2时要用到这个控制字，对C口的某一位置1/0，输出正/负脉冲。<br>此控制字只对C口有效。<br>它被写入控制口，不是写入C口。<br><img src="/images/接口技术及应用/8255C口按位复位置位命令字.png" width="490" height="250" alt="8255C口按位复位置位命令字" align="center/"></p>
</li>
<li><p><strong>编程流程</strong><br>和82C54编程原则相同：先写控制字，再写数据值。</p>
</li>
</ul>
<h3 id="8255工作方式"><a href="#8255工作方式" class="headerlink" title="8255工作方式"></a>8255工作方式</h3><p>8255有3种工作方式：方式0，方式1和方式2，<br>方式0：无条件传送（外设始终做好了准备）<br>方式1：单向应答式传送（查询、中断）<br>方式2：双向应答式传送（查询、中断）<br><strong>重要是方式0和方式1</strong></p>
<p>8255三个端口对工作方式的使用情况不同。<br>A端口：可使用3种方式的任一种；<br>B端口：只能使用方式0和方式1；<br>C瑞口：一般作为控制信号使用，配合A端口和B端口的工作。</p>
<ul>
<li><p><strong>方式0</strong><br>最简单的连接方式，直接读写数据即可。<br>2个8位的端口和2个4位的端口，都可以作为输入或输出。<br>单向I/0，端口只能做输入或输出一项功能。<br>系统没有指定C口的某些线作为专门的信号联络线和状态位，但是用户可以自定义C口的某些线作为信号联络线。<br>端口信号线之间无固定的时序关系，由用户根据数据传送的要求决定输入输出的操作过程。不需要任何选通信号。</p>
</li>
<li><p><strong>方式1（输入过程）</strong><br><img src="/images/接口技术及应用/8255方式1输入过程.png" width="435" height="67" alt="方式1输入过程示意图" align="center/"><br><strong>各信号意义：</strong><br>\(\small \rm \overline{STB}\)：选通信号，表示外设已经准备好数据。<br>IBF：输入缓冲器满信号，表示端口已经接收数据完毕。<br>INTR：中断请求信号，请求CPU接收数据。<br>\(\small \rm \overline{RD}\)：读数据信号，有效代表CPU在读取数据。在外设向CPU发出INTR信号后，什么时候CPU响应了中断，\(\small \rm \overline{RD}\)即变为有效。<br><img src="/images/接口技术及应用/8255方式1信号时序图(输入).png" width="433" height="180" alt="信号时序图（输入）" align="center/"></p>
</li>
<li><p><strong>方式1（输出过程）</strong><br><img src="/images/接口技术及应用/8255方式1输出过程.png" width="435" height="67" alt="方式1输出过程示意图" align="center/"><br><strong>各信号意义：</strong><br>INTR：中断请求信号，接口向CPU发出中断。<br>\(\small \rm \overline{WR}\)：写信号，表示CPU向接口在写数据。<br>\(\small \rm \overline{OBF}\)：输出缓冲器满信号，表示外设可以从接口中取数据了 。<br>\(\small \rm \overline{ACK}\)：外设应答信号，\(\small \rm \overline{ACK}=0\)其实是一个负脉冲，表示外设已接收完数据，可以再发下一个数据，因此马上会回到高电平。<br><img src="/images/接口技术及应用/8255方式1信号时序图(输出).png" width="433" height="180" alt="信号时序图（输出）" align="center/"><br>CPU响应中断以后，向8255输出数据，写信号出现；写信号撤消，其上升沿一方面撤消中断请求信号INTR，另一方面使\(\small \rm \overline{OBF}\)信号变为有效的低电平，通知外设可以接收数据。<br>当外设接收完数据后，便发出一个\(\small \rm \overline{ACK}\)信号，同时使\(\small \rm \overline{OBF}\)变为无效，表示数据已经取走，当前缓冲器空。\(\small \rm \overline{ACK}\)信号结束时使INTR信号变为有效的高电平，向CPU发出中断请求信号，从而开始新的数据输出过程。</p>
</li>
<li><p><strong>方式1下的C口状态字</strong><br><img src="/images/接口技术及应用/8255方式1C口状态字.png" width="457" height="225" alt="8255方式1 C口状态字" align="center/"><br><strong>INTE：</strong>中断使能状态，表示是否允许端口发出INTR信号。初始化时通过C口按位复位/置位命令字来设定，设定后，就会在状态字中反映出来。<br><strong>PC0-PC7：</strong>指C口的对应位，为A口和B口的提供辅助信号。A组：8位数据口+5位控制口(PC3-PC7)，B组：8位数据口+3位控制口(PC0-PC2)。<br><strong>状态字作用：</strong><br>状态字主要为查询方式提供了状态标志位，方式1下，CPU读取的C口某几位内容，主要有：\(\small \rm \overline{OBF}\)、IBF、INTE、INTR，来判断下一步应该进行的操作。<br>注1：A口、B口都有相应的状态字，实质是相互独立的两个数据口。<br>注2：\(\small \rm \overline{STB}\)、\(\small \rm \overline{ACK}\)线的状态不能读取，因为是来自外设的信号，所以状态字中没有，CPU也不需要知道。<br>注3：端口C状态字寄存器的值和对应的引脚信号不一定一样。如输入状态下，PC4寄存器值表示INTE，而引脚则接\(\small \rm \overline{STB}\)信号。因为INTE是在初始化时设置的，而\(\small \rm \overline{STB}\)信号又不写到寄存器中，所以两者并不冲突，这样可以提升端口利用率。</p>
</li>
</ul>
<h2 id="第五章-中断技术"><a href="#第五章-中断技术" class="headerlink" title="第五章 中断技术"></a>第五章 中断技术</h2><h3 id="中断的基本概念"><a href="#中断的基本概念" class="headerlink" title="中断的基本概念"></a>中断的基本概念</h3><p>中断的本质是程序转移：CPU响应中断请求，暂停现行的主程序，转去执行中断服务子程序，完成中断事件处理后，返回断点继续执行主程序的过程。</p>
<ul>
<li><p><strong>中断的分类</strong><br><img src="/images/接口技术及应用/中断分类.png" width="475" height="207" alt="中断分类" align="center/"><br>中断的内、外是针对CPU而言的，外部中断即来自CPU外部的中断。</p>
</li>
<li><p><strong>外部可屏蔽中断的一般流程</strong><br>1、中断请求：INTR，请求信号应保持到本次中断被响应<br>2、中断识别及判优：通过类型号区分不同中断源，通过优先级进行中断判优<br>3、中断响应：保护现场等操作（硬件完成）<br>4、中断处理：执行中断服务子程序<br>5、中断返回：恢复现场等操作（硬件完成）</p>
</li>
<li><p><strong>中断向量与中断向量表</strong><br><strong>中断类型号：</strong>8086微处理器支持256种中断，编号为0~255号。<br><strong>中断向量：</strong>中断服务程序的入口地址，CS:IP的形式存储，占4个字节的地址。<br><strong>中断向量表：</strong>系统中所有的中断向量集中起来放到存储器的某一区域内，即为中断向量表。在内存中用000~3FFH共1024(4*256)个地址作为中断向量表存储区。<br><strong>由中断号计算中断服务程序地址：</strong>先计算中断向量的地址(4*中断号)，再取出中断服务程序的地址。总共四个字节，低2字节为IP，高2字节为CS，都是小端存储。<br>eg：计算中断类型号为4AH的中断服务程序入口地址<br><img src="/images/接口技术及应用/计算中断入口地址eg.png" width="340" height="270" align="center/"></p>
</li>
</ul>
<h3 id="可编程中断控制器8259A"><a href="#可编程中断控制器8259A" class="headerlink" title="可编程中断控制器8259A"></a>可编程中断控制器8259A</h3><p><strong>作用：</strong>接收外设传来的中断，进行中断识别和判优，并将应该响应中断的中断号传给CPU。只传中断号，并不执行中断。<br>8259A只是帮助系统管理外部可屏蔽中断，外部不可屏蔽中断及内部中断CPU自己处理。<br>8259A具有8级优先权控制，通过级连可扩展至64级优先权控制。</p>
<ul>
<li><p><strong>8259A内部结构</strong><br><img src="/images/接口技术及应用/8259A内部结构.png" width="370" height="270" alt="8259A内部结构图" align="center/"><br><strong>中断请求寄存器(IRR)：</strong>该寄存器8位(D0～D7)对应于IR0~IR7线上传来的中断请求，哪一根输入线有请求，哪位就置“1”，中断被响应后对应位就置0。<br><strong>中断屏蔽寄存器(IMR)：</strong>寄存器8位(D0～D7)对应8级中断屏蔽，IR0~IR7哪一个中断被屏蔽，哪位就写1。<br><strong>优先权分析器(PR)：</strong>PR将当前中断请求的优先级和“正在服务中的中断”进行比较，决定是否让这个中断请求送给处理器（低优先级就不送了）。<br><strong>ISR寄存器：</strong>寄存了正在服务的\(\small \rm IR_{i}\)中断源和被挂起的中断源，可根据优先级规则判断哪个中断源正在被服务。<br><strong>被挂起的含义：</strong>低优先级中断先响应了，之后来了高优先级中断，就挂起去执行高优先级（若高优先级先响应，低优先级压根就不会送到ISR）。<br>如下图：若IR0中断优先级最高，IR7优先级最低，则当前被服务的是IR0，被挂起的是IR2和IR6。<br><img src="/images/接口技术及应用/8259A_ISR寄存器.png" width="330" height="50" alt="8259A ISR寄存器" align="center/"><br><strong>级联缓冲/比较器（CAS0~CAS2）：</strong>主控和从控芯片的CAS0~CAS2相互连接，进行级联；从控的INT引脚接到主控的IR上，传递中断号。<br><strong>如何区分主控和从控：</strong>SP/EN引脚接高电平为主控，接低电平为从控。</p>
</li>
<li><p><strong>8259A外部引脚</strong><br><img src="/images/接口技术及应用/8259A外部引脚.png" width="430" height="280" alt="8259A外部引脚" align="center/"></p>
</li>
<li><p><strong>8259A中断响应过程</strong><br>1、IRQ0~IRQ7有中断请求，IRR的相应位置1<br>2、IRR与IMR相应位进行比较，封锁或发送中断请求给PR<br>3、PR分析后，把当前最高优先级的中断请求由INT送至CPU<br>4、若IF=1，CPU执行完当前指令后，连续发出2个\(\small \rm \overline{INTA}\)信号（IF=1表示开中断）<br><strong>5、</strong>接到第1个\(\small \rm \overline{INTA}\)后，ISR对应位置1，IRR对应位清0<br><strong>6、</strong>接到第2个\(\small \rm \overline{INTA}\)后，8259A把中断类型号送上数据总线<br>7、CPU根据收到的中断类型号，到中断向量表中取中断向量，执行中断子程序。</p>
</li>
</ul>
<h3 id="8259A工作方式"><a href="#8259A工作方式" class="headerlink" title="8259A工作方式"></a>8259A工作方式</h3><p><img src="/images/接口技术及应用/8259A工作方式.png" width="508" height="293" align="center/"><br>因为其他部分都不太重要，因此接下来重点介绍<strong>优先级排队方式</strong>。</p>
<ul>
<li><p><strong>普通完全嵌套方式</strong><br>在该方式下，IR7～IR0的优先级顺序是IR0最高，IR7最低。且一个中断被响应，只有比它更高优先级的中断请求才会被响应。</p>
</li>
<li><p><strong>特殊嵌套方式</strong><br>该方式一般用于8259A的<strong>级联方式</strong><br>与全嵌套方式基本相同，不同之处在于特殊嵌套不但响应比本级高的中断申请，而且响应同级的中断申请。<br>如果当前正在执行的中断是由从片传来的，这是从片上更高级别的中断提出请求，从片会予以响应，向主片发INT信号，但主片分不出来，只将它们视为同一级别。<br>若普通全嵌套方式，则主片不会响应，只有特殊全嵌套方式，主片才会响应。因此级联时主片必须采取特殊嵌套方式。</p>
</li>
<li><p><strong>优先级循环方式</strong><br>指当某个中断源受到中断服务后，它的优先权就自动降为最低，而优先级较其低一级的升为最高。<br>例如，IR4被服务后，相应的IR5的优先级升为最高，依次为IR6，IR7，IR0，IR1，IR2，IR3，IR4。<br>根据初始优先级的不同又分为两种方式：<br><strong>普通循环方式：</strong>默认初始优先级最高为IR0，最低为IR7。<br><strong>特殊循环方式：</strong>用户自己决定初始优先级，如规定IR5最低，则相应的最高优先级为IR6，依次为IR7，IR0，IR1，IR2，IR3，IR4，IR5。</p>
</li>
</ul>
<h3 id="8259A初始化命令字"><a href="#8259A初始化命令字" class="headerlink" title="8259A初始化命令字"></a>8259A初始化命令字</h3><p>8259A有4个初始化命令字ICW1~ICW4，在接口使用前进行设置。<br>初始化命令字必须按ICW1~ICW4的顺序写入，中间不能被打断（关中断）。且ICW1、ICW2是必须写的，ICW3、ICW4需不需要写视工作方式而定。<br><strong>写入地址：</strong>ICW1要写到<strong>偶地址（A0=0）</strong>，ICW2~ICW4写到<strong>奇地址（A0=1）</strong>。</p>
<ul>
<li><p><strong>ICW1（芯片控制命令字）</strong><br><img src="/images/接口技术及应用/8259A_ICW1.png" width="420" height="50" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D7 D6 D5：可任意设置，建议设为0</span><br><span class="line">D4：标志位，只能设为1</span><br><span class="line">D3：设置中断触发方式</span><br><span class="line">    1：电平触发方式</span><br><span class="line">    0：边沿触发方式 </span><br><span class="line">D2：任意设置，建议为0</span><br><span class="line">D1：规定单片还是级连方式</span><br><span class="line">    1：单片方式</span><br><span class="line">    0：级连方式</span><br><span class="line">D0：是否写入ICW4</span><br><span class="line">    1：要写入ICW4</span><br><span class="line">    0：不写入ICW4</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ICW2（中断类型号命令字）</strong><br><img src="/images/接口技术及应用/8259A_ICW2.png" width="420" height="50" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D7~D3：设置中断向量号的高5位，手动设置。</span><br><span class="line">D2~D0：中断向量号的低3位，8259A会自动确定。</span><br><span class="line">IR0为000、IR1为001...IR7为111</span><br><span class="line">写的时候只用写D7~D3即可，D2~D0自动设为0。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最终中断号=ICW2的高5位+\(\small \rm IR_{i}\)组合而成。</p>
<ul>
<li><p><strong>ICW3（级联控制命令字）</strong><br><img src="/images/接口技术及应用/8259A_ICW3.png" width="485" height="85" align="center/"><br>ICW3是级联时才需写入的控制字，且对于主、从片的意义不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对于主片：Di=1表示IRi接有从片，否则IRi没有接从片。</span><br><span class="line">对于从片：D2~D0表明从片的INT引脚接到主片的哪个IR引脚。</span><br><span class="line"></span><br><span class="line">例：主控8259第IR3、IR6上联了从控。</span><br><span class="line">主控：ICW3=01001000B，</span><br><span class="line">从控A：ICW3=00000011B，</span><br><span class="line">从控B：ICW3=00000110B。</span><br><span class="line"></span><br><span class="line">如何区分主控和从控：SP/EN接高电平为主控，接低电平为从控。</span><br><span class="line">主控和从控的CAS0~CAS2相互连接，进行级联；从控的INT引脚接到主控的IR上，传递中断号。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ICW4（方式命令控制字）</strong><br><img src="/images/接口技术及应用/8259A_ICW4.png" width="485" height="85" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D7 D6 D5：直接设0</span><br><span class="line">D4：设置嵌套方式</span><br><span class="line">    1：特殊嵌套方式</span><br><span class="line">    0：普通完全嵌套方式</span><br><span class="line">D3：数据线的缓冲方式</span><br><span class="line">    1：缓冲方式</span><br><span class="line">    0：非缓冲方式 </span><br><span class="line">D2：主片/从片选择</span><br><span class="line">    1：主片</span><br><span class="line">    0：从片</span><br><span class="line">D1：中断结束方式</span><br><span class="line">    1：自动中断结束</span><br><span class="line">    0：非自动中断结束</span><br><span class="line">D0：微处理器类型</span><br><span class="line">    1：16位80x86</span><br><span class="line">    0：8位8080/8085</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>8259A初始化流程</strong><br><img src="/images/接口技术及应用/8259A初始化流程.png" width="220" height="300" alt="8259A初始化流程" align="center/"></p>
</li>
</ul>
<h3 id="8259A操作命令字"><a href="#8259A操作命令字" class="headerlink" title="8259A操作命令字"></a>8259A操作命令字</h3><p>8259A有3个操作命令字OCW1~OCW3，负责对8259A的工作状态进行设置。<br>在8259A工作期间，可以随时接受操作命令字，且对写入顺序没有要求，需要哪个OCW就写入那个OCW。<br><strong>写入地址：</strong>OCW1写到<strong>奇地址（A0=1）</strong>，OCW2、OCW3写到<strong>偶地址（A0=0）</strong></p>
<ul>
<li><p><strong>OCW1（屏蔽命令字）</strong><br><img src="/images/接口技术及应用/8259A_OCW1.png" width="485" height="85" align="center/"><br>内容写入中断屏蔽寄存器IMR，\(\small \rm D_i\)对应\(\small \rm IR_i\)<br><code>1</code>：禁止\(\small \rm IR_i\)中断<br><code>0</code>：允许\(\small \rm IR_i\)中断</p>
</li>
<li><p><strong>OCW2</strong><br><img src="/images/接口技术及应用/8259A_OCW2.png" width="410" height="300" align="center/"><br>OCW2用于设置优先级循环方式和中断结束方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D7 D6 D5：组合为设置编码</span><br><span class="line">D7：是否允许优先权循环</span><br><span class="line">D6：设置优先级方式</span><br><span class="line">    1：循环优先级（按D2~D0决定哪个引脚优先级最低）</span><br><span class="line">    0：固定优先级（IR7最低，IR0最高）</span><br><span class="line">D5：是否允许EOI，EOI：结束中断，结束D2~D0对应引脚的中断</span><br><span class="line">    1：允许</span><br><span class="line">    0：不允许</span><br><span class="line">D2 D1 D0：指定优先级循环时，初始的最低优先级的引脚</span><br><span class="line"></span><br><span class="line">eg：D2~D0为101，表明指定初始时最低优先级为IR5，则最高优先级为IR6。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>OCW3</strong><br><img src="/images/接口技术及应用/8259A_OCW3.png" width="375" height="160" align="center/"><br>OCW3用于设置和撤消特殊屏蔽方式、设置中断查询方式以及发出对8259A内部寄存器的读出命令。</p>
</li>
<li><p><strong>如何区分初始化命令字和方式命令字</strong><br>8259A只有两个端口用来写命令字（一个奇地址一个偶地址），如何区分写到地址中的命令字？<br><strong>对于奇地址：</strong>ICW1、OCW2、OCW3都写到奇地址，通过命令字的<code>D4 D3</code>两位来区分。<br><strong>对于偶地址：</strong>ICW2~4、OCW1都写到偶地址，通过写入顺序来区分，系统规定只能按<code>ICW2-&gt;ICW3-&gt;ICW4-&gt;OCW1</code>的顺序写入。</p>
</li>
</ul>
<h2 id="第六章-A-D、D-A转换器接口"><a href="#第六章-A-D、D-A转换器接口" class="headerlink" title="第六章 A/D、D/A转换器接口"></a>第六章 A/D、D/A转换器接口</h2><p>在实际工业生产环境，都是连续变化的模拟量 ，如：压力、温度、流量等；<br>而在计算机内部，则都是离散的数字量，二进制数、十进制数、十六进制等。<br>因此需要对连续的模拟量和离散的数字量做转换，就出现了A/D(Analog to Digital)、D/A(Digital to Analog)转换器芯片。</p>
<h3 id="D-A转换芯片DAC0832"><a href="#D-A转换芯片DAC0832" class="headerlink" title="D/A转换芯片DAC0832"></a>D/A转换芯片DAC0832</h3><p>D/A转换器的功能是把二进制数字量电信号–&gt;与其数值成正比的模拟量电信号(电压、电流..)。<br>如下图：横坐标为输入的数字信号量，纵坐标为输出的模拟信号量。<br><img src="/images/接口技术及应用/DA转换器功能.png" width="275" height="155" alt="D/A转换器功能" align="center/"></p>
<p>DAC0832主要有三项技术指标：分辨率、精度和建立时间。</p>
<ul>
<li><p><strong>分辨率</strong><br>分辨率是指输入数字量发生一个单位的变化时，输出模拟量的变化量，这个参数反映了DAC对模拟量的分辨能力<br>eg：<br>满刻度值电压为5V、10位DAC：能分辨的电压为\(\small 5/2^{10}=4.88(mV)\)。<br>满刻度值电压为5V、8位DAC：能分辨的电压为\(\small 5/2^8=19.53(mV)\)。</p>
</li>
<li><p><strong>精度</strong><br>精度表明了模拟输出实际值与理想值之间的偏差，可能工艺做的器件比较粗糙，导致实际用的时候有误差，反映的是“工艺”精度。</p>
</li>
<li><p><strong>建立时间</strong><br>从数字输入端发生变化开始，到模拟输出稳定在理想值的\(\pm \frac{1} {2}\)\(\small LSB\)时所需的时间（LSB指分辨率）。</p>
</li>
<li><p><strong>DAC0832内部结构</strong><br><img src="/images/接口技术及应用/DAC0832结构.png" width="400" height="206" alt="D/A转换器结构" align="center/"><br>DAC0832内部有两个数据缓冲器，分别由两组控制信号控制：<br><strong>输入寄存器：</strong>存放外部输入的数据，当\(\small ILE=1\cap \overline{CS}=0\cap \overline{WR1}=0\)时，\(\small LE1\)端有效，DI7~DI0上的数据锁被写到输入寄存器中。<br><strong>DAC寄存器：</strong>存放要输出的数据（D/A转换器根据DAC寄存器中的值计算输出的模拟值），当\(\small \overline{XFER}=0\cap \overline{WR2}=0\)时，\(\small LE2\)端有效，输入寄存器中的数据被写到DAC寄存器中。<br><strong>DAC0832外部引脚：</strong><br>\(\small DI0\sim DI7\)：8位数字输入端，DI0为最低端，DI7为最高端。<br>\(\small ILE\)：数据输入锁存允许，通常一直为高电平；<br>\(\small \overline{CS}\)：片选信号1–&gt;输入寄存器。<br>\(\small \overline{XFER}\)：片选信号2–&gt;DAC寄存器。<br>\(\small \overline{WR1}\)：写信号1，输入寄存器写选通信号。<br>\(\small \overline{WR2}\)：写信号2，DAC寄存器写选通信号。<br>\(\small Iout1\)：DAC电流输出端1，为数字输入端为1的位的输出电流之和。全1时最大，全0时最小。<br>\(\small Iout2\)：电流输出端2，\(\small Iout1+Iout2=常数\)</p>
</li>
<li><p><strong>DAC0832工作时序</strong><br><img src="/images/接口技术及应用/DAC0832工作时序.png" width="485" height="317" alt="DAC0832工作时序" align="center/"></p>
</li>
</ul>
<h3 id="DAC0832工作方式"><a href="#DAC0832工作方式" class="headerlink" title="DAC0832工作方式"></a>DAC0832工作方式</h3><p>DAC0832没有应答信号，有数据输入时，若已经选通了，即开始转换；也没有控制字信号，直接送数据即可。<br>DAC0832有单缓冲模式、双缓冲模式、无缓冲模式三种工作方式，重点是<strong>单缓冲模式</strong>。<br><strong>缓冲的含义：</strong>缓冲即指锁存，锁存就是寄存器能否暂存数据（尽管有新的输入数据，但仍旧保持原有的值，直到某个信号的到来才更新寄存器的值）。如果没有锁存功能，就是寄存器值和输入值保持同步，输出会随着输入而变化。<br>在DAC0832中，实现两个寄存器的缓冲功能，要通过寄存器对应的选通信号线：选通信号线处于无效状态，数据就写不进去，就实现了缓冲/锁存。若选通信号线恒有效，就没有缓冲功能。<br><strong>如何设置工作方式：</strong>0832没有命令字，根据选通信号引脚连线的不同来决定工作方式。</p>
<ul>
<li><p><strong>双缓冲方式</strong><br>输入寄存器、DAC寄存器都有缓冲功能。当把数据由输入寄存器写到DAC寄存器以后，输入寄存器就可以接受新数据而不影响模拟输出值，该结构便于多路DAC同时工作（可以时分复用，利用DAC寄存器中数据转换的时间读取数据）。<br><img src="/images/接口技术及应用/DAC0832双缓冲方式.png" width="380" height="275" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">要分别对两个寄存器写数据</span><br><span class="line">MOV DX，200H    ;DAC0832 的输入锁存器的地址为200H </span><br><span class="line">OUT DX，AL      ;AL中数据DATA送输入寄存器</span><br><span class="line">MOV DX，201H	;DAC0832 的DAC锁存器的地址为201H </span><br><span class="line">OUT DX，AL   	;数据DATA写入DAC锁存器并转换</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单缓冲方式</strong><br>只有输入寄存器有缓冲功能。只需一次写操作，就开始转换，提高了D/A的数据吞吐量。适合在不要求多片D/A同时输出时。<br><img src="/images/接口技术及应用/DAC0832单缓冲方式.png" width="390" height="234" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV	DX，200H	;设DAC0832的地址为200H</span><br><span class="line">OUT	DX，AL	    ;AL内数据送DAC转换</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>直通方式</strong><br>两寄存器都没有缓冲功能，输出随输入同步变化。<br><img src="/images/接口技术及应用/DAC0832直通方式.png" width="385" height="180" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   DX，200H 	  ;8255的A口地址为200H</span><br><span class="line">OUT   DX，AL      ;AL中数据送A口锁存并转换</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用DAC0832输出三角波</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;设输出初始值0</span><br><span class="line">L1:  MOV AL, 0</span><br><span class="line"></span><br><span class="line">;输出数值递增，产生三角波上升沿</span><br><span class="line">UP:  MOV DX, 300H   ;单缓冲</span><br><span class="line">OUT  DX, AL</span><br><span class="line">INC  AL</span><br><span class="line">CALL DELAY</span><br><span class="line">;判断输出是否为0，JNZ：不为0跳转</span><br><span class="line">AND  AL, AL</span><br><span class="line">JNZ  UP</span><br><span class="line"></span><br><span class="line">;输出数值递减，产生三角波下降沿</span><br><span class="line">DOWN: DEC AL   ;AL=0-1=255</span><br><span class="line">OUT  DX, AL		       </span><br><span class="line">CALL DELAY</span><br><span class="line">;判断输出是否为0</span><br><span class="line">AND  AL, AL</span><br><span class="line">JNZ  DOWN</span><br><span class="line">LOOP L1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="A-D转换芯片ADC0809"><a href="#A-D转换芯片ADC0809" class="headerlink" title="A/D转换芯片ADC0809"></a>A/D转换芯片ADC0809</h3><p>将模拟信号转换为数字信号</p>
<ul>
<li><p><strong>A/D转换基本原理：</strong><br><strong>采样：</strong>利用采样脉冲序列，从信号中抽取一系列离散值，使之成为采样信号；<br><strong>量化：</strong>把采样信号经过舍入变为只有有限个有效数字的数，使电流和数据有一一对应的关系；<br><strong>编码：</strong>将经过量化的值变为二进制数字。<br><strong>如何将十进制数值转换为二进制：</strong>使用逐次逼近的方法，具体原理如下图：<br><img src="/images/接口技术及应用/AD转换逐次逼近原理.png" width="385" height="180" alt="A/D转换逐次逼近原理" align="center/"></p>
</li>
<li><p><strong>ADC0809结构</strong><br><img src="/images/接口技术及应用/ADC0809结构图.png" width="375" height="252" alt="ADC0809结构图" align="center/"><br><strong>IN7~IN0：</strong>8路模拟信号输入。<br><strong>ADDC、ADDB、ADDA：</strong>8路模拟信号量的地址选择线，选择要接收的一路模拟信号量。<br><strong>ALE：</strong>地址锁存允许，其正跳变锁存地址选择线状态，经译码选通对应的模拟输入信号。<br><strong>START：</strong>启动信号，上升沿使片内所有寄存器清零，下降沿启动A/D转换（通常与ALE共用一根线）。<br><strong>EOC：</strong>AD转换结束信号，转换开始后，此引脚变为低电平，转换一结束，此引脚变为高电平；<br><strong>OE：</strong>输出允许，当有效时，D7~D0输出结果。<br><strong>D7~D0：</strong>8位数据输出线。</p>
</li>
<li><p><strong>ADC0809输出数据的传送方式</strong><br><strong>延时等待法：</strong>软件延时等待足够长的时间（大于转换时间），此时不用EOC信号，CPU效率最低。<br><strong>中断法：</strong>把EOC作为中断请求信号，在中断服务程序中读入转换结果，效率较高。<br><strong>查询法：</strong>软件查询EOC信号的状态。<br>具体代码见PPT</p>
</li>
</ul>
<h2 id="第七章-串行接口"><a href="#第七章-串行接口" class="headerlink" title="第七章 串行接口"></a>第七章 串行接口</h2><h3 id="串行通信方式基本概念"><a href="#串行通信方式基本概念" class="headerlink" title="串行通信方式基本概念"></a>串行通信方式基本概念</h3><p><strong>串行通信方式：</strong>在一条传输线上，将多位数据从低位到高位顺序地进行传输。<br><strong>并行通信方式：</strong>在多条传输线上同时传输多位数据，且有专门的联络、控制信号线。</p>
<ul>
<li><p><strong>串行通信的数据传送方向</strong><br><img src="/images/接口技术及应用/串行通信数据传送方向.png" width="455" height="222" alt="串行通信数据传送方向" align="center/"></p>
</li>
<li><p><strong>信号的调制和解调</strong><br>数据通信设备DCE：Modern<br>数据终端设备DTC：主机、终端通讯设备。<br>三种调制方式：振幅键控（ASK），频移键控（FSK）和相移键控（PSK） </p>
</li>
<li><p><strong>数据的传输速度</strong><br>数字通信中，传输速率经常用波特率(baud)来表示。同时为提高发送/接收时钟对波特率的定位精度，发送/接收时钟的频率常定为波特率的整数倍（1、16、32、64），这个整数称为<strong>波特率因子</strong>。$$TxC=factor\times baud$$ TxC为发送/接收时钟频率。<br>波特率因子可理解为发送/接收1位数据所需要的时钟脉冲个数，即在发送端，需要多少个时钟脉冲才能移出1位数据。时钟脉冲多一些，可提高定位采样的精度。</p>
</li>
<li><p><strong>串行通信的基本方式</strong><br><strong>异步串行通信：</strong>以字符为单位发送数据，字符间间隔不定（异步），但字符内各位是同步的。适合数据量少、速率低，发送数据不连续的场合。<br><strong>同步串行通信：</strong>以数据块为单位发送数据，字符间、字符内都是同步的。适合速率高，连续传输大批量数据的场合。<br><strong>外同步：</strong>发送端发数据前先发送同步时钟信号，接收方用这一同步信号来锁定自己的时钟脉冲频率，来达到收发双方位同步的目的。<br><strong>自同步法：</strong>接收方利用包含有同步信号的特殊编码（如曼彻斯特编码）从信号自身提取同步信号来锁定自己的时钟脉冲频率，达到同步目的。</p>
</li>
<li><p><strong>串行通信数据格式</strong><br>对于异步串行通信，因为字符间的间隙不固定，因此要有起始位和终止位。<br><img src="/images/接口技术及应用/异步串行通信数据格式.png" width="375" height="90" alt="异步串行通信数据格式" align="center/"><br>对于同步串行通信，要求有时钟来实现发送端与接收端之间的同步，因此有很多控制字符，因较为复杂就不列举了。</p>
</li>
</ul>
<h3 id="串行接口标准RS-232C"><a href="#串行接口标准RS-232C" class="headerlink" title="串行接口标准RS-232C"></a>串行接口标准RS-232C</h3><ul>
<li><p><strong>电气特性</strong><br><strong>在TxD和RxD数据上：</strong><br>逻辑1(MARK) = -3 ~ -15V<br>逻辑0(SPACE) = +3 ~ +15V<br><strong>在RTS、CTS、DSR、DTR和DCD等控制线上：</strong><br>信号有效（接通，ON状态）= +3 ~ +15V<br>信号无效（断开，OFF状态）= -3 ~ -15V </p>
</li>
<li><p><strong>RS-232C的引脚信号线</strong><br><img src="/images/接口技术及应用/RS232C引脚图.png" width="353" height="243" alt="RS232C引脚信号线" align="center/"><br>数据发送与接收线：<br>TxD：发送数据，将串行数据发送到MODEM　　<br>RxD：接收数据，从MODEM接收发来的串行数据<br>状态线：<br>DSR：表明MODEM可以使用。<br>DTR：表明数据终端可以使用。<br>信号联络线（modem之间建立通信链路）：<br>RI：振铃指示，当MODEM收到交换台送来的振铃呼叫信号时，通知终端，表示交换台准备好了。<br>DCD：数据载波检出线，表示MODEM已接通通信链路。<br>信号联络线（modem与终端之间）：<br>RTS：请求发送，表示DTE请求DCE发送数据。<br>CTS：允许发送，表示DCE准备好了，DTE可以发数据，是对RTS的响应信号。<br>地线：<br>GND：地线</p>
</li>
<li><p><strong>数据传输过程</strong><br><img src="/images/接口技术及应用/RS232C数据传输过程.png" width="495" height="315" alt="RS232C数据传输过程" align="center/"></p>
</li>
<li><p><strong>微机间连线方式</strong><br>重点是不使用联络信号的3线相连方式，如下图所示：<br><img src="/images/接口技术及应用/串口连接方式.png" width="220" height="190" alt="R串口连接方式" align="center/"><br>不使用Modem，TxD和RxD要交叉连接。</p>
</li>
</ul>
<h3 id="8251可编程通信接口"><a href="#8251可编程通信接口" class="headerlink" title="8251可编程通信接口"></a>8251可编程通信接口</h3><p>8251是通用同步异步接收发送器USART(Univesal Synchronous Asynchronous Receiver and Transmitter)，适合作为异步起止式和同步面向字符式的接口。<br><img src="/images/接口技术及应用/8251接口.png" width="275" height="165" alt="8251接口" align="center/"></p>
<h2 id="第八章-存储器"><a href="#第八章-存储器" class="headerlink" title="第八章 存储器"></a>第八章 存储器</h2><ul>
<li><p><strong>内存的分类</strong><br><img src="/images/接口技术及应用/内存的分类.png" width="450" height="200" alt="内存分类" align="center/"><br>DRAM的特点：主要由电容构成，需要定时刷新<br>DRAM芯片举例：intel 2164A，容量为\(64k\times 1\)</p>
</li>
<li><p><strong>存储器扩展技术</strong><br>存储器的存储容量等于：单元数(字节数)×每单元的位数(字长)，因此就有三种扩容方式：字扩展、位扩展、字位扩展。</p>
</li>
<li><p><strong>位扩展</strong><br>地址线、片选线和读写信号线各芯片共用，数据线单独引出。<br>eg：8片64K×1位的SRAM芯片构成容量为64KB的存储器<br><img src="/images/接口技术及应用/位扩展.png" width="400" height="305" alt="位扩展" align="center/"></p>
</li>
<li><p><strong>字扩展</strong><br>地址线、读写信号线和数据线各芯片共用，片选线单独引出。<br>eg：4片16K×8位的SRAM芯片构成容量为64KB的存储器<br><img src="/images/接口技术及应用/字扩展.png" width="470" height="320" alt="字扩展" align="center/"></p>
</li>
<li><p><strong>字位扩展</strong><br>结合了上述两种方法的特点。<br>eg：用8片16K×4位的存储器芯片组成64K×8位的存储器<br><img src="/images/接口技术及应用/字位扩展.png" width="440" height="240" alt="字位扩展" align="center/"></p>
</li>
</ul>
<h2 id="第九章-人机接口"><a href="#第九章-人机接口" class="headerlink" title="第九章 人机接口"></a>第九章 人机接口</h2><ul>
<li><p><strong>键盘接口的分类</strong><br><strong>编码键盘：</strong>这种键盘内部能自动检测被按下的键，并提供与被按键对应的键码（如ASCII码），以并行或串行方式送给CPU。<br><strong>非编码键盘：</strong>这种键盘只提供键盘的行列矩阵，而按键的识别和键值的确定、输入等工作通过软件完成。这是目前可得到的最便宜的微机输入设备。 </p>
</li>
<li><p><strong>软件实现非编码键盘识别的方法</strong><br><img src="/images/接口技术及应用/非编码键盘.png" width="330" height="165" alt="非编码键盘示意图" align="center/"><br><strong>扫描法：</strong><br>依次查询键盘矩阵的每一行线，然后读取列数据确定按键是否在本行，具体方法如下：<br>首先使PA0=0，然后读取PB端口。<br>若PB=0FFH则表示行0没有按键按下，再使PA1=0再读取PB判断行2有无按键按下，依次扫描全部的行线。<br>当PB读取的数据不为0FFH，则表示该扫描行有按键按下，则再确定相应的按键序号。<br>时间复杂度：\(n^2\)<br><strong>行列交换法：</strong><br>使CPU通过A口向各行线上全部送低电平，然后从B口读入列线的值。<br>如果某按键按下，则必定会使某一列线值为0。然后，交换A口B口的输入输出方向，并将刚才读到的列线值从列线所接的并口输出。<br>再读取行线上的输入值，在闭合键所在的行线上的值必定为0。这样，当一个按键被按下时，必定可以读取一对唯一的行值和列值。<br>时间复杂度：\(2n\)</p>
</li>
<li><p><strong>七段数码管</strong><br>七段数码管就是并行接口8255，7个段分别对应8255的一个引脚，通过设置引脚电平来控制亮灭，示意图如下：<br><img src="/images/接口技术及应用/七段数码管.png" width="330" height="165" alt="七段数码管" align="center/"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/微机接口技术与应用/" data-id="cjo6b5dg4000u4sqxx33dp8ap" class="article-share-link" data-share="baidu" data-title="微机接口技术与应用">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/微机接口技术与应用/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程笔记/">课程笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-Sharp/">C_Sharp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English/">English</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/">JSP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lingo/">Lingo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MachineLearning/">MachineLearning</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper-Notes/">Paper Notes</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cs224n/">cs224n</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uwtsd-modules/">uwtsd_modules</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/课程笔记/">课程笔记</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/C/" style="font-size: 12.5px;">C++</a> <a href="/tags/C-Sharp/" style="font-size: 10px;">C_Sharp</a> <a href="/tags/English/" style="font-size: 20px;">English</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Lingo/" style="font-size: 10px;">Lingo</a> <a href="/tags/MachineLearning/" style="font-size: 17.5px;">MachineLearning</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/Other/" style="font-size: 20px;">Other</a> <a href="/tags/Paper-Notes/" style="font-size: 15px;">Paper Notes</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/cs224n/" style="font-size: 15px;">cs224n</a> <a href="/tags/python/" style="font-size: 12.5px;">python</a> <a href="/tags/uwtsd-modules/" style="font-size: 10px;">uwtsd_modules</a> <a href="/tags/课程笔记/" style="font-size: 10px;">课程笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/06/cs224n/background/">基础知识</a>
          </li>
        
          <li>
            <a href="/2018/11/05/cs224n/lecture 2/">lecture 2_Word Vectors</a>
          </li>
        
          <li>
            <a href="/2018/11/02/cs224n/lecture 1/">lecture 1_Introduction</a>
          </li>
        
          <li>
            <a href="/2018/10/18/uwtsd_modules/Distributed & Cluster Computing/">Distributed &amp; Cluster Computing</a>
          </li>
        
          <li>
            <a href="/2018/09/13/Paper Notes/Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/">Personal Recommendation Using Deep Recurrent Neural Networks in NetEase读书笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Ren Li<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
