
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Ren Li&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ren Li&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ren Li&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ren Li&#39;s blog">
  
    <link rel="alternative" href="/atom.xml" title="Ren Li&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ren Li&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Think and write down</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-Paper Notes/Notes of On Availability For Blockchain based Systems" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/Paper Notes/Notes of On Availability For Blockchain based Systems/" class="article-date">
  <time datetime="2018-09-13T07:49:59.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/Paper Notes/Notes of On Availability For Blockchain based Systems/">On Availability For Blockchain based Systems读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a href="https://research.csiro.au/data61/wp-content/uploads/sites/85/2016/08/OnAvailabilityForBlockchain-BasedSystems-SRDS2017-authors-copy.pdf" target="_blank" rel="noopener">论文地址点这里</a></p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>  

<h2 id="论文内容概述"><a href="#论文内容概述" class="headerlink" title="论文内容概述"></a>论文内容概述</h2><p>这是一篇偏重实验的论文，通过研究影响交易提交时间的因素，探讨了目前区块链的可靠性问题，并提出了一种交易终止策略来解决这个问题。</p>
<h3 id="简介-INTRODUCTION"><a href="#简介-INTRODUCTION" class="headerlink" title="简介(INTRODUCTION)"></a>简介(INTRODUCTION)</h3><ul>
<li><p><strong>区块链的可靠性问题</strong><br>可靠性保证不透明：从应用的角度上来说，并不清楚区块链技术是如何保证系统的可靠性的，而且多数区块链系统只能以一定概率保证交易信息的不变性。<br>提交时间不稳定：客户端不可预知交易成功提交所需的时间。从Fig.1中可看出，61.5%的交易在3分钟内就提交了，但13.8%的交易4.5分钟还没提交(延迟了50%)，提交时间的差异可能系统可用性的下降。</p>
</li>
<li><p><strong>论文主要研究内容</strong>  </p>
<ul>
<li>导致交易无法成功提交的因素</li>
<li>以太坊中的transaction inclusion机制</li>
<li>以太坊中gas price和gas limit两个参数对提交时间的影响</li>
<li>以太坊中block gas limit的影响</li>
<li>交易终止机制</li>
</ul>
</li>
</ul>
<h3 id="背景知识-BACKGROUND"><a href="#背景知识-BACKGROUND" class="headerlink" title="背景知识(BACKGROUND)"></a>背景知识(BACKGROUND)</h3><ul>
<li><p><strong>区块链基本知识</strong><br>区块链可认为是一个分布式的公共账本，记载了交易信息和资产信息。区块链中的每个用户本地都存储着一个账本的副本，并运行着一个客户端，负责和整个网络同步更新账本信息。</p>
</li>
<li><p><strong>区块链中的链指什么</strong><br>区块链系统的交易信息存储在区块(block)中，从第二个区块开始，每个区块都有前一区块的哈希值，即相当于把各个区块链起来了，最终各个区块按时间顺序链接起来呈现一套完整的数据(区块链大账本)。 </p>
</li>
<li><p><strong>区块链加密技术</strong><br>区块链采用了非对称加密技术，和传统对称加密最大不同是，加密和解密不再是同一把钥匙，而是分为公钥和私钥。只有特定的用户具有私钥，可以对交易信息进行加密和数字签名；而所有的用户都具备公钥，可以对交易信息解密，并通过数字签名验证交易签署者的身份。 </p>
</li>
<li><p><strong>共识算法</strong><br><strong>问题背景：</strong>因为区块链是分布式存储的，所有节点都需要对区块链中块的内容和次序达成“共识”，为了解决这个问题就提出了共识算法。<br><strong>工作量证明算法(POW)：</strong>这是目前最广泛使用的共识算法，其基本原理是：一个节点将交易信息打包到区块中，并添加一个随机数，再做哈希和运算，之后将块发布到网络中。其他节点接收到块后，根据块中包含的参数进行大量的计算(俗称挖矿)，计算出的结果如果小于哈希和，即完成了这部分工作，得出的结果值就相当于对其工作量的“证明”。拥有“证明”后节点不仅会获得一定奖励，也拥有了创建区块的权利，新创建的区块会加到主链末端，其他节点可在其后面继续添加新区块，其后每添加一个区块，就相当于做了一次确认，当其后的区块达到了一定数量后(比特币是6个，以太坊是12个)，就相当于和网络中其他节点达成“共识”了，这个区块即正式被记录在案了。<br><strong>核心思想：</strong>工作量证明机制的核心思想是工作方要得出结果具有一定难度，但验证方检查结果却非常容易，因此很容易验证工作方是不是做了相应工作。既保证了工作完成后奖励的价值(需要付出大量的计算代价)，激励节点去积极打包交易信息，同时验证的简单性也保证了共识算法的效率和可靠。</p>
</li>
<li><p><strong>分叉问题(fork)</strong><br><strong>基本概念：</strong>考虑一种小概率情况，两个节点恰好同时完成了计算，创建了区块，并向全网进行了广播，这种情况就叫做分叉。形象的理解就是区块链主链的末端被连了两个块，像是分叉了一样。<br><strong>分叉的影响：</strong>正常情况下，网络中所有的节点达成共识，所生成的区块链就是一条主链，内容、次序都是确定的；而在分叉的情况下，区块链会向两个不同的方向延申(因为每一个区块都是依赖于上一个区块产生的)，主链的内容、次序就不确定了，各节点即无法正常地查询交易和资产信息。<br><strong>解决办法：</strong>所有节点都从当前最长的链开始工作。因为有统计结论，链中的区块数越多，越不容易发生分叉现象。</p>
</li>
</ul>
<h3 id="比特币交易的提交-COMMIT-OF-BITCOIN-TRANSACTIONS"><a href="#比特币交易的提交-COMMIT-OF-BITCOIN-TRANSACTIONS" class="headerlink" title="比特币交易的提交(COMMIT OF BITCOIN TRANSACTIONS)"></a>比特币交易的提交(COMMIT OF BITCOIN TRANSACTIONS)</h3><p>在本节中，作者讨论了影响比特币提交时间的因素，并进行了实验验证。</p>
<ul>
<li><p><strong>影响交易提交时间的因素</strong><br><strong>交易手续费(transaction fee)：</strong>手续费的多少会影响节点打包交易信息的积极性，从而影响交易提交的时间。<br><strong>交易是否按顺序到达：</strong>如果一个交易比其所引用的父交易先到达，则被称为orphan。只有父交易提交后，子交易才能提交，否则子交易就会一直在mempool中等待。<br><strong>锁定时间(locktimes)：</strong>这是一个用户可设置的参数，可使得某个交易在特定顺序的区块产生之前一直处于不可用状态。  </p>
</li>
<li><p><strong>实验过程</strong><br><strong>实验任务：</strong>观测交易的产生并记录其提交所花费的时间。为了探究不同网络环境下的情况，作者在2016年11月和2017年4月分别进行了两次实验（第二次实验的网络负载较大）。<br><strong>观测窗口：</strong>为了充分收集包含在区块链中的交易信息，作者定义了观测窗口：从实验开始前的第一个区块到实验结束24h后的一个区块，这之间的交易即处于观测窗口中，都会被记录下来。</p>
</li>
<li><p><strong>实验结果</strong><br>作者主要研究的交易有两类：<strong>Straight-accepts</strong>和<strong>Oranphans</strong>。<br>实验结果1（针对到达顺序因素）：由Fig.2可知两次实验中，Oranphans的提交时间都比Straight-accepts的时间要长，且在第二次实验中尤为明显，可见到达的顺序对提交时间有着显著的影响，按顺序到达的交易比无序到达的交易时间要短很多。<br>实验结果2（针对交易手续费因素）：由Fig.3可知，交易手续费和提交时间之间并没有显著关联。<br>实验结果3（针对locktimes因素）：通过作者分析可知，绝大多数交易并未使用locktimes这个参数，且Oranphans和Straight-accepts这两类交易结束锁定的时间差异也很大，最终作者认为locktimes并非是Oranphans延迟的主要因素。  </p>
</li>
</ul>
<h3 id="以太坊交易的提交-COMMIT-OF-ETHEREUM-TRANSACTIONS"><a href="#以太坊交易的提交-COMMIT-OF-ETHEREUM-TRANSACTIONS" class="headerlink" title="以太坊交易的提交(COMMIT OF ETHEREUM TRANSACTIONS)"></a>以太坊交易的提交(COMMIT OF ETHEREUM TRANSACTIONS)</h3><p>在本节中，作者介绍了以太坊不能保证提交的原理，并实验研究了gas price、gas limit、network三个因素对提交时间的影响。</p>
<ul>
<li><p><strong>以太坊中交易事务的生命周期</strong><br>1、交易声明：交易发生并声明。<br>2、交易打包进区块：发布节点将交易信息打包到区块中。<br>3、区块链接到主链：节点完成打包计算，将区块链接到主链。<br>4、交易正式提交：其后链接了一定数量的区块后，即正式提交。<br>注：因为分叉现象或其他原因，步骤2并不能保证交易最终一定被提交，这就产生系统的可靠性问题。</p>
</li>
<li><p><strong>实验过程</strong><br>实验任务：研究交易从打包到最终提交所花费的时间以及分支合并后会丢失多少已打包的交易。<br>创建监听节点：作者改写了一个客户端节点作为监听节点，以检测交易声明和区块声明。<br>记录时间：监听节点会记录交易声明的时间和区块到达的时间，以计算交易提交的延迟时间。<br>计算方法：根据交易声明的时间和包含此交易的第一个区块到达的时间，我们计算这之间的时间差，结果就是Fig.5中的<br><code>1st inclusion</code>；当第一个块变为叔块时，我们可根据包含此交易的第二个区块到达的时间，计算出<code>2nd inclusion</code>；同理，<br><code>3rd inclusion</code>也是这么计算的；此外，我们根据最后一个区块的到达时间，可以计算出<code>12 confirmations</code>和<code>36 confirmations</code>。将上述计算出的结果绘成图表，就是文中的Fig.5。</p>
</li>
<li><p><strong>实验结果</strong><br>实验结果1（各类提交时间的对比）：从Fig.5中可知，相比1st/2nd/3rd inclusion，12/36 conclusion的提交时间更长，而36 conclusion尤为明显，这说明交易数量越多，交易提交所花费的时间越长。<br>实验结果2（针对gas price因素）：从Fig.6中可知，总体趋势是gas price越高，延时越短，但gas price高于25Gwei后对延时的影响就非常小了。这也侧面解释为什么大部分交易定价在[20,25)的区间内(性价比最高)。<br>实验结果3（针对maximum gas因素）：虽然有个别交易因maximum gas过高而有明显的延时，但作者依旧认为maximum gas和提交时间之间没有很强的关联性。<br>实验结果4（针对network delays因素）：虽然没有得出明确的结论，但作者分析了in-order和out-of-order交易在提交延迟和数量方面的数据后，认为网络延迟对交易的传播是有负面影响的。</p>
</li>
</ul>
<h3 id="BLOCK-GAS-LIMIT对以太坊的影响-IMPACT-OF-THE-BLOCK-GAS-LIMIT-IN-ETHEREUM"><a href="#BLOCK-GAS-LIMIT对以太坊的影响-IMPACT-OF-THE-BLOCK-GAS-LIMIT-IN-ETHEREUM" class="headerlink" title="BLOCK GAS LIMIT对以太坊的影响(IMPACT OF THE BLOCK GAS LIMIT IN ETHEREUM)"></a>BLOCK GAS LIMIT对以太坊的影响(IMPACT OF THE BLOCK GAS LIMIT IN ETHEREUM)</h3><ul>
<li><p><strong>产生原因</strong><br>出台gas limit per block的原因是希望通过限制每个区块消耗的gas总量，防止DDoS攻击。如果交易所需的气体超过了限制值，交易就无法被包含到块中，这就使得大规模的分布式拒绝服务攻击难以发生。</p>
</li>
<li><p><strong>问题背景</strong><br>在没有限制之前，签署合约花费了150万的气体，因此作者认为限制会对合约相关的交易产生负面影响，但对单纯的资金转移交易应该影响不大，之后作者即针对这个观点进行了分析。</p>
</li>
<li><p><strong>分析结果</strong><br>由Fig.10可知，在50万气体的限制下，有46.21%的合约类交易无法正常进行；在200万气体的限制下，也有18.78%的合约类交易无法产生。因为气体限额的存在，大量的合约类交易无法进行，这也验证了作者之前的观点。</p>
</li>
</ul>
<h3 id="以太坊的交易终止机制-TRANSACTION-ABORT-IN-ETHEREUM"><a href="#以太坊的交易终止机制-TRANSACTION-ABORT-IN-ETHEREUM" class="headerlink" title="以太坊的交易终止机制(TRANSACTION ABORT IN ETHEREUM)"></a>以太坊的交易终止机制(TRANSACTION ABORT IN ETHEREUM)</h3><p>这一节主要对应了作者在摘要中提到的观点：终止机制的缺失会使大量交易处于既未终止也未提交的”pending”状态，严重影响系统的可靠性。为解决这个问题，作者提出了一种交易终止的机制，并进行了实验考察。</p>
<ul>
<li><p><strong>终止原理</strong><br><strong>竞争法：</strong>如果先前的交易\(Tx_i\)在规定的时间内未提交，账户可以重新发布一个具有相同nonce序号的交易\(Tx_i^{\prime}\)，赋予其更高的手续费，并将交易的接收方设为自己。一旦\(Tx_i^{\prime}\)成功提交，\(Tx_i\)就会自动过期了，即终止了其状态。<br><strong>重传法：</strong>账户重新发布一个与\(Tx_i\)内容相同的交易\(Tx_i^{\prime\prime}\)，但设置较高的手续费，这样虽然\(Tx_i^{\prime\prime}\)交易信息和\(Tx_i\)是一样的，但数字签名和哈希值却不一样(因为手续费不一样)，这样其他节点会把其当作一个新的交易。只要交易\(Tx_i\)和\(Tx_i^{\prime\prime}\)任何一个成功提交了，另外一个即过期了(因为nonce是一样的)，这样也可以达到终止的目的。</p>
</li>
<li><p><strong>实验模拟的三种情况</strong><br>1、交易在规定时间内没有被打包<br>2、因为手续费不足，用户决定撤回之前发布的交易<br>3、因为账户余额不足，交易无法被正常提交，即进入”pending”状态</p>
</li>
<li><p><strong>对情况1的实验</strong><br>实验原理：为了降低交易被打包的概率，作者减少了交易的手续费，分别为市场均价的0%、10%、…、90%，并设置了10min的截止时间。如果截止时间内原交易未提交，就按照上文提到的竞争法进行终止。<br>实验结果1：大部分交易都成功提交了，甚至30%-90%市场价的交易全部成功提交。出现这样的情况，我猜测可能是因为设置的终止时间太长了，即虽然手续费低，但只要时间足够长，交易还是有可能成功提交的。<br>实验结果2：在0-20%市场价的交易中，有16个没有成功提交，但最后都成功终止了，终止成功率为100%。</p>
</li>
<li><p><strong>对情况2的实验</strong><br>实验原理：这种情况考虑的是客户端希望撤回原先的交易，因此相比情况1，设置的截止时间要短一些（因为如果再设置很长时间的话，就失去模拟用户自行撤回的意义了），实验中是取所有交易提交时间的中位点，即3min。<br>实验结果1：截止时间缩短后，未提交的交易数明显增多，总共有53个交易没有提交，甚至0-20%市场价的交易全部没有提交成功，这也验证了我在实验1中的猜想。<br>实验结果2：虽然未提交的交易数量大大增加，但依旧每个交易都成功终止了，成功率为100%。</p>
</li>
<li><p><strong>对情况3的实验</strong><br>实验原理：首先作者创建了两个交易：\(Tx_1(bonce=n+1,value=\frac {k} {1000})\)和\(Tx_1(bonce=n+1,value=\frac {999k} {1000})\)，k为当前账户的余额。其次为了模拟余额不足这种情况，作者采用了一种很巧妙的方式：先发送\(Tx_2\)，隔5s后再发送\(Tx_1\)，这样可以使得\(Tx_2\)顺利发出，因为先发\(Tx_1\)的话，一旦其被顺利打包，\(Tx_2\)就会因为余额不够而无法发送到网络中了。采用这种方式，\(Tx_2\)就有可能比\(Tx_1\)先发到网络中，又因为\(Tx_1 nonce&lt;Tx_2 nonce\)，所以\(Tx_1\)必然会比\(Tx_2\)先打包，这样\(Tx_2\)就会因余额不够而停滞在网络中，即成功模拟了因余额不足所导致的”pending”状态。<br>实验结果：作者进行了100次实验，终止成功率依然是100%，结合前两次实验的结果，说明终止机制的效果还是非常好的。</p>
</li>
</ul>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><h3 id="对于区块链的理解"><a href="#对于区块链的理解" class="headerlink" title="对于区块链的理解"></a>对于区块链的理解</h3><ul>
<li>区块链的本质是一个去中心化的分布式账本。我认为区块链就是一个账本，记载了所有交易信息和资产信息，但和传统金融记录方式的不同在于，区块链账本并非存储在某一个中心，其在每一个用户的本地都有存储的副本，相当于每个用户都是一个中心。  </li>
<li>去中心化带来的好处：首先是不用考虑中心的故障问题，就像双11，你再想买一个东西，淘宝服务器一旦瘫痪就不行了，所有的交易都依赖于这个第三方的中心；其次是不用担心信息泄露的问题，还是淘宝的例子，你要买东西、卖家要卖东西，都要提供个人信息，交易完成后也会产生交易信息，这些都被存在淘宝的服务器中，在当今这个强调个人隐私的时代，这是非常让人困扰的；第三是安全，区块链技术具有不可篡改性，我们不用担心因第三方中心的原因导致我们的资产受损失(如银行破产)。  </li>
<li>去中心化带来的问题：最大的问题是我们如何在各个节点间同步数据。在中心化系统中，中心说什么就是什么，其他人只需和中心保持同步即可；而在去中心化系统中，我们需要和全网进行同步，难度增大了很多，为了解决这个问题，也就出现了共识机制，大家共同记账，一定数量的节点达成共识后，就可正式在网络中进行同步了；而为了提高大家记账的积极性，就出现了工作量证明算法，对于成功记账的人会有奖励，大家都去积极记账了，账本自然就可以不断地维护、更新了。</li>
</ul>
<h3 id="对于区块链可靠性的理解"><a href="#对于区块链可靠性的理解" class="headerlink" title="对于区块链可靠性的理解"></a>对于区块链可靠性的理解</h3><ul>
<li>本文对于区块链可靠性的研究主要围绕“交易提交时间”这个概念，一个交易产生了，最好的情况是在规定时间内顺利打包，加入到区块链主链中。但因为复杂的网络环境、交易手续费或其他种种因素，一个交易的提交很可能会产生延迟，甚至会出现交易既没有提交、又没有销毁的”pending”状态。  </li>
<li>这就需要我们去探讨两个方面的问题：到底有哪些因素会影响交易的提交时间？交易如果没有顺利提交我们应该采取什么办法？前者就是文章第三、第四节主要研究的内容，通过具体的实验分析了各种可能影响因素；后者则是作者在第六节研究的内容，提出了一种交易终止机制并进行了实验测试。</li>
</ul>
<h3 id="对于交易终止机制的理解"><a href="#对于交易终止机制的理解" class="headerlink" title="对于交易终止机制的理解"></a>对于交易终止机制的理解</h3><ul>
<li>文中提到了两种交易终止的方法：竞争法和重传法，虽然有些区别，但本质思想都是一样的，都是利用了“nonce相等”的原理来终止原来的交易。  </li>
<li>文中还提到，虽然以太坊不像比特币那样把每一个块都链接起来，但其每个块都有唯一的顺序号nonce，而且主链上的区块必须是按顺序的，因此我们就可以利用nonce号来使某次交易过期，从而达到终止的目的。</li>
</ul>
<h3 id="其他一些感想"><a href="#其他一些感想" class="headerlink" title="其他一些感想"></a>其他一些感想</h3><ul>
<li>论文中还有一点使我印象很深刻，就是整篇文章都贯穿着实验的思想，作者进行了大量的实验去研究某些因素的影响，对所提出的终止机制也进行了具体的实验探究，实验过后还有对实验结果的合理分析，这些都使得整篇文章的逻辑结构很清晰，值得我在今后的科研工作中去学习。</li>
</ul>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><h3 id="对比特币实验中无序现象产生的原因进行研究"><a href="#对比特币实验中无序现象产生的原因进行研究" class="headerlink" title="对比特币实验中无序现象产生的原因进行研究"></a>对比特币实验中无序现象产生的原因进行研究</h3><ul>
<li>在第三节中，作者研究了到达顺序对交易提交时间的影响，最终得出了结论：顺序到达的交易比无序到达的交易的延时要短。</li>
<li>作者虽然分析出了现象，但对产生这种现象的原因并没有深入研究，我认为如果对无序现象产生的原因进行研究，也会有助于改善区块链系统的可靠性问题。</li>
<li>方案实现：可参考文中第三节引言部分提到的几种情况，我认为可以主要研究节点转发策略和节点负载这两个因素，转发策略的不同可能会打乱原先的交易分发顺序，从而使得交易无法按顺序到达其他节点；而节点负载主要会影响交易传播的速度，不同节点的传播速度如果不同，也可能会导致交易失序。有了初步的分析，我们可设计实验来具体研究：首先选择一定量的矿工节点，将其按照不同的转发策略和不同的节点负载进行分组，转发策略可通过观察客户端版本、研究底层转发行为的实现代码等方式得出，而节点负载可通过观测相应网络指标得到。之后可以对两种因素进行控制变量分析，从而研究其对交易到达顺序的影响。</li>
</ul>
<h3 id="对比特币实验2中部分Orphans数据未统计的情况进行改进"><a href="#对比特币实验2中部分Orphans数据未统计的情况进行改进" class="headerlink" title="对比特币实验2中部分Orphans数据未统计的情况进行改进"></a>对比特币实验2中部分Orphans数据未统计的情况进行改进</h3><ul>
<li>在比特币的实验2中，因为高网络负载的原因，有20%的Orphans交易最后未被打包到块中，观测样本因此少了20%，作者也认为这对实验结果是一个很大的限制，因此我认为可根据这一点做下改进。  </li>
<li>方案实现：我考虑了两种思路，思路一：选择网络负载比实验2小但比实验1大的一个时间点，按照同样的方式做实验3，这样既可观测到不同网络环境下的实验结果，也可以减小网络负载对Orphans交易的影响，不至于使实验观测到的样本减少太多；思路二：保持实验1和实验2的网络条件不变，增加观测窗口的时长，分别进行实验3和实验4。由Fig.2可知计算的是累积比例，因此增加观测窗口相当于延长了一段X轴，Orphans Exp 2这条线最终就有机会到达1，而对其他三条曲线则不会有影响(它们已经很接近1了)，因此就可收集到更多的Orphans数据。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/Paper Notes/Notes of On Availability For Blockchain based Systems/" data-id="cjmmeykyo001zd5qxqjlomff5" class="article-share-link" data-share="baidu" data-title="On Availability For Blockchain based Systems读书笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/Paper Notes/Notes of On Availability For Blockchain based Systems/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper-Notes/">Paper Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Paper Notes/Notes of Efficient Estimation of Word Representations in Vector Space" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/Paper Notes/Notes of Efficient Estimation of Word Representations in Vector Space/" class="article-date">
  <time datetime="2018-09-13T07:49:59.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/Paper Notes/Notes of Efficient Estimation of Word Representations in Vector Space/">Notes of Efficient Estimation of Word Representations in Vector Space读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a href="https://arxiv.org/pdf/1301.3781.pdf?" target="_blank" rel="noopener">论文地址点这里</a></p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script> 

<h2 id="论文内容概述"><a href="#论文内容概述" class="headerlink" title="论文内容概述"></a>论文内容概述</h2><p>这是谷歌发布的关于词向量的经典论文，针对传统模型无法表征单词间关联性的问题，本文提出了两种连续的词向量模型，并针对模型实现了分布式学习模块，最后基于词向量的线性运算设计了一种评价模型精度的方法，取得了良好的效果。</p>
<h3 id="简介-INTRODUCTION"><a href="#简介-INTRODUCTION" class="headerlink" title="简介(INTRODUCTION)"></a>简介(INTRODUCTION)</h3><ul>
<li><p><strong>传统NLP技术的特点</strong><br>传统NLP技术主要是基于单词间没有相似性的思想，将词汇以单词表索引的形式来表示。这样做虽然有很多好处，如简单、健壮、使用大量数据训练的简单模型的效果好于使用少量数据训练的复杂模型等；但同样也有很多限制，如语料数据库没有足够的数据、无法表征单词间的关联等。因此作者认为原先的技术很难再取得突破，需要去发掘新的技术。</p>
</li>
<li><p><strong>论文主要工作</strong><br>1、从大量单词和短语数据中学习出高质量的词向量，并且要保持一个合适的向量维度。<br>2、使用了一种评估词向量精度的技术，期望不仅相似的单词可以趋向接近，同时单词间能具有更多维的相似度。<br>3、使用单词偏移技术对词向量做简单的代数运算，以更好地挖掘词向量间的相似性规则。<br>4、设计了一个综合测试集来探究句法和语义的规律性，并研究了词向量维度和训练数据量这两个因素对训练时间和模型精度的影响。</p>
</li>
</ul>
<h3 id="模型框架-Model-Architectures"><a href="#模型框架-Model-Architectures" class="headerlink" title="模型框架(Model Architectures)"></a>模型框架(Model Architectures)</h3><p>在本节中，作者使用了NNLM和RNNLM两种神经网络来学习连续的单词表示方法，并且对不同神经网络的训练复杂度进行了分析。</p>
<ul>
<li><p><strong>训练复杂度公式</strong><br>作者首先提出了分析训练复杂度的公式：\(O=E\times T\times Q\)，其中E为训练的趟数，T为训练集中单词的数量，Q为表征模型复杂度的变量，下文还会对Q具体分析。</p>
</li>
<li><p><strong>前馈神经网络语言模型(NNLM)</strong><br>基本结构：整个网络分为输入层、映射层、隐含层和输出层，输入层将前N个单词编码为1-of-V的向量，V为词表大小，这N个单词共享相同的映射矩阵，阵映射到映射层，之后再从映射层转换到隐含层，经过一系列计算后输出最终结果。<br>模型复杂度：\(Q=N\times D+N\times D\times H+H\times V\)，因为N是一个较小的量，因此\(N\times D\)也比较小；另外对单词表用二叉树做优化，可使得\(V\)下降到\(log_2(V)\)，这样\(H\times V\)也会减小，最终模型的复杂度主要就集中在\(N\times D\times H\)，即映射层-&gt;隐含层这部分。<br>注：对于单词表的表示，还可以继续用哈夫曼树做优化，减少高频单词的编码长度，从而进一步降低输出层的计算量。</p>
</li>
<li><p><strong>循环神经网络语言模型(RNNLM)</strong><br>模型特点：RNN最大的特点是其自连接性，即状态的更新不仅取决于输入，还取决于上一时刻自己本身的状态，这个特性就使得RNN具有了一种“短时”的记忆，可以更好地表示前后文本之间的关联。<br>模型复杂度：RNNLM中没有映射层，因此模型复杂度简化为\(Q=H\times H+H\times V\)。和上文同理，\(V\)可以优化为\(log_2(V)\)，因此模型的复杂度主要集中在\(H\times H\)。</p>
</li>
<li><p><strong>神经网络的平行训练模型</strong><br>为了提升在大规模数据集上训练模型的效率，作者在DistBelief框架的基础上实现了一个分布式计算模型，允许多个副本并行地学习训练，而且所有副本会同步进行梯度更新，作者在下文会分析模型的具体效果。  </p>
</li>
</ul>
<h3 id="新的对数线性模型-New-Log-linear-Models"><a href="#新的对数线性模型-New-Log-linear-Models" class="headerlink" title="新的对数线性模型(New Log-linear Models)"></a>新的对数线性模型(New Log-linear Models)</h3><p>在本节中，作者提出了两个连续词向量模型，希望能使用一种更简单的模型来训练更大量的数据，以通过增加训练量来提升训练效果。</p>
<ul>
<li><p><strong>连续词袋模型(Continuous Bag-of-Words Model)</strong><br>基本结构：模型与前馈NNLM比较相似，但是去掉了非线性隐含层，并且所有单词直接共享整个映射层，而非只是映射矩阵。通过这种方法，所有的单词被映射到同一位置，对这些向量进行平均后即为最终的映射结果。<br>模型特点：1、所有的单词最终都被映射到同一位置，因此单词的顺序就不再起作用了；2、为了对单词进行分类，模型会同时使用上下文的一部分单词进行计算；3、模型的作用是根据上下文来推测中间可能出现的单词；4、与传统词袋模型的不同在于其对于上下文的表示是连续。<br>模型复杂度：\(Q=N\times D+D\times log_2(V)\)</p>
</li>
<li><p><strong>连续Skip-gram模型(Continuous Skip-gram Model)</strong><br>模型特点：1、模型的结构类似上述CBOW模型，可以说是“镜像对称”的；2、Skip-gram模型的作用也和CBOW模型相反，其是根据中间的单词，来推测单词的上下文信息；3、考虑到大部分距离较远的单词之间的关联性都较小，因此作者减少了远距离单词的训练样本数量，以降低其权重。<br>模型复杂度：\(Q=C\times (D+D\times log_2(V))\)，C指单词最大化距离，使用模型时会随机选取\([1,C]\)中的一个值作为取词窗口的长度。  </p>
</li>
</ul>
<h3 id="结果分析-Results"><a href="#结果分析-Results" class="headerlink" title="结果分析(Results)"></a>结果分析(Results)</h3><ul>
<li><p><strong>核心思想</strong><br>考虑明显具有相同相似关系的两对单词，如”biggest”、”big”和”smallest”、”small”，计算\(X=D(biggest)-D(big)+D(small)\)，若词向量模型训练成功，应有\(X\)与\(D(smallest)\)是向量空间中距离最近的点。</p>
</li>
<li><p><strong>实验设计</strong><br>作者从句法和语义的角度列出若干相似的类别，分别在每个类别中加入若干单词对，将这些单词对随机两两组合，基于上述公式，计算是否是距离最近的点，若是，即为一次正确的实验结果，最终统计总体正确率来评价模型的优劣。</p>
</li>
<li><p><strong>提升模型精度</strong><br>作者研究了训练数据量和词向量维度两个因素对CBOW模型精度的影响，发现如果只单纯提升某一个因素，对模型精度的影响都是有限的，因此需要同时提升两个因素才能取得比较好的效果。</p>
</li>
<li><p><strong>各模型的对比</strong><br>对比1：在相同训练量和向量维度的条件下，作者对比了RNNLM、NNLM、CBOW和Skip-gram四种模型的精确度，由Table 3可知，CBOW和Skip-gram两种模型的表现明显好于RNNLM、NNLM模型。<br>对比2：作者研究了增大训练量和增大向量维度对CBOW和Skip-gram两种模型的影响，发现只将训练量增大两倍和只将向量维度增大两倍，取得的效果是差不多的，增加的训练时间也比较接近；同时可以发现，两倍数据训练一趟比单倍数据训练三趟的效果要好。<br>对比3：作者将文中的模型与已公布的其他向量模型做了对比，综合表现最好的依旧是Skip-gram。<br>对比4：作者使用了之前提到的分布式计算框架，将向量维度提升到了1000，使用谷歌新闻数据集进行训练，在这种情况下Skip-gram模型的精度依旧是最高的，而且达到了65.6%。<br>对比5：介绍了微软的一个挑战赛，给定挖去一个词的句子和五个候选词，求哪个词和句子最匹配。作者将句子填词问题反向转化为了由词去预测句子的问题，预测出原句的概率最大的那个词，就是所求的词。作者利用Skip-gram+RNNLMs的组合模型，取得了所有模型中最好的效果。</p>
</li>
</ul>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><h3 id="关于连续词向量模型"><a href="#关于连续词向量模型" class="headerlink" title="关于连续词向量模型"></a>关于连续词向量模型</h3><ul>
<li>本文的工作主要围绕着连续词向量模型，因为传统的词向量表示是将单词视作一个个离散的符号，这样做的缺点是无法提供足够的信息来体现词语之间的关联，比如虽然Italy和Rome两个单词看起来一点也不像，但其实两者之间是有联系的(Rome是Italy的首都)，而如何研究出这种潜在的联系，便是本文的主要讨论内容。  </li>
<li>作者的思路是通过词向量来表征这种潜在的联系，首先使用了两种神经网络来生成词向量，但因为隐含层的计算开销过大，使得模型无法训练大量数据集，也无法提升词向量的维度；因此作者从简化模型的角度，提出CBOW和Skip-gram两种模型，并且使用了分布式训练框架，这使得模型能够针对大量数据集进行训练，从而获得更好的训练效果。  </li>
<li>训练出向量模型后，作者为了检测向量模型的效果，基于“相似度高的向量距离近”的思想，提出了一种检测算法，对向量进行代数运算并计算之间的距离，如果相似度高的向量计算出的距离确实小，就说明模型是合理的，作者即通过这个思路分析了各个模型的优劣。</li>
</ul>
<h3 id="关于词向量的线性运算"><a href="#关于词向量的线性运算" class="headerlink" title="关于词向量的线性运算"></a>关于词向量的线性运算</h3><ul>
<li>文中所用的检测词向量精度的方法是基于词向量的线性运算，即“意大利-罗马+巴黎=法国”这样的计算规则，通过这个算式，我们可以很明显地感受到词之间所具有的某种关联，利用这种关联就可以大大扩展词向量的应用范围。  </li>
<li>但具体为什么会有这种性质呢？我认为可能的原因：词向量的假设是基于上下文的分布来推导词义，而“意大利-罗马+巴黎=法国”可以转换为“意大利+巴黎=法国+罗马”，而只有意大利和巴黎共同的上下文与法国和罗马共同的上下文是相似的，才会有这样的相等关系。而仔细考虑一下，这两对词的上下文确实是有可能比较像的，比如一篇介绍欧洲国家的文章，这些词所在的语境肯定是很相近的，这也就是我们把这些词作为相似词的原因。</li>
</ul>
<h3 id="关于训练数据量"><a href="#关于训练数据量" class="headerlink" title="关于训练数据量"></a>关于训练数据量</h3><ul>
<li>本文还有一个比较重要的思想是：简化模型，提升学习效率，利用更大的训练量来求得更好的训练效果。作者一开始就是因为神经网络模型的计算量太大，因此舍弃了隐含层，简化模型，从而提出了CBOW和Skip-gram这两个模型。</li>
<li>这样做虽然可能会损失一部分隐含层所提升的精度，但计算开销大大降低了，结合分布式学习模型，可以极大地提升训练量和向量维度的上限，从而弥补因简化模型而损失的精度。实验结果证明了这样的方案是可行的，这也为我们今后如何改善模型精度提供了一个思路。</li>
</ul>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><h3 id="关于CBOW模型的语义问题"><a href="#关于CBOW模型的语义问题" class="headerlink" title="关于CBOW模型的语义问题"></a>关于CBOW模型的语义问题</h3><ul>
<li>在CBOW模型中，所有的单词最终都会映射到同一位置，模型是不考虑单词顺序的。我认为这样做主要是因为CBOW模型的作用是从上下文中推测相关的单词，即模型关注的是文章中是否出现单词，并不关注单词出现的顺序，因此舍弃顺序也是合理的。  </li>
<li>但这样做也会有一定问题，即一些语句虽然单词组成一样，但语义却有明显不同。如“李丽是谁的姐姐”和“李丽的姐姐是谁”，这两句话的词袋模型是完全一致的，但如果不考虑语法结构，我们很难得出正确的结果。因此在这种情况下，我们可以将词袋模型和句法分析相结合，来求出句子的真正含义。</li>
</ul>
<h3 id="CBOW模型和Skip-gram模型与神经网络相结合"><a href="#CBOW模型和Skip-gram模型与神经网络相结合" class="headerlink" title="CBOW模型和Skip-gram模型与神经网络相结合"></a>CBOW模型和Skip-gram模型与神经网络相结合</h3><ul>
<li>文章最后提到神经网络词向量和其他技术的结合可能会有很好的效果，作者在微软的挑战赛中也通过Skip-gram+RNNLMs取得了很高的预测精度，说明这个结合思路是可行的。  </li>
<li>因为首先CBOW和Skip-gram都未考虑单词的顺序，会带来一定的语义问题；同时RNN模型本身具有自连接性质，这可以使其对前后的单词的关联性有更好的“记忆”，因此两者结合可能会有互补的效果。关于实现，可以将两者的词向量模型以一定权重进行组合，得出新的词向量，以探究其在相关问题中的表现效果。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/Paper Notes/Notes of Efficient Estimation of Word Representations in Vector Space/" data-id="cjmmeykyq0023d5qxnaa84x4r" class="article-share-link" data-share="baidu" data-title="Notes of Efficient Estimation of Word Representations in Vector Space读书笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/Paper Notes/Notes of Efficient Estimation of Word Representations in Vector Space/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper-Notes/">Paper Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Paper Notes/Notes of Personal Recommendation Using Deep Recurrent Neural Networks in NetEase" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/Paper Notes/Notes of Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/" class="article-date">
  <time datetime="2018-09-13T07:49:59.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/Paper Notes/Notes of Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/">Personal Recommendation Using Deep Recurrent Neural Networks in NetEase读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a href="http://cfm.uestc.edu.cn/~zhangdongxiang/papers/ICDE16_industry_231.pdf" target="_blank" rel="noopener">论文地址点这里</a></p>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>  </p>
<h2 id="论文内容概述"><a href="#论文内容概述" class="headerlink" title="论文内容概述"></a>论文内容概述</h2><p>本文结合RNN和FNN两种神经网络提出了一种新的个性推荐方法，希望解决传统的CF方法无法进行实时推荐的问题，最终在网易的考拉电商网站上取得了良好的效果。</p>
<h3 id="简介-INTRODUCTION"><a href="#简介-INTRODUCTION" class="headerlink" title="简介(INTRODUCTION)"></a>简介(INTRODUCTION)</h3><ul>
<li><p><strong>传统CF模型存在的问题</strong><br>因为是基于用户购物习惯的推荐，使用的是历史信息，未能利用用户当前的浏览历史，因此无法进行实时推荐。</p>
</li>
<li><p><strong>如何进行实时推荐</strong><br>首先要考虑访问电商网站的用户属性，包括基本属性(浏览器、IP地址、个人基本信息、购买历史等)和动态属性(用户所浏览页面的信息)，而基于后者，我们就可以猜测用户在本次访问中究竟想要购买什么，从而完成实时推荐。</p>
</li>
<li><p>之后作者对系统主要面临的挑战、所构建DRNN的特点和其他一些技术作了介绍，即完成了本节内容。</p>
</li>
</ul>
<h3 id="推荐模块概述-OVERVIEW-OF-RECOMMENDATION-MODULE"><a href="#推荐模块概述-OVERVIEW-OF-RECOMMENDATION-MODULE" class="headerlink" title="推荐模块概述(OVERVIEW OF RECOMMENDATION MODULE)"></a>推荐模块概述(OVERVIEW OF RECOMMENDATION MODULE)</h3><ul>
<li><p><strong>系统流程</strong><br>服务器首先接收用户请求并聚合为一个会话信息，之后将其输入到推荐系统中，经过RNN和FNN计算后输出推荐结果，并在页面中显示。</p>
</li>
<li><p><strong>数据格式</strong><br>数据收集：假设用户\(u_i\)访问网站，会生成日志文档\(D_j^l\)和会话文档\(D_i^s\)两种文档，两者关系为\(D_i^s=\{D_0^l,D_1^l,\cdots,D_{k-1}^l\}\)，即一个会话文档对应多个日志文档。<br>数据简化：又因为每个日志文档都可简化为一个URL地址\(p_j\)，因此可得\(D_i^s=\{p_0,p_1,\cdots,p_{n-1}\}\)。<br>最终的输入数据：访问网站的每个用户\(u_i\)都会对应一个\(D_i^s\)，即构成了神经网络的输入数据。</p>
</li>
</ul>
<h3 id="DRNN具体介绍-DEEP-RECURRENT-NEURAL-NETWORK"><a href="#DRNN具体介绍-DEEP-RECURRENT-NEURAL-NETWORK" class="headerlink" title="DRNN具体介绍(DEEP RECURRENT NEURAL NETWORK)"></a>DRNN具体介绍(DEEP RECURRENT NEURAL NETWORK)</h3><ul>
<li><p><strong>RNN的特点</strong><br>RNN即循环神经网络，相比其他神经网络最大的特点是：其考虑了前后两个状态之间的关联，可以更好地处理序列信息。在本文的场景中，一个session可抽象为一系列的网页序列，因此利用RNN来进行推荐直观上是非常合适的。</p>
</li>
<li><p><strong>基本RNN模型</strong><br>在单个隐藏层的RNN中，隐藏层节点除了的输入和输出外，还会有一个自连接环，可以根据时间来不断地更新它的值。<br>更新函数：\(a(i)=f(Ux(i)+Wa(i-1))\)，\(a(i)\)表示在状态\(i\)下的节点值，\(x(i)\)表示输入值，\(U,W\)为相应的转移矩阵，\(f(x)\)为激活函数。<br>公式理解：隐藏层节点每次更新除了会考虑输入值外，还会考虑该节点在前一状态下的值，因此RNN的结果可以反映时间序列的相应信息。</p>
</li>
<li><p><strong>有限状态的DRNN</strong><br>当RNN具有多个隐藏层时，即构成了DRNN。考虑DRNN中第\(i\)层的某个状态\(t\)，其不仅会连接同层的状态\(t+1\)，还会连接到第\(i+1\)层的状态\(t\)，即构成了新的更新函数：<br>$$ f(x)=\left\{<br>\begin{align}<br>&amp;f(W_ia_i(t-1)+Z_i(a_{i-1}(t)+b_i(t)))&amp;,&amp; i&gt;1 \\<br>&amp;f(W_ia_i(t-1)+Z_i(V_t+\theta (p_t)))&amp;,&amp; i=1<br>\end{align}<br>\right.<br>$$</p>
</li>
<li><p><strong>引入历史状态节点的DRNN</strong><br>问题背景：受限于内存，我们不可能保存用户所有产生的状态；但如果使用\(n\)状态的滑动窗口，则只能选择最新的\(n\)个数据训练模型，会降低预测精度。因此作者引入了历史状态节点(history state)的概念。<br>当用户访问的页面数\(x\)超过一定数量\(n\)时，我们将前\(x-n\)个状态组合起来作为历史状态节点，有<br>$$\bar{V}=\sum_{i=0}^{x-n}\varepsilon_iV_i$$<br>$$\varepsilon_i=\frac {\theta(p_i)} {\sum_{j=i}^{x-n}\theta(p_j)} $$<br>公式理解：根据用户在页面的停留时间对前\(x-n\)个页面作加权平均，近似表征用户的历史信息，是一个既在一定程度上保证了模型精度，计算开销又不至于太大的折中方案。</p>
</li>
<li><p><strong>与协同过滤算法的结合</strong><br>问题背景：虽然协同过滤算法无法提供实时的推荐，但如果用户遵循以往购买习惯，其推荐效果还是很好的。因此作者引入了FNN模型来模拟CF算法，作为RNN的补充。<br>另外使用FNN还有两点好处：</p>
<ul>
<li>FNN和RNN共享相同的输出层，因此可以将二者的输出融合起来作为最终结果，来表征用户购买某件商品的概率。</li>
<li>可以使用随机最速下降法(SGD)来训练RNN和FNN结合的权重，而不用人为地决定哪个网络更为重要，减轻了模型调参的工作量。</li>
</ul>
</li>
<li><p><strong>如何生成训练数据</strong><br>用户从进入网站开始到最终购买商品，会经历一定数量的页面，个性推荐的本质目标就是减少这之间页面的数量。对于一次购买行为\(I\)，其对应的页面路径为\(p_0,\cdots,p_{n-1}\rightarrow I\)。若对其进行优化，不一定非要优化成\(p_0\rightarrow I\)这样(当然这是最优情况)，只要能减少用户的页面访问数量，都可以算作优化。因此我们的训练数据还可以是\(p_0,p_1\rightarrow I\)、 \(p_0,p_1,p_2\rightarrow I\)等，这样一次购买行为就可以产生\(n\)组训练数据，大大增加了我们的训练量。</p>
</li>
<li><p><strong>模型的实现</strong><br>作者使用了Caffe框架来实现模型，整个网络包含三层隐含层，且同一层次的神经元共享相同的权重和偏置矩阵。此外，模型的RNN部分包含4个状态的输入，FNN包含1个状态的输入。</p>
</li>
</ul>
<h3 id="模型调优-MODEL-OPTIMIZATIONS"><a href="#模型调优-MODEL-OPTIMIZATIONS" class="headerlink" title="模型调优(MODEL OPTIMIZATIONS)"></a>模型调优(MODEL OPTIMIZATIONS)</h3><p>这一节作者介绍了其为了改进模型性能所做的工作，并提出了一种自动调优框架，使得模型具有了更高的精度和更快的学习速度。</p>
<ul>
<li><p><strong>自动代码生成器</strong><br>问题背景：模型中包括了很多参数，调整这些参数需要更改甚至重写Caffe脚本，非常繁琐。因此作者构建了一个代码生成器，其主要任务是接收参数值，输出对应的Caffe脚本。<br>主要思想：首先将参数分为<strong>基本参数</strong>(损失函数、学习速率等)和<strong>网络结构参数</strong>(每层的神经元数)，调整基本参数只需更改相应的值，而调整网络结构参数则需要改写Caffe脚本，因此我们只需重点关注网络结构参数即可。<br>三种网络结构参数：文中提出了长、宽、高三种网络结构参数，分别对应隐含层数量、状态数以及隐含层与状态层的连接数，并编写了相应的代码生成算法，具体可见文中的Algorithm 1。</p>
</li>
<li><p><strong>模型调优</strong><br>为了求得表现更好的模型参数，作者采用了遗传算法这种启发式算法进行模型调优。<br>染色体结构：\(C=(w,l,h,a_1,a_2,\cdots,a_L,\cdots)\)，直观的理解就是将所有参数结合在了一起。<br>适应度函数：\(fit=accuracy+\frac {1} {1+loss}\)，\(accuracy\)为模型预测精度，\(loss\)为损失率。<br>注：虽然遗传算法最终求得的是局部最优解，但因为参数调优本就是一个非常复杂、难以建模的过程，所以作者认为这样的解已经足够好了。</p>
</li>
</ul>
<h3 id="模型实验-EXPERIMENTS"><a href="#模型实验-EXPERIMENTS" class="headerlink" title="模型实验(EXPERIMENTS)"></a>模型实验(EXPERIMENTS)</h3><p>这一节作者对模型进行了全面的测试和分析，并分别研究几个重要因素对模型的影响。</p>
<ul>
<li><p><strong>评价指标</strong><br>作者采用了预测正确率作为模型主要的评价指标，公式为\(accuracy=\frac {f(S)} {|S|}\)，\(S\)代表训练样本总数，\(f(S)\)代表正确预测的样本数。</p>
</li>
<li><p><strong>batch size的影响</strong><br>在使用默认参数训练模型时，增大batch size可以提高模型精度，但对于内存的消耗也更大。而一个有趣的现象是，使用调优框架后再训练模型，batch size对精度的影响就不再显著了，可见调优框架确实使得模型的表现更为优异了。</p>
</li>
<li><p><strong>FNN的影响</strong><br>由Fig.11、Fig.12可得，FNN的使用显著提升了模型精度，尤其是同时使用调优框架和FNN的模型，精度提升了约10%，而且这还是在模型只推荐1个物品的情况下(即购买概率最大的那个物品)，若模型返回10个物品，模型精度可以达到50%以上。<br>同时，使用FNN并不会影响模型的收敛速率，即模型精度的提升并不会增加计算开销，这也是很重要的一点。</p>
</li>
<li><p><strong>历史状态节点的影响</strong><br>在使用默认参数训练模型时，使用历史状节点态可提高模型10%的精度；而使用了调优框架后，只能提升2%的精度，即调优过程降低了不同网络结构对模型的影响，这也侧面表明了作者所提出调优框架的优异性能。</p>
</li>
<li><p><strong>模型最终效果</strong><br>在DRNN和FNN结合的情况下，模型最终的预测精度达到了33.13%，页面路径压缩到了原先的72.41%，相当于用户从点进网站到最终购买商品，少浏览了30%的页面，效果还是显而易见的，毕竟用户每多浏览一个自己不感兴趣的页面，其离开网站的概率就会越大，这也就是推荐系统的作用所在，即帮助用户更快地进行选择。</p>
</li>
</ul>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><h3 id="关于推荐系统"><a href="#关于推荐系统" class="headerlink" title="关于推荐系统"></a>关于推荐系统</h3><ul>
<li>本文提出了基于RNN和FNN的推荐系统，最主要的原因是传统的CF算法基于用户间购物历史的相似度来做推荐，考虑的更多是用户的购物习惯，这就使其无法把握用户突发的、低频的购买需求。</li>
<li>比如我平常很爱买衣服，网购的大部分物品都是衣服，但有一天突然想吃零食，就会在网站上浏览零食的相关页面，这时系统给我推荐的若还是衣服，就会影响用户体验，也不利于提高网站的销量，因此实时推荐是很有必要的。</li>
<li>但同时，在生活大部分情况中，一个人还是会遵循其所形成的习惯去购物，这时基于购物习惯的推荐便能表现出很好的效果，因此CF算法也是很有必要的。</li>
<li>综上，论文中使用RNN和FNN两种算法共同完成推荐，这种思路是合理的，也是符合我们的直观认知的。</li>
</ul>
<h3 id="关于RNN算法"><a href="#关于RNN算法" class="headerlink" title="关于RNN算法"></a>关于RNN算法</h3><ul>
<li>RNN与其他网络最大的不同在于其隐含层节点的自连接性，在其更新函数中，不仅包括正常的输入值，还包括上一时刻中节点自身的值，这就像使得节点具有了“记忆”，这个记忆表征了时间序列中前后节点的关联，因此RNN适合处理时间序列或状态间具有一定联系的情况。</li>
<li>对应到本文，用户在网站上购物必然会浏览一系列页面，而这些页面是否是有关联的呢？我认为是有的。比如我要买一个钱包，在第一个页面中没有浏览到我喜欢的款式，那我下一个访问的页面也会是关于钱包的，甚至我之后的浏览可能都会围绕钱包来展开，因此我们就可从用户初始的浏览内容来推测其实时的购买兴趣，这也就是作者应用RNN进行实时推荐的原因。</li>
</ul>
<h3 id="关于历史状态节点-history-state"><a href="#关于历史状态节点-history-state" class="headerlink" title="关于历史状态节点(history state)"></a>关于历史状态节点(history state)</h3><ul>
<li>本文的一个创新在于引入了历史状态节点，来解决状态数过多、计算开销过大的问题。根据用户在页面上停留的时间，将多出的历史状态作加权平均，构成一个新的节点，这样既可以保留历史信息，又不会造成计算开销的大量增加，是一种比较折衷的方案。</li>
<li>这也提示我们，在数据量过大的情况下，与其直接将一部分数据丢弃掉，不如将这部分数据做整合，采用加权平均或其他的提取信息的方法，构成新的节点来参与运算，在模型精度和计算开销之间取得平衡。</li>
</ul>
<h3 id="关于训练数据的生成"><a href="#关于训练数据的生成" class="headerlink" title="关于训练数据的生成"></a>关于训练数据的生成</h3><ul>
<li>本文针对用户一次的购买行为，将各种可能的路径优化方案都作为了训练数据送入模型进行训练，这样可以增加我们的训练量。因为对于有监督学习来说，带标签的数据是有限的，如何充分利用有限的标签数据去训练模型需要我们去研究，本文给了我们一种可行的思路。</li>
</ul>
<h3 id="关于模型调优"><a href="#关于模型调优" class="headerlink" title="关于模型调优"></a>关于模型调优</h3><ul>
<li>本文提出了一种模型调优框架，大致可分为“生成参数”和“生成代码”两部分。</li>
<li>首先将模型的相关参数整合成染色体，再利用遗传算法的杂交、变异等操作，生成下一代染色体，之后将参数传入代码生成器中生成对应的Caffe脚本，训练模型后，将结果回带到遗传算法的适应度函数中进行评估和自然选择，一轮轮地迭代，最终即可得出最优的参数组合。</li>
<li>因为建模的复杂性和组合爆炸等问题，模型调优一直是机器学习的一个难点，在这种情况下，利用一些启发式算法进行智能调优不失为一个好的方法，这也是文章给我们的一个启示。</li>
</ul>
<h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><h3 id="关于模型的更新问题"><a href="#关于模型的更新问题" class="headerlink" title="关于模型的更新问题"></a>关于模型的更新问题</h3><ul>
<li>在文章中提到，顾客每完成一次购物，就相当于得到了一个”ground truth”，可以用来训练、调整模型，这样模型随着网站的运行就会不断优化和改进。</li>
<li>如果顾客这次购物是在遵循自己以往的购物习惯，那么将结果用来继续训练模型是没有问题的，因为这个行为在今后还会多次发生，这样可以使得模型更了解顾客的购买习惯，从而更好地完成推荐。</li>
<li>但如果这是一次”unexpected”的购物行为，就像平常都喜欢买衣服的我只是突然想吃点零食，如果模型把这个突发的低频需求当作了用户的购买习惯，在今后也多次向用户进行推荐，可能会造成用户的厌烦。</li>
<li>因此我认为在模型的持续更新中，应该考虑到用户购买行为的属性，即对利用了RNN方式完成的推荐，要降低其对模型的后续影响。</li>
<li>方案实现：可以通过减少训练样本数量的方式，对于通过RNN推荐完成的购买，不要将<br>$$<br>  p_0 \rightarrow I \\<br>  p_0,p_1 \rightarrow I \\<br>  \cdots \\<br>  p_0,\cdots,p_{n-1} \rightarrow I<br>$$<br>所有的路径样本都送入训练，可以只送入后半段或后1/4的样本，让推荐发生的条件更为“苛刻”一些，从而使得模型不会在用户一进入网站就推荐一些低频、不经常需求的产品。</li>
</ul>
<h3 id="将社群属性加入到模型中"><a href="#将社群属性加入到模型中" class="headerlink" title="将社群属性加入到模型中"></a>将社群属性加入到模型中</h3><ul>
<li>论文在”Related Work”中提到CF推荐和基于内容的推荐相结合，会在社交网络上表现得更好，因此我认为可以将这种思路应用到本文，即在推荐系统中加入一定的社群属性。</li>
<li>问题背景：在实际生活中，我们会更倾向于接受来自朋友的推荐，而非来自商家的推荐。尤其是本文的电商网站——网易考拉，是一个主打海淘的平台，用户对一些国外的品牌可能了解并不多，这时如果有来自自己社交圈的推荐，无疑会增加购买的概率。</li>
<li>方案实现：可以考虑改进文中的FNN部分的方法，即首先通过用户填写的基本信息或其他网易系应用中的用户资料(如网易音乐、游戏等)，对用户进行社群判别和分类，为每个用户构建一个“熟人圈”。在进行FNN推荐时，模型不仅推荐历史相似的用户购买的产品，也推荐来自熟人圈购买的产品，以将社群属性加入到推荐模型中。</li>
</ul>
<h3 id="关于推荐理由"><a href="#关于推荐理由" class="headerlink" title="关于推荐理由"></a>关于推荐理由</h3><ul>
<li>问题背景：目前用户对于推荐系统的态度，不仅是想“知其然”，也想“知其所以然”，即除了推荐的物品本身，用户也会想知道系统为什么会给自己推荐这个物品，因此如果能给推荐物品附上推荐理由，无疑会提升网站的用户体验。</li>
<li>方案实现：因为本文是将两种神经网络的输出层共享，以类似加权平均的方式进行融合(见文章第三节D部分)，来计算出用户购买某件物品的概率的，因此可以将最终结果的各个部分分离出来，从大到小排序，通过分析值最大的一项或几项来构造我们的推荐理由。</li>
<li>具体形式：推荐理由的形式可以为“根据你以前购买过的xxx牛仔裤，我们猜你还喜欢这个”、“根据你刚刚浏览过的xxx钱包，我们猜你会喜欢这个”等等，以一种猜测、活泼的口吻对用户进行提示，以增加用户的购买欲望。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/Paper Notes/Notes of Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/" data-id="cjmmeykyr0027d5qxfbcphu86" class="article-share-link" data-share="baidu" data-title="Personal Recommendation Using Deep Recurrent Neural Networks in NetEase读书笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/Paper Notes/Notes of Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper-Notes/">Paper Notes</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深度学习与Tensorflow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/深度学习与Tensorflow/" class="article-date">
  <time datetime="2018-09-13T07:49:58.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/深度学习与Tensorflow/">深度学习与TensorFlow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="深度学习概述"><a href="#深度学习概述" class="headerlink" title="深度学习概述"></a>深度学习概述</h2><h3 id="人工智能AI"><a href="#人工智能AI" class="headerlink" title="人工智能AI"></a>人工智能AI</h3><p>人工智能AI是计算机科学的一个分支，早在20世纪50年代就被提出了，著名的“图灵测试”就是AI发展的终极目标：如果某台机器运行的逻辑程序可以表现出与人类无法分辨的智能，则认为计算机有了思维，能够进行思考。从实用的角度讲，AI的目标是要让计算机自动完成那些需要人类智慧才能完成的工作。</p>
<h3 id="深度学习的起因"><a href="#深度学习的起因" class="headerlink" title="深度学习的起因"></a>深度学习的起因</h3><ul>
<li><p><strong>AI初期：专家系统</strong><br>AI发展初期，主要的思路是将人类总结的知识用一系列规范的、形式化的规则来表示，然后通过自动化的程序来代替人类处理问题，以知识为基础的<strong>专家系统</strong>（Knowledge-based expert system）就是这方面的典型代表。<br>专家系统是将专家的经验写成规则，再依照规则推理的方式来模拟专家的思维。专家系统没有获得太大的成功，原因在于系统会明显受到规则数量的限制，规则是有限的，而问题发生时的状况是无限的，用有限的规则处理无限的可能，注定很容易失败。</p>
</li>
<li><p><strong>专家系统-&gt;机器学习</strong><br>因此，“演绎法”的规则推理暂时行不通，“归纳法”就成了另一条出路，基于概率统计的机器学习（Machine Learning）逐渐成为了主流方法，其直接将大量真实世界产生的数据样本交给算法处理，让算法自己在数据中寻找和学习特定的规律，自己“归纳”知识。这种从数据中学习规律的过程也叫做“模式识别”。</p>
</li>
<li><p><strong>机器学习-&gt;深度学习</strong><br>但这之后机器学习也遇到了一些问题，例如，对于朴素贝叶斯、逻辑回归等经典机器学习算法，本质是计算输入样本和输出目标之间的<strong>隐含规律/相关性</strong>，但计算相关性其实是一个后续问题，在这之前我们首先要确定各个影响因素，而如何表示各个影响因素会严重影响相关性的判断。如要辨别一段语言中演讲者是男人、女人还是小孩，简单机器学习算法的判断依据很可能是音量而非音色和音调。因此设计合适的<strong>特征表示</strong>在机器学习中是一项非常重要的工作，被称为<strong>特征工程</strong>。但长期以来，合适特征的选取都非常困难，不仅费事费力，更需要人们提供大量的先验知识以弥补对数据本身挖掘不足而产生的缺陷。因此若要拓展机器学习的适用范围，必须要降低对特征工程的依赖性。因此也就出现了深度学习。<br>深度学习是一种<strong>表示学习</strong>（Representation Learning）方法，所谓表示学习，就是要让算法在少量人为先验知识的情况下，能够自己从数据中抽取合适的特征。而表示学习目前受到重视的另一个原因是对于人工智能，其目标就是让机器有能力理解我们所在的世界，只有当它学会如何感知和辨别数据背后的各种隐含因素时才能达到这个目标。<br>深度学习最主要的模型是<strong>深度神经网络</strong>，其思想是通过一些列非线性变换操作把从原始数据中提取的简单特征进行组合，从而得到更高层、更抽象的特征表示，这也对应着我们思维理解的过程。如对于文本分析，先认识各个字母，再认识由字母组成的单词，其次是词组、句子、段落，逐渐由简单向抽象映射。一般有<strong>三个</strong>以上隐含层的神经网络就称为深度神经网络。</p>
</li>
<li><p><strong>CPU和GPU</strong><br>促进深度学习的另一个因素是GPU的广泛使用。GPU的主要功能是渲染画面，涉及到坐标变换、栅格化、平面渲染等大量的浮点数计算操作。相比来说，CPU是面向通用计算的产品，GPU则是面向大规模浮点数并行计算的，因此GPU训练计算神经网络的效率会更高。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/深度学习与Tensorflow/" data-id="cjmmeykxu000xd5qxx9y6q6fi" class="article-share-link" data-share="baidu" data-title="深度学习与TensorFlow">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/深度学习与Tensorflow/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MachineLearning/">MachineLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-微机接口技术与应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/微机接口技术与应用/" class="article-date">
  <time datetime="2018-09-13T07:49:58.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/微机接口技术与应用/">微机接口技术与应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

<blockquote>
<p>在微机系统中，微处理器的强大功能必须通过外部设备才能实现，而外设与微处理器之间的信息交换及通信又是靠接口实现的，所以，微机应用系统的研究和微机系统的产品的开发，从硬件角度来讲，就是接口技术的演进和开发。微机的应用随着外设的不断更新早已深入各个领域。</p>
</blockquote>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li><p><strong>CPU架构分类</strong><br>目前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，另一个是以IBM、ARM为首的精简指令集CPU。<br>Intel、AMD的CPU是X86、x64架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构<br>而对于Intelx86架构的CPU，最具代表性的就是1978年所推出的<code>Intel 8086</code>和之后推出的<code>Intel 8088</code>，被称为x86架构的鼻祖。<br>8086：16位处理器芯片，内部总线和外部总线都为16位，本笔记中的接口都是基于<strong>8086架构的</strong>。<br>8088：准16位处理器芯片，内部总线16位，外部总线8位</p>
</li>
<li><p><strong>总线位数</strong><br>内部总线：CPU位数，CPU一次处理的数据总线宽度，通用寄存器长度，ALU运算字长。<br>外部总线：系统总线位数，与内存交换数据的宽度，即数据总线。<br>注：内、外都是相对CPU而言的。<br>三总线：数据总线、地址总线、控制总线。<br>8086中，数据总线16位，地址总线20位，寻址空间<code>2^{20}=1MB</code>。</p>
</li>
<li><p><strong>主板芯片组</strong><br>CPU与周边设备沟通的桥梁，分为南桥和北桥。<br>南桥：PCI桥，CPU与外设的I/O。<br>北桥：HOST桥，离CPU更近，速率更快，用于CPU和内存、显卡、PCI桥交换数据。</p>
</li>
</ul>
<h3 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h3><p>接口指CPU与外设间信息交换的输入输出电路，CPU<->接口<->外设。<br>接口实现了外设与微机间的信息交换。</-></-></p>
<ul>
<li><p><strong>三类接口芯片</strong><br>通用接口芯片：并行接口、串行接口等。<br>面向微机专用接口芯片：不直接与外设连接，只是帮CPU分担工作，DMA控制器、中断控制器等。<br>面向外设专用接口芯片：显示器接口、键盘接口等。</p>
</li>
<li><p><strong>设立接口原因</strong><br>CPU与外设两者的工作速度不兼容<br>CPU与外设两者的信号不兼容<br>有利于外设的标准化</p>
</li>
<li><p><strong>接口电路一般结构</strong><br><img src="/images/接口技术及应用/接口电路一般结构.png" width="340" height="200" alt="接口电路一般结构" align="center"><br>DB, AB, CB即数据总线、地址总线、控制总线。<br>接口内主要有三类寄存器：命令口（CPU向其中写命令，只写）、状态口（CPU从其中读取接口的状态信息，只读）、数据口（CPU与外设间的交换信息，可读可写）。</p>
</li>
<li><p><strong>CPU与接口交换数据方式</strong><br><strong>程序控制方式：</strong>CPU主动。<strong>无条件传送方式</strong>（同步传送），外设一直是准备好的，传送前CPU不需要了解外设的状态，适合一些较简单的外设，如LED显示器；<strong>查询传送方式</strong>（条件传送），传数据前CPU先检测外设状态（状态字），外设没准备好，CPU就一直等待。<br><strong>中断方式：</strong>外设主动，CPU被动。外设做好准备时，主动向CPU发出中断请求，CPU响应中断。<br><strong>DMA方式：</strong>DMA控制外设与存储器间的数据传送，传送过程由特定硬件完成，无需CPU介入。</p>
</li>
</ul>
<h2 id="第二章-I-O端口地址译码技术"><a href="#第二章-I-O端口地址译码技术" class="headerlink" title="第二章 I/O端口地址译码技术"></a>第二章 I/O端口地址译码技术</h2><h3 id="端口地址"><a href="#端口地址" class="headerlink" title="端口地址"></a>端口地址</h3><p>I/O端口(Port)：指I/O接口电路中能被CPU直接访问的<strong>寄存器</strong>，CPU与外设间不能直接交换信息，必须通过端口。</p>
<ul>
<li><p><strong>端口编址方式</strong><br>采用小端模式，低字节在低地址，高字节在高地址。<br><strong>统一编址：</strong>端口地址和存储器地址是统一的，可直接用内存指令访问端口，无需专门的I/O指令。因此指令会比较长，且寻址速度慢。<br><strong>独立编址：</strong>端口地址和存储器地址独立，根据不同指令访问不同的地址（通过专门的I/O指令访问端口），<strong>8086中就是这种方式</strong>。</p>
</li>
<li><p><strong>8086中端口地址分配</strong><br>地址空间：<code>000-3FFH</code>，A0-A9共10根地址线，可访问1024个端口。<code>3FFH=15+15*16+3*16*16=1023</code>。<br>系统板上的I/O接口芯片：地址<code>000-0FFH</code>，单字节地址。较为简单的接口，定时器、中断控制器等。<br>扩展槽上的I/O接口卡：地址<code>100-3FFH</code>，双字节地址。若干个集成电路合在一起，较为复杂，显卡、声卡、网卡等。</p>
</li>
<li><p><strong>端口地址译码方式</strong><br>三种译码方式：全译码、部分译码和地址开关译码。<br><strong>全译码：</strong>所有I/O地址线A0~A9全部作为译码的输入参与译码。<br><strong>部分译码：</strong>将地址线分为两部分：<code>端口地址=芯片地址（高位）+片内地址（低位）</code>，只有高位地址线参加译码，可分为片间寻址与片内端口寻址。<strong>片间寻址：</strong>高位地址信号与控制信号组合，经译码电路产生接口的片选信号\(\small \overline{CS}\)。控制信号如：读信号\(\small \overline{IOR}\)、写信号\(\small \overline{IOW}\)等。<strong>片内端口寻址：</strong>低位地址信号不参加译码，直接连到接口芯片中，进行端口寻址。<br><img src="/images/接口技术及应用/部分译码.png" width="230" height="140" alt="部分译码示意图" align="center"><br><strong>地址开关译码：</strong>在部分译码方法的基础上，加上地址开关来改变端口地址。</p>
</li>
<li><p><strong>地址译码电路设计</strong><br><strong>固定式译码：</strong>接口中用到的端口地址不能更改，分为门电路译码和译码器译码。<strong>门电路译码：</strong>对单一端口地址进行译码，使用与门、与非门等各种门电路；<strong>译码器译码：</strong>对多个端口地址译码，使用各种译码器元件。<br><strong>可选式译码：</strong>采用开关式端口地址译码。通过开关改变接口卡的端口地址（无需改动线路）。如果要求端口地址能适应不同的地址分配场合，或为系统以后扩充留有余地，则采用开关式端口地址译码，电路可由地址开关、译码器、比较器或异或门几种元器件组合而成。<br>地址译码电路设计原则如下：<br><img src="/images/接口技术及应用/地址译码电路设计原则.png" width="545" height="265" alt="地址译码电路设计原则" align="center"></p>
</li>
</ul>
<h3 id="接口I-O指令"><a href="#接口I-O指令" class="headerlink" title="接口I/O指令"></a>接口I/O指令</h3><p>8086中通过AL寄存器与外设交换信息。</p>
<ul>
<li><strong>端口为单字节地址：</strong>可直接使用地址。<br><code>in AL, 60H</code>：将60H端口中的8位数据-&gt;AL；<br><code>out 61H, AL</code>：将AL中数据-&gt;61H端口。</li>
<li><strong>端口为双字节地址：</strong>不能直接使用地址，通过DX寄存器承接。<br><code>mov DX,300H  in AL,DX</code>：将300H端口中的8位数据-&gt;AL（地址为16位，数据还是8位）。<br><code>mov DX,301H  out DX,AL</code>：将AL中数据-&gt;301H端口。<br>注：in/out都是相对CPU而言的。</li>
</ul>
<h2 id="第三章-定时-计数技术"><a href="#第三章-定时-计数技术" class="headerlink" title="第三章 定时/计数技术"></a>第三章 定时/计数技术</h2><ul>
<li><strong>什么是定时与计数</strong><br>定时：确定时间间隔。<br>计数：统计个数。<br>在计算中定时就是对时钟脉冲(CLK)进行计数，定时和计数本质是一样的。</li>
</ul>
<h3 id="定时计数接口82C54"><a href="#定时计数接口82C54" class="headerlink" title="定时计数接口82C54"></a>定时计数接口82C54</h3><ul>
<li><p><strong>可编程定时计数器</strong><br><img src="/images/接口技术及应用/可编程定时计数器.png" width="300" height="210" alt="可编程定时计数器内部结构图" align="center/"><br><strong>初值寄存器CR：</strong>设定计数初值<br><strong>计数执行单元CE：</strong>执行计数操作，CPU不能访问<br><strong>计数输出锁存器OL：</strong>CPU从中读取当前计数值<br><strong>控制寄存器：</strong>决定82C54工作方式<br><strong>CLK：</strong>CPU时钟信号信号<br><strong>GATE：</strong>门控信号，控制83C54是否工作<br><strong>OUT：</strong>输出端<br>注：寄存器都是<strong>16位</strong>的，但因为数据线只有8位，所以一次只能读写8位数据。<br><strong>工作原理：</strong><br>对CLK信号进行减1计数<br>1、将控制字写入控制寄存器，确定82C54工作方式<br>2、将计数初始值写入初值寄存器。<br>3、从计数初值开始，在GATE控制下，每当CLK信号出现一次，计数值减1。<br>4、当计数值减到0，从OUT端输出规定的信号。<br>注：CLK信号出现时，计数器是否减1，由门控信号GATE控制</p>
</li>
<li><p><strong>定时计数接口82C54</strong><br>82C54具有三个独立的16位计数器（0#~2#通道），每个通道就是一个独立的可编程定时计数器。<br>每个通道有6种工作方式；<br>可以进行二进制或十进制计数，计数方式为减1计数。<br>注：82C54、8254、8253都是一个意思</p>
</li>
<li><p><strong>82C54内部结构</strong><br><img src="/images/接口技术及应用/定时计数接口82C54.png" width="310" height="200" alt="82C54内部结构图" align="center/"></p>
<ul>
<li><strong>数据总线缓冲器：</strong><br>8位，双向，用于暂存数据。<br>1、初始化时向其写入控制字；<br>2、向某一通道写入计数初值；<br>3、从某一通道读当前计数初值。</li>
<li><strong>控制逻辑：</strong><br>接收CPU发来的RD、WR、CS、A1、A0信号，经过逻辑控制电路产生出对82C54要执行的操作。 </li>
<li><strong>控制字寄存器：</strong><br>接收8位的方式命令字（控制字）</li>
</ul>
</li>
<li><p><strong>82C54外部引脚</strong><br><img src="/images/接口技术及应用/82C54外部引脚.png" width="460" height="190" alt="82C54外部引脚" align="center/"><br>\(\small \rm \textbf{D0}\cdots \textbf{D7}\)：双向，8位数据线<br>\(\small \rm \overline{\textbf{WR}}\)：输入，写信号<br>\(\small \rm \overline{\textbf{RD}}\)：输入，读信号<br>\(\small \rm \overline{\textbf{CS}}\)：输入，接口片选信号<br>\(\small \rm \textbf{A0 A1}\)：输入，片内地址选择<br><code>00</code>：通道0<br><code>01</code>：通道1<br><code>10</code>：通道2<br><code>11</code>：方式命令字<br>\(\small \rm \textbf{OUT}\)：输出信号</p>
</li>
</ul>
<h3 id="82C54初始化编程"><a href="#82C54初始化编程" class="headerlink" title="82C54初始化编程"></a>82C54初始化编程</h3><ul>
<li><p><strong>方式命令字格式</strong><br><img src="/images/接口技术及应用/82C54方式命令字.png" width="500" height="60" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">D7 D6：控制字是针对哪个计数器的</span><br><span class="line">    00：计数器0</span><br><span class="line">    01：计数器1</span><br><span class="line">    10：计数器2</span><br><span class="line">    11：非法。</span><br><span class="line">D5 D4：设置读写格式，由计数初值的位数决定，8位-01，16位-11。</span><br><span class="line">    00：计数器锁存命令</span><br><span class="line">    01：只读写低字节</span><br><span class="line">    10：只读写高字节</span><br><span class="line">    11：先读写低字节，后读写高字节。</span><br><span class="line">D3 D2 D1：指定82C54的工作模式</span><br><span class="line">    000：方式0</span><br><span class="line">    ...</span><br><span class="line">    101：方式5。</span><br><span class="line">D0：指定计数模式</span><br><span class="line">    0：二进制</span><br><span class="line">    1：十进制，即BCD码，将每个十进制位转化为4位二进制，求和还是按十进制来算。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编程流程</strong><br><strong>原则: 先写方式命令字、再写计数初值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;端口地址为60H~63H，选择1#，工作方式2，计数初值33H，BCD码制。初始化程序段为：</span><br><span class="line">MOV AL,01010101B     ;写入方式命令字</span><br><span class="line">OUT 63H,AL           ;片内地址为11</span><br><span class="line">MOV AL,33H           ;写入计数初值</span><br><span class="line">OUT 61H,AL           ;片内地址为01（使用1号通道）</span><br><span class="line"></span><br><span class="line">;若计数初值为5533H，其他不变，则程序段为：</span><br><span class="line">MOV AL,01110101B   ;写入控制命令字</span><br><span class="line">OUT 63H,AL         </span><br><span class="line">MOV AL,33H         ;写入计数初值低字节</span><br><span class="line">OUT 61H,AL         </span><br><span class="line">MOV AL,55H         ;写入计数初值高字节</span><br><span class="line">OUT 61H,AL</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="82C54六种工作方式"><a href="#82C54六种工作方式" class="headerlink" title="82C54六种工作方式"></a>82C54六种工作方式</h3><p>方式0：计数结束产生中断<br>方式1：可重复编程的单脉冲<br>方式2：分频器<br>方式3：方波发生器<br>方式4：软件触发的选通信号发生器<br>方式5：硬件触发的选通信号发生器<br><strong>重点是方式2和方式3</strong><br><img src="/images/接口技术及应用/82C54工作方式.png" width="315" height="125" align="center/"></p>
<ul>
<li><p><strong>6种方式不同之处</strong><br>启动计数的触发方式不同。<br>门控信号GATE对计数操作控制不同。<br>是否有初值重装功能。<br>OUT引脚输出波形不同</p>
</li>
<li><p><strong>方式0（计数结束产生中断）</strong><br><img src="/images/接口技术及应用/82C54方式0.png" width="310" height="160" align="center/"><br><strong>触发方式：</strong>软启动。写入控制字后，立即启动，OUT-&gt;低电平，但写入初值后才开始计数。<br>注：写入初值后要等下一个clk才开始计数，一低一高算一个clk。<br><strong>GATE信号：</strong>高电平时计数，低电平时暂停计数。<br><strong>初值重装：</strong>不具有<br><strong>OUT波形：</strong>只计数一次，计数时为低电平，计数结束输出持续的高电平，在写入初值\((n+1)\cdot T_{clk}\)时间后发生0到1跳变。</p>
</li>
<li><p><strong>方式1（可重复编程的单脉冲）</strong><br><img src="/images/接口技术及应用/82C54方式1.png" width="310" height="160" align="center/"><br><strong>触发方式：</strong>硬件启动，写入控制字后，OUT-&gt;高电平；检测到GATE上升沿，OUT-&gt;低电平，开始计数。<br><strong>GATE信号：</strong>可重复触发计数，检测到GATE上升后就重新计数。<br><strong>初值重装：</strong>不具有。<br><strong>OUT波形：</strong>宽度为\(n\cdot T_{clk}\)的负脉冲。<br><strong>用途：</strong>单脉冲发生器，宽度由程序设置的n决定。 </p>
</li>
<li><p><strong>方式2 周期性负脉冲输出（分频器）</strong><br><img src="/images/接口技术及应用/82C54方式2.png" width="350" height="165" align="center/"><br><strong>触发方式：</strong>写入控制字后，OUT-&gt;高电平，但写入初值后才开始计数。<br><strong>GATE信号：</strong>高电平时计数，低电平时暂停计数。<br><strong>初值重装：具有</strong>，在计数过程中若重新写入计数初值，对正在进行的计数过程没有影响，但在计到1输出一个CLK宽度的负脉冲后，计数器将按新的计数初值开始计数。<br><img src="/images/接口技术及应用/82C54方式2初值重装.png" width="360" height="90" align="center/"><br><strong>OUT波形：</strong>产生连续的负脉冲，宽度为\(T_{clk}\)，周期为\(n\cdot T_{clk}\)。<br><strong>用途：</strong>分频器，放大\(T_{clk} \rightarrow n\cdot T_{clk}\)，可用来提供周期性脉冲信号/时终信号。<br>注：分频器意思是高频-&gt;低频就行，波形不一定要相同。</p>
</li>
<li><p><strong>方式3 方波发生器</strong><br><img src="/images/接口技术及应用/82C54方式3.png" width="350" height="165" align="center/"><br>（和方式2类似，只不过输出的是方波）<br><strong>触发方式：</strong>写入控制字后，OUT-&gt;高电平，但写入初值后才开始计数。<br><strong>GATE信号：</strong>高电平时计数，低电平时暂停计数。<br><strong>初值重装：具有</strong>，和方式2原理一样。<br><strong>OUT波形：</strong>产生连续的负脉冲，宽度为\(\frac {n} {2}\cdot T_{clk}\)，周期为\(n\cdot T_{clk}\)。<br>注：当n是奇数时，输出不对称方波，前\(\frac {n+1} {2}\)个计数期间，OUT输出高电平；后\(\frac {n-1} {2}\)个计数期间，OUT输出低电平。<br><strong>用途：</strong>方波发生器，也可分频。</p>
</li>
</ul>
<h2 id="第四章-并行接口"><a href="#第四章-并行接口" class="headerlink" title="第四章 并行接口"></a>第四章 并行接口</h2><p>串/并接口指<strong>接口和外设</strong>间的连线是单根还是多根，接口和CPU间肯定是多根线。</p>
<ul>
<li><strong>并行接口特点</strong><br>通过多根信号线同时传送多位数据，且传送时一般不需要特定的数据传送格式；<br>并行接口多用于距离短，数据量大，速率高的实时传输场合；<br>并行接口布线成本高，且有线路间互相干扰、时钟同步等问题，因此并行传输技术发展受限。<br>常用并行接口：<br><img src="/images/接口技术及应用/常见并行接口.png" width="390" height="175" alt="常见并行接口" align="center/"></li>
</ul>
<h3 id="可编程并行接口8255"><a href="#可编程并行接口8255" class="headerlink" title="可编程并行接口8255"></a>可编程并行接口8255</h3><p>上一章介绍的82C54属于非通道接口，其主要功能为驱动外设，而非在CPU和外设间传数据；<br>本章介绍的8255是通道接口，主要功能就是在CPU和外设间传数据。</p>
<ul>
<li><p><strong>8255特点</strong><br>有三个输入输出端口：端口A，端口B，端口C。<br>每个端口可编程设定为输入端口或输出端口，并可设定不同的工作方式。<br>端口C可作为一个独立的端口使用，但常常是配合A口和B口工作，为A、B端口的提供联络信号。</p>
</li>
<li><p><strong>8255的内部结构</strong><br><img src="/images/接口技术及应用/8255内部结构.png" width="400" height="300" alt="8255内部结构" align="center/"><br>三个并行输入输出端口（A口、B口、C口）分为两组进行控制，分别对应一个控制寄存器：<br>A组：A口、C口高4位<br>B组：B口、C口低4位</p>
</li>
<li><p><strong>8255的外部引脚</strong><br><img src="/images/接口技术及应用/8255外部引脚.png" width="460" height="185" alt="8255外部引脚" align="center/"><br><strong>片选地址A1 A0：</strong><br><code>00</code>：A端口<br><code>01</code>：B端口<br><code>10</code>：C端口<br><code>11</code>：方式命令字</p>
</li>
</ul>
<h3 id="8255初始化编程"><a href="#8255初始化编程" class="headerlink" title="8255初始化编程"></a>8255初始化编程</h3><p>8255A有两个控制字（方式命令字，C口按位复位/置位命令字）和一个状态字，设置方法也不同。</p>
<ul>
<li><p><strong>方式命令字</strong><br><img src="/images/接口技术及应用/8255方式命令字.png" width="510" height="210" alt="8255方式命令字" align="center/"><br>D7：<code>1</code>时表示方式命令字，<code>0</code>时表示C口按位复位/置位命令字<br>其余位按A、B组分为两组，进行不同的控制。</p>
</li>
<li><p><strong>C口按位复位/置位命令字</strong><br>在方式1和方式2时要用到这个控制字，对C口的某一位置1/0，输出正/负脉冲。<br>此控制字只对C口有效。<br>它被写入控制口，不是写入C口。<br><img src="/images/接口技术及应用/8255C口按位复位置位命令字.png" width="490" height="250" alt="8255C口按位复位置位命令字" align="center/"></p>
</li>
<li><p><strong>编程流程</strong><br>和82C54编程原则相同：先写控制字，再写数据值。</p>
</li>
</ul>
<h3 id="8255工作方式"><a href="#8255工作方式" class="headerlink" title="8255工作方式"></a>8255工作方式</h3><p>8255有3种工作方式：方式0，方式1和方式2，<br>方式0：无条件传送（外设始终做好了准备）<br>方式1：单向应答式传送（查询、中断）<br>方式2：双向应答式传送（查询、中断）<br><strong>重要是方式0和方式1</strong></p>
<p>8255三个端口对工作方式的使用情况不同。<br>A端口：可使用3种方式的任一种；<br>B端口：只能使用方式0和方式1；<br>C瑞口：一般作为控制信号使用，配合A端口和B端口的工作。</p>
<ul>
<li><p><strong>方式0</strong><br>最简单的连接方式，直接读写数据即可。<br>2个8位的端口和2个4位的端口，都可以作为输入或输出。<br>单向I/0，端口只能做输入或输出一项功能。<br>系统没有指定C口的某些线作为专门的信号联络线和状态位，但是用户可以自定义C口的某些线作为信号联络线。<br>端口信号线之间无固定的时序关系，由用户根据数据传送的要求决定输入输出的操作过程。不需要任何选通信号。</p>
</li>
<li><p><strong>方式1（输入过程）</strong><br><img src="/images/接口技术及应用/8255方式1输入过程.png" width="435" height="67" alt="方式1输入过程示意图" align="center/"><br><strong>各信号意义：</strong><br>\(\small \rm \overline{STB}\)：选通信号，表示外设已经准备好数据。<br>IBF：输入缓冲器满信号，表示端口已经接收数据完毕。<br>INTR：中断请求信号，请求CPU接收数据。<br>\(\small \rm \overline{RD}\)：读数据信号，有效代表CPU在读取数据。在外设向CPU发出INTR信号后，什么时候CPU响应了中断，\(\small \rm \overline{RD}\)即变为有效。<br><img src="/images/接口技术及应用/8255方式1信号时序图(输入).png" width="433" height="180" alt="信号时序图（输入）" align="center/"></p>
</li>
<li><p><strong>方式1（输出过程）</strong><br><img src="/images/接口技术及应用/8255方式1输出过程.png" width="435" height="67" alt="方式1输出过程示意图" align="center/"><br><strong>各信号意义：</strong><br>INTR：中断请求信号，接口向CPU发出中断。<br>\(\small \rm \overline{WR}\)：写信号，表示CPU向接口在写数据。<br>\(\small \rm \overline{OBF}\)：输出缓冲器满信号，表示外设可以从接口中取数据了 。<br>\(\small \rm \overline{ACK}\)：外设应答信号，\(\small \rm \overline{ACK}=0\)其实是一个负脉冲，表示外设已接收完数据，可以再发下一个数据，因此马上会回到高电平。<br><img src="/images/接口技术及应用/8255方式1信号时序图(输出).png" width="433" height="180" alt="信号时序图（输出）" align="center/"><br>CPU响应中断以后，向8255输出数据，写信号出现；写信号撤消，其上升沿一方面撤消中断请求信号INTR，另一方面使\(\small \rm \overline{OBF}\)信号变为有效的低电平，通知外设可以接收数据。<br>当外设接收完数据后，便发出一个\(\small \rm \overline{ACK}\)信号，同时使\(\small \rm \overline{OBF}\)变为无效，表示数据已经取走，当前缓冲器空。\(\small \rm \overline{ACK}\)信号结束时使INTR信号变为有效的高电平，向CPU发出中断请求信号，从而开始新的数据输出过程。</p>
</li>
<li><p><strong>方式1下的C口状态字</strong><br><img src="/images/接口技术及应用/8255方式1C口状态字.png" width="457" height="225" alt="8255方式1 C口状态字" align="center/"><br><strong>INTE：</strong>中断使能状态，表示是否允许端口发出INTR信号。初始化时通过C口按位复位/置位命令字来设定，设定后，就会在状态字中反映出来。<br><strong>PC0-PC7：</strong>指C口的对应位，为A口和B口的提供辅助信号。A组：8位数据口+5位控制口(PC3-PC7)，B组：8位数据口+3位控制口(PC0-PC2)。<br><strong>状态字作用：</strong><br>状态字主要为查询方式提供了状态标志位，方式1下，CPU读取的C口某几位内容，主要有：\(\small \rm \overline{OBF}\)、IBF、INTE、INTR，来判断下一步应该进行的操作。<br>注1：A口、B口都有相应的状态字，实质是相互独立的两个数据口。<br>注2：\(\small \rm \overline{STB}\)、\(\small \rm \overline{ACK}\)线的状态不能读取，因为是来自外设的信号，所以状态字中没有，CPU也不需要知道。<br>注3：端口C状态字寄存器的值和对应的引脚信号不一定一样。如输入状态下，PC4寄存器值表示INTE，而引脚则接\(\small \rm \overline{STB}\)信号。因为INTE是在初始化时设置的，而\(\small \rm \overline{STB}\)信号又不写到寄存器中，所以两者并不冲突，这样可以提升端口利用率。</p>
</li>
</ul>
<h2 id="第五章-中断技术"><a href="#第五章-中断技术" class="headerlink" title="第五章 中断技术"></a>第五章 中断技术</h2><h3 id="中断的基本概念"><a href="#中断的基本概念" class="headerlink" title="中断的基本概念"></a>中断的基本概念</h3><p>中断的本质是程序转移：CPU响应中断请求，暂停现行的主程序，转去执行中断服务子程序，完成中断事件处理后，返回断点继续执行主程序的过程。</p>
<ul>
<li><p><strong>中断的分类</strong><br><img src="/images/接口技术及应用/中断分类.png" width="475" height="207" alt="中断分类" align="center/"><br>中断的内、外是针对CPU而言的，外部中断即来自CPU外部的中断。</p>
</li>
<li><p><strong>外部可屏蔽中断的一般流程</strong><br>1、中断请求：INTR，请求信号应保持到本次中断被响应<br>2、中断识别及判优：通过类型号区分不同中断源，通过优先级进行中断判优<br>3、中断响应：保护现场等操作（硬件完成）<br>4、中断处理：执行中断服务子程序<br>5、中断返回：恢复现场等操作（硬件完成）</p>
</li>
<li><p><strong>中断向量与中断向量表</strong><br><strong>中断类型号：</strong>8086微处理器支持256种中断，编号为0~255号。<br><strong>中断向量：</strong>中断服务程序的入口地址，CS:IP的形式存储，占4个字节的地址。<br><strong>中断向量表：</strong>系统中所有的中断向量集中起来放到存储器的某一区域内，即为中断向量表。在内存中用000~3FFH共1024(4*256)个地址作为中断向量表存储区。<br><strong>由中断号计算中断服务程序地址：</strong>先计算中断向量的地址(4*中断号)，再取出中断服务程序的地址。总共四个字节，低2字节为IP，高2字节为CS，都是小端存储。<br>eg：计算中断类型号为4AH的中断服务程序入口地址<br><img src="/images/接口技术及应用/计算中断入口地址eg.png" width="340" height="270" align="center/"></p>
</li>
</ul>
<h3 id="可编程中断控制器8259A"><a href="#可编程中断控制器8259A" class="headerlink" title="可编程中断控制器8259A"></a>可编程中断控制器8259A</h3><p><strong>作用：</strong>接收外设传来的中断，进行中断识别和判优，并将应该响应中断的中断号传给CPU。只传中断号，并不执行中断。<br>8259A只是帮助系统管理外部可屏蔽中断，外部不可屏蔽中断及内部中断CPU自己处理。<br>8259A具有8级优先权控制，通过级连可扩展至64级优先权控制。</p>
<ul>
<li><p><strong>8259A内部结构</strong><br><img src="/images/接口技术及应用/8259A内部结构.png" width="370" height="270" alt="8259A内部结构图" align="center/"><br><strong>中断请求寄存器(IRR)：</strong>该寄存器8位(D0～D7)对应于IR0~IR7线上传来的中断请求，哪一根输入线有请求，哪位就置“1”，中断被响应后对应位就置0。<br><strong>中断屏蔽寄存器(IMR)：</strong>寄存器8位(D0～D7)对应8级中断屏蔽，IR0~IR7哪一个中断被屏蔽，哪位就写1。<br><strong>优先权分析器(PR)：</strong>PR将当前中断请求的优先级和“正在服务中的中断”进行比较，决定是否让这个中断请求送给处理器（低优先级就不送了）。<br><strong>ISR寄存器：</strong>寄存了正在服务的\(\small \rm IR_{i}\)中断源和被挂起的中断源，可根据优先级规则判断哪个中断源正在被服务。<br><strong>被挂起的含义：</strong>低优先级中断先响应了，之后来了高优先级中断，就挂起去执行高优先级（若高优先级先响应，低优先级压根就不会送到ISR）。<br>如下图：若IR0中断优先级最高，IR7优先级最低，则当前被服务的是IR0，被挂起的是IR2和IR6。<br><img src="/images/接口技术及应用/8259A_ISR寄存器.png" width="330" height="50" alt="8259A ISR寄存器" align="center/"><br><strong>级联缓冲/比较器（CAS0~CAS2）：</strong>主控和从控芯片的CAS0~CAS2相互连接，进行级联；从控的INT引脚接到主控的IR上，传递中断号。<br><strong>如何区分主控和从控：</strong>SP/EN引脚接高电平为主控，接低电平为从控。</p>
</li>
<li><p><strong>8259A外部引脚</strong><br><img src="/images/接口技术及应用/8259A外部引脚.png" width="430" height="280" alt="8259A外部引脚" align="center/"></p>
</li>
<li><p><strong>8259A中断响应过程</strong><br>1、IRQ0~IRQ7有中断请求，IRR的相应位置1<br>2、IRR与IMR相应位进行比较，封锁或发送中断请求给PR<br>3、PR分析后，把当前最高优先级的中断请求由INT送至CPU<br>4、若IF=1，CPU执行完当前指令后，连续发出2个\(\small \rm \overline{INTA}\)信号（IF=1表示开中断）<br><strong>5、</strong>接到第1个\(\small \rm \overline{INTA}\)后，ISR对应位置1，IRR对应位清0<br><strong>6、</strong>接到第2个\(\small \rm \overline{INTA}\)后，8259A把中断类型号送上数据总线<br>7、CPU根据收到的中断类型号，到中断向量表中取中断向量，执行中断子程序。</p>
</li>
</ul>
<h3 id="8259A工作方式"><a href="#8259A工作方式" class="headerlink" title="8259A工作方式"></a>8259A工作方式</h3><p><img src="/images/接口技术及应用/8259A工作方式.png" width="508" height="293" align="center/"><br>因为其他部分都不太重要，因此接下来重点介绍<strong>优先级排队方式</strong>。</p>
<ul>
<li><p><strong>普通完全嵌套方式</strong><br>在该方式下，IR7～IR0的优先级顺序是IR0最高，IR7最低。且一个中断被响应，只有比它更高优先级的中断请求才会被响应。</p>
</li>
<li><p><strong>特殊嵌套方式</strong><br>该方式一般用于8259A的<strong>级联方式</strong><br>与全嵌套方式基本相同，不同之处在于特殊嵌套不但响应比本级高的中断申请，而且响应同级的中断申请。<br>如果当前正在执行的中断是由从片传来的，这是从片上更高级别的中断提出请求，从片会予以响应，向主片发INT信号，但主片分不出来，只将它们视为同一级别。<br>若普通全嵌套方式，则主片不会响应，只有特殊全嵌套方式，主片才会响应。因此级联时主片必须采取特殊嵌套方式。</p>
</li>
<li><p><strong>优先级循环方式</strong><br>指当某个中断源受到中断服务后，它的优先权就自动降为最低，而优先级较其低一级的升为最高。<br>例如，IR4被服务后，相应的IR5的优先级升为最高，依次为IR6，IR7，IR0，IR1，IR2，IR3，IR4。<br>根据初始优先级的不同又分为两种方式：<br><strong>普通循环方式：</strong>默认初始优先级最高为IR0，最低为IR7。<br><strong>特殊循环方式：</strong>用户自己决定初始优先级，如规定IR5最低，则相应的最高优先级为IR6，依次为IR7，IR0，IR1，IR2，IR3，IR4，IR5。</p>
</li>
</ul>
<h3 id="8259A初始化命令字"><a href="#8259A初始化命令字" class="headerlink" title="8259A初始化命令字"></a>8259A初始化命令字</h3><p>8259A有4个初始化命令字ICW1~ICW4，在接口使用前进行设置。<br>初始化命令字必须按ICW1~ICW4的顺序写入，中间不能被打断（关中断）。且ICW1、ICW2是必须写的，ICW3、ICW4需不需要写视工作方式而定。<br><strong>写入地址：</strong>ICW1要写到<strong>偶地址（A0=0）</strong>，ICW2~ICW4写到<strong>奇地址（A0=1）</strong>。</p>
<ul>
<li><p><strong>ICW1（芯片控制命令字）</strong><br><img src="/images/接口技术及应用/8259A_ICW1.png" width="420" height="50" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D7 D6 D5：可任意设置，建议设为0</span><br><span class="line">D4：标志位，只能设为1</span><br><span class="line">D3：设置中断触发方式</span><br><span class="line">    1：电平触发方式</span><br><span class="line">    0：边沿触发方式 </span><br><span class="line">D2：任意设置，建议为0</span><br><span class="line">D1：规定单片还是级连方式</span><br><span class="line">    1：单片方式</span><br><span class="line">    0：级连方式</span><br><span class="line">D0：是否写入ICW4</span><br><span class="line">    1：要写入ICW4</span><br><span class="line">    0：不写入ICW4</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ICW2（中断类型号命令字）</strong><br><img src="/images/接口技术及应用/8259A_ICW2.png" width="420" height="50" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D7~D3：设置中断向量号的高5位，手动设置。</span><br><span class="line">D2~D0：中断向量号的低3位，8259A会自动确定。</span><br><span class="line">IR0为000、IR1为001...IR7为111</span><br><span class="line">写的时候只用写D7~D3即可，D2~D0自动设为0。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最终中断号=ICW2的高5位+\(\small \rm IR_{i}\)组合而成。</p>
<ul>
<li><p><strong>ICW3（级联控制命令字）</strong><br><img src="/images/接口技术及应用/8259A_ICW3.png" width="485" height="85" align="center/"><br>ICW3是级联时才需写入的控制字，且对于主、从片的意义不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对于主片：Di=1表示IRi接有从片，否则IRi没有接从片。</span><br><span class="line">对于从片：D2~D0表明从片的INT引脚接到主片的哪个IR引脚。</span><br><span class="line"></span><br><span class="line">例：主控8259第IR3、IR6上联了从控。</span><br><span class="line">主控：ICW3=01001000B，</span><br><span class="line">从控A：ICW3=00000011B，</span><br><span class="line">从控B：ICW3=00000110B。</span><br><span class="line"></span><br><span class="line">如何区分主控和从控：SP/EN接高电平为主控，接低电平为从控。</span><br><span class="line">主控和从控的CAS0~CAS2相互连接，进行级联；从控的INT引脚接到主控的IR上，传递中断号。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ICW4（方式命令控制字）</strong><br><img src="/images/接口技术及应用/8259A_ICW4.png" width="485" height="85" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D7 D6 D5：直接设0</span><br><span class="line">D4：设置嵌套方式</span><br><span class="line">    1：特殊嵌套方式</span><br><span class="line">    0：普通完全嵌套方式</span><br><span class="line">D3：数据线的缓冲方式</span><br><span class="line">    1：缓冲方式</span><br><span class="line">    0：非缓冲方式 </span><br><span class="line">D2：主片/从片选择</span><br><span class="line">    1：主片</span><br><span class="line">    0：从片</span><br><span class="line">D1：中断结束方式</span><br><span class="line">    1：自动中断结束</span><br><span class="line">    0：非自动中断结束</span><br><span class="line">D0：微处理器类型</span><br><span class="line">    1：16位80x86</span><br><span class="line">    0：8位8080/8085</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>8259A初始化流程</strong><br><img src="/images/接口技术及应用/8259A初始化流程.png" width="220" height="300" alt="8259A初始化流程" align="center/"></p>
</li>
</ul>
<h3 id="8259A操作命令字"><a href="#8259A操作命令字" class="headerlink" title="8259A操作命令字"></a>8259A操作命令字</h3><p>8259A有3个操作命令字OCW1~OCW3，负责对8259A的工作状态进行设置。<br>在8259A工作期间，可以随时接受操作命令字，且对写入顺序没有要求，需要哪个OCW就写入那个OCW。<br><strong>写入地址：</strong>OCW1写到<strong>奇地址（A0=1）</strong>，OCW2、OCW3写到<strong>偶地址（A0=0）</strong></p>
<ul>
<li><p><strong>OCW1（屏蔽命令字）</strong><br><img src="/images/接口技术及应用/8259A_OCW1.png" width="485" height="85" align="center/"><br>内容写入中断屏蔽寄存器IMR，\(\small \rm D_i\)对应\(\small \rm IR_i\)<br><code>1</code>：禁止\(\small \rm IR_i\)中断<br><code>0</code>：允许\(\small \rm IR_i\)中断</p>
</li>
<li><p><strong>OCW2</strong><br><img src="/images/接口技术及应用/8259A_OCW2.png" width="410" height="300" align="center/"><br>OCW2用于设置优先级循环方式和中断结束方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D7 D6 D5：组合为设置编码</span><br><span class="line">D7：是否允许优先权循环</span><br><span class="line">D6：设置优先级方式</span><br><span class="line">    1：循环优先级（按D2~D0决定哪个引脚优先级最低）</span><br><span class="line">    0：固定优先级（IR7最低，IR0最高）</span><br><span class="line">D5：是否允许EOI，EOI：结束中断，结束D2~D0对应引脚的中断</span><br><span class="line">    1：允许</span><br><span class="line">    0：不允许</span><br><span class="line">D2 D1 D0：指定优先级循环时，初始的最低优先级的引脚</span><br><span class="line"></span><br><span class="line">eg：D2~D0为101，表明指定初始时最低优先级为IR5，则最高优先级为IR6。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>OCW3</strong><br><img src="/images/接口技术及应用/8259A_OCW3.png" width="375" height="160" align="center/"><br>OCW3用于设置和撤消特殊屏蔽方式、设置中断查询方式以及发出对8259A内部寄存器的读出命令。</p>
</li>
<li><p><strong>如何区分初始化命令字和方式命令字</strong><br>8259A只有两个端口用来写命令字（一个奇地址一个偶地址），如何区分写到地址中的命令字？<br><strong>对于奇地址：</strong>ICW1、OCW2、OCW3都写到奇地址，通过命令字的<code>D4 D3</code>两位来区分。<br><strong>对于偶地址：</strong>ICW2~4、OCW1都写到偶地址，通过写入顺序来区分，系统规定只能按<code>ICW2-&gt;ICW3-&gt;ICW4-&gt;OCW1</code>的顺序写入。</p>
</li>
</ul>
<h2 id="第六章-A-D、D-A转换器接口"><a href="#第六章-A-D、D-A转换器接口" class="headerlink" title="第六章 A/D、D/A转换器接口"></a>第六章 A/D、D/A转换器接口</h2><p>在实际工业生产环境，都是连续变化的模拟量 ，如：压力、温度、流量等；<br>而在计算机内部，则都是离散的数字量，二进制数、十进制数、十六进制等。<br>因此需要对连续的模拟量和离散的数字量做转换，就出现了A/D(Analog to Digital)、D/A(Digital to Analog)转换器芯片。</p>
<h3 id="D-A转换芯片DAC0832"><a href="#D-A转换芯片DAC0832" class="headerlink" title="D/A转换芯片DAC0832"></a>D/A转换芯片DAC0832</h3><p>D/A转换器的功能是把二进制数字量电信号–&gt;与其数值成正比的模拟量电信号(电压、电流..)。<br>如下图：横坐标为输入的数字信号量，纵坐标为输出的模拟信号量。<br><img src="/images/接口技术及应用/DA转换器功能.png" width="275" height="155" alt="D/A转换器功能" align="center/"></p>
<p>DAC0832主要有三项技术指标：分辨率、精度和建立时间。</p>
<ul>
<li><p><strong>分辨率</strong><br>分辨率是指输入数字量发生一个单位的变化时，输出模拟量的变化量，这个参数反映了DAC对模拟量的分辨能力<br>eg：<br>满刻度值电压为5V、10位DAC：能分辨的电压为\(\small 5/2^{10}=4.88(mV)\)。<br>满刻度值电压为5V、8位DAC：能分辨的电压为\(\small 5/2^8=19.53(mV)\)。</p>
</li>
<li><p><strong>精度</strong><br>精度表明了模拟输出实际值与理想值之间的偏差，可能工艺做的器件比较粗糙，导致实际用的时候有误差，反映的是“工艺”精度。</p>
</li>
<li><p><strong>建立时间</strong><br>从数字输入端发生变化开始，到模拟输出稳定在理想值的\(\pm \frac{1} {2}\)\(\small LSB\)时所需的时间（LSB指分辨率）。</p>
</li>
<li><p><strong>DAC0832内部结构</strong><br><img src="/images/接口技术及应用/DAC0832结构.png" width="400" height="206" alt="D/A转换器结构" align="center/"><br>DAC0832内部有两个数据缓冲器，分别由两组控制信号控制：<br><strong>输入寄存器：</strong>存放外部输入的数据，当\(\small ILE=1\cap \overline{CS}=0\cap \overline{WR1}=0\)时，\(\small LE1\)端有效，DI7~DI0上的数据锁被写到输入寄存器中。<br><strong>DAC寄存器：</strong>存放要输出的数据（D/A转换器根据DAC寄存器中的值计算输出的模拟值），当\(\small \overline{XFER}=0\cap \overline{WR2}=0\)时，\(\small LE2\)端有效，输入寄存器中的数据被写到DAC寄存器中。<br><strong>DAC0832外部引脚：</strong><br>\(\small DI0\sim DI7\)：8位数字输入端，DI0为最低端，DI7为最高端。<br>\(\small ILE\)：数据输入锁存允许，通常一直为高电平；<br>\(\small \overline{CS}\)：片选信号1–&gt;输入寄存器。<br>\(\small \overline{XFER}\)：片选信号2–&gt;DAC寄存器。<br>\(\small \overline{WR1}\)：写信号1，输入寄存器写选通信号。<br>\(\small \overline{WR2}\)：写信号2，DAC寄存器写选通信号。<br>\(\small Iout1\)：DAC电流输出端1，为数字输入端为1的位的输出电流之和。全1时最大，全0时最小。<br>\(\small Iout2\)：电流输出端2，\(\small Iout1+Iout2=常数\)</p>
</li>
<li><p><strong>DAC0832工作时序</strong><br><img src="/images/接口技术及应用/DAC0832工作时序.png" width="485" height="317" alt="DAC0832工作时序" align="center/"></p>
</li>
</ul>
<h3 id="DAC0832工作方式"><a href="#DAC0832工作方式" class="headerlink" title="DAC0832工作方式"></a>DAC0832工作方式</h3><p>DAC0832没有应答信号，有数据输入时，若已经选通了，即开始转换；也没有控制字信号，直接送数据即可。<br>DAC0832有单缓冲模式、双缓冲模式、无缓冲模式三种工作方式，重点是<strong>单缓冲模式</strong>。<br><strong>缓冲的含义：</strong>缓冲即指锁存，锁存就是寄存器能否暂存数据（尽管有新的输入数据，但仍旧保持原有的值，直到某个信号的到来才更新寄存器的值）。如果没有锁存功能，就是寄存器值和输入值保持同步，输出会随着输入而变化。<br>在DAC0832中，实现两个寄存器的缓冲功能，要通过寄存器对应的选通信号线：选通信号线处于无效状态，数据就写不进去，就实现了缓冲/锁存。若选通信号线恒有效，就没有缓冲功能。<br><strong>如何设置工作方式：</strong>0832没有命令字，根据选通信号引脚连线的不同来决定工作方式。</p>
<ul>
<li><p><strong>双缓冲方式</strong><br>输入寄存器、DAC寄存器都有缓冲功能。当把数据由输入寄存器写到DAC寄存器以后，输入寄存器就可以接受新数据而不影响模拟输出值，该结构便于多路DAC同时工作（可以时分复用，利用DAC寄存器中数据转换的时间读取数据）。<br><img src="/images/接口技术及应用/DAC0832双缓冲方式.png" width="380" height="275" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">要分别对两个寄存器写数据</span><br><span class="line">MOV DX，200H    ;DAC0832 的输入锁存器的地址为200H </span><br><span class="line">OUT DX，AL      ;AL中数据DATA送输入寄存器</span><br><span class="line">MOV DX，201H	;DAC0832 的DAC锁存器的地址为201H </span><br><span class="line">OUT DX，AL   	;数据DATA写入DAC锁存器并转换</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单缓冲方式</strong><br>只有输入寄存器有缓冲功能。只需一次写操作，就开始转换，提高了D/A的数据吞吐量。适合在不要求多片D/A同时输出时。<br><img src="/images/接口技术及应用/DAC0832单缓冲方式.png" width="390" height="234" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV	DX，200H	;设DAC0832的地址为200H</span><br><span class="line">OUT	DX，AL	    ;AL内数据送DAC转换</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>直通方式</strong><br>两寄存器都没有缓冲功能，输出随输入同步变化。<br><img src="/images/接口技术及应用/DAC0832直通方式.png" width="385" height="180" align="center/"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV   DX，200H 	  ;8255的A口地址为200H</span><br><span class="line">OUT   DX，AL      ;AL中数据送A口锁存并转换</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用DAC0832输出三角波</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;设输出初始值0</span><br><span class="line">L1:  MOV AL, 0</span><br><span class="line"></span><br><span class="line">;输出数值递增，产生三角波上升沿</span><br><span class="line">UP:  MOV DX, 300H   ;单缓冲</span><br><span class="line">OUT  DX, AL</span><br><span class="line">INC  AL</span><br><span class="line">CALL DELAY</span><br><span class="line">;判断输出是否为0，JNZ：不为0跳转</span><br><span class="line">AND  AL, AL</span><br><span class="line">JNZ  UP</span><br><span class="line"></span><br><span class="line">;输出数值递减，产生三角波下降沿</span><br><span class="line">DOWN: DEC AL   ;AL=0-1=255</span><br><span class="line">OUT  DX, AL		       </span><br><span class="line">CALL DELAY</span><br><span class="line">;判断输出是否为0</span><br><span class="line">AND  AL, AL</span><br><span class="line">JNZ  DOWN</span><br><span class="line">LOOP L1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="A-D转换芯片ADC0809"><a href="#A-D转换芯片ADC0809" class="headerlink" title="A/D转换芯片ADC0809"></a>A/D转换芯片ADC0809</h3><p>将模拟信号转换为数字信号</p>
<ul>
<li><p><strong>A/D转换基本原理：</strong><br><strong>采样：</strong>利用采样脉冲序列，从信号中抽取一系列离散值，使之成为采样信号；<br><strong>量化：</strong>把采样信号经过舍入变为只有有限个有效数字的数，使电流和数据有一一对应的关系；<br><strong>编码：</strong>将经过量化的值变为二进制数字。<br><strong>如何将十进制数值转换为二进制：</strong>使用逐次逼近的方法，具体原理如下图：<br><img src="/images/接口技术及应用/AD转换逐次逼近原理.png" width="385" height="180" alt="A/D转换逐次逼近原理" align="center/"></p>
</li>
<li><p><strong>ADC0809结构</strong><br><img src="/images/接口技术及应用/ADC0809结构图.png" width="375" height="252" alt="ADC0809结构图" align="center/"><br><strong>IN7~IN0：</strong>8路模拟信号输入。<br><strong>ADDC、ADDB、ADDA：</strong>8路模拟信号量的地址选择线，选择要接收的一路模拟信号量。<br><strong>ALE：</strong>地址锁存允许，其正跳变锁存地址选择线状态，经译码选通对应的模拟输入信号。<br><strong>START：</strong>启动信号，上升沿使片内所有寄存器清零，下降沿启动A/D转换（通常与ALE共用一根线）。<br><strong>EOC：</strong>AD转换结束信号，转换开始后，此引脚变为低电平，转换一结束，此引脚变为高电平；<br><strong>OE：</strong>输出允许，当有效时，D7~D0输出结果。<br><strong>D7~D0：</strong>8位数据输出线。</p>
</li>
<li><p><strong>ADC0809输出数据的传送方式</strong><br><strong>延时等待法：</strong>软件延时等待足够长的时间（大于转换时间），此时不用EOC信号，CPU效率最低。<br><strong>中断法：</strong>把EOC作为中断请求信号，在中断服务程序中读入转换结果，效率较高。<br><strong>查询法：</strong>软件查询EOC信号的状态。<br>具体代码见PPT</p>
</li>
</ul>
<h2 id="第七章-串行接口"><a href="#第七章-串行接口" class="headerlink" title="第七章 串行接口"></a>第七章 串行接口</h2><h3 id="串行通信方式基本概念"><a href="#串行通信方式基本概念" class="headerlink" title="串行通信方式基本概念"></a>串行通信方式基本概念</h3><p><strong>串行通信方式：</strong>在一条传输线上，将多位数据从低位到高位顺序地进行传输。<br><strong>并行通信方式：</strong>在多条传输线上同时传输多位数据，且有专门的联络、控制信号线。</p>
<ul>
<li><p><strong>串行通信的数据传送方向</strong><br><img src="/images/接口技术及应用/串行通信数据传送方向.png" width="455" height="222" alt="串行通信数据传送方向" align="center/"></p>
</li>
<li><p><strong>信号的调制和解调</strong><br>数据通信设备DCE：Modern<br>数据终端设备DTC：主机、终端通讯设备。<br>三种调制方式：振幅键控（ASK），频移键控（FSK）和相移键控（PSK） </p>
</li>
<li><p><strong>数据的传输速度</strong><br>数字通信中，传输速率经常用波特率(baud)来表示。同时为提高发送/接收时钟对波特率的定位精度，发送/接收时钟的频率常定为波特率的整数倍（1、16、32、64），这个整数称为<strong>波特率因子</strong>。$$TxC=factor\times baud$$ TxC为发送/接收时钟频率。<br>波特率因子可理解为发送/接收1位数据所需要的时钟脉冲个数，即在发送端，需要多少个时钟脉冲才能移出1位数据。时钟脉冲多一些，可提高定位采样的精度。</p>
</li>
<li><p><strong>串行通信的基本方式</strong><br><strong>异步串行通信：</strong>以字符为单位发送数据，字符间间隔不定（异步），但字符内各位是同步的。适合数据量少、速率低，发送数据不连续的场合。<br><strong>同步串行通信：</strong>以数据块为单位发送数据，字符间、字符内都是同步的。适合速率高，连续传输大批量数据的场合。<br><strong>外同步：</strong>发送端发数据前先发送同步时钟信号，接收方用这一同步信号来锁定自己的时钟脉冲频率，来达到收发双方位同步的目的。<br><strong>自同步法：</strong>接收方利用包含有同步信号的特殊编码（如曼彻斯特编码）从信号自身提取同步信号来锁定自己的时钟脉冲频率，达到同步目的。</p>
</li>
<li><p><strong>串行通信数据格式</strong><br>对于异步串行通信，因为字符间的间隙不固定，因此要有起始位和终止位。<br><img src="/images/接口技术及应用/异步串行通信数据格式.png" width="375" height="90" alt="异步串行通信数据格式" align="center/"><br>对于同步串行通信，要求有时钟来实现发送端与接收端之间的同步，因此有很多控制字符，因较为复杂就不列举了。</p>
</li>
</ul>
<h3 id="串行接口标准RS-232C"><a href="#串行接口标准RS-232C" class="headerlink" title="串行接口标准RS-232C"></a>串行接口标准RS-232C</h3><ul>
<li><p><strong>电气特性</strong><br><strong>在TxD和RxD数据上：</strong><br>逻辑1(MARK) = -3 ~ -15V<br>逻辑0(SPACE) = +3 ~ +15V<br><strong>在RTS、CTS、DSR、DTR和DCD等控制线上：</strong><br>信号有效（接通，ON状态）= +3 ~ +15V<br>信号无效（断开，OFF状态）= -3 ~ -15V </p>
</li>
<li><p><strong>RS-232C的引脚信号线</strong><br><img src="/images/接口技术及应用/RS232C引脚图.png" width="353" height="243" alt="RS232C引脚信号线" align="center/"><br>数据发送与接收线：<br>TxD：发送数据，将串行数据发送到MODEM　　<br>RxD：接收数据，从MODEM接收发来的串行数据<br>状态线：<br>DSR：表明MODEM可以使用。<br>DTR：表明数据终端可以使用。<br>信号联络线（modem之间建立通信链路）：<br>RI：振铃指示，当MODEM收到交换台送来的振铃呼叫信号时，通知终端，表示交换台准备好了。<br>DCD：数据载波检出线，表示MODEM已接通通信链路。<br>信号联络线（modem与终端之间）：<br>RTS：请求发送，表示DTE请求DCE发送数据。<br>CTS：允许发送，表示DCE准备好了，DTE可以发数据，是对RTS的响应信号。<br>地线：<br>GND：地线</p>
</li>
<li><p><strong>数据传输过程</strong><br><img src="/images/接口技术及应用/RS232C数据传输过程.png" width="495" height="315" alt="RS232C数据传输过程" align="center/"></p>
</li>
<li><p><strong>微机间连线方式</strong><br>重点是不使用联络信号的3线相连方式，如下图所示：<br><img src="/images/接口技术及应用/串口连接方式.png" width="220" height="190" alt="R串口连接方式" align="center/"><br>不使用Modem，TxD和RxD要交叉连接。</p>
</li>
</ul>
<h3 id="8251可编程通信接口"><a href="#8251可编程通信接口" class="headerlink" title="8251可编程通信接口"></a>8251可编程通信接口</h3><p>8251是通用同步异步接收发送器USART(Univesal Synchronous Asynchronous Receiver and Transmitter)，适合作为异步起止式和同步面向字符式的接口。<br><img src="/images/接口技术及应用/8251接口.png" width="275" height="165" alt="8251接口" align="center/"></p>
<h2 id="第八章-存储器"><a href="#第八章-存储器" class="headerlink" title="第八章 存储器"></a>第八章 存储器</h2><ul>
<li><p><strong>内存的分类</strong><br><img src="/images/接口技术及应用/内存的分类.png" width="450" height="200" alt="内存分类" align="center/"><br>DRAM的特点：主要由电容构成，需要定时刷新<br>DRAM芯片举例：intel 2164A，容量为\(64k\times 1\)</p>
</li>
<li><p><strong>存储器扩展技术</strong><br>存储器的存储容量等于：单元数(字节数)×每单元的位数(字长)，因此就有三种扩容方式：字扩展、位扩展、字位扩展。</p>
</li>
<li><p><strong>位扩展</strong><br>地址线、片选线和读写信号线各芯片共用，数据线单独引出。<br>eg：8片64K×1位的SRAM芯片构成容量为64KB的存储器<br><img src="/images/接口技术及应用/位扩展.png" width="400" height="305" alt="位扩展" align="center/"></p>
</li>
<li><p><strong>字扩展</strong><br>地址线、读写信号线和数据线各芯片共用，片选线单独引出。<br>eg：4片16K×8位的SRAM芯片构成容量为64KB的存储器<br><img src="/images/接口技术及应用/字扩展.png" width="470" height="320" alt="字扩展" align="center/"></p>
</li>
<li><p><strong>字位扩展</strong><br>结合了上述两种方法的特点。<br>eg：用8片16K×4位的存储器芯片组成64K×8位的存储器<br><img src="/images/接口技术及应用/字位扩展.png" width="440" height="240" alt="字位扩展" align="center/"></p>
</li>
</ul>
<h2 id="第九章-人机接口"><a href="#第九章-人机接口" class="headerlink" title="第九章 人机接口"></a>第九章 人机接口</h2><ul>
<li><p><strong>键盘接口的分类</strong><br><strong>编码键盘：</strong>这种键盘内部能自动检测被按下的键，并提供与被按键对应的键码（如ASCII码），以并行或串行方式送给CPU。<br><strong>非编码键盘：</strong>这种键盘只提供键盘的行列矩阵，而按键的识别和键值的确定、输入等工作通过软件完成。这是目前可得到的最便宜的微机输入设备。 </p>
</li>
<li><p><strong>软件实现非编码键盘识别的方法</strong><br><img src="/images/接口技术及应用/非编码键盘.png" width="330" height="165" alt="非编码键盘示意图" align="center/"><br><strong>扫描法：</strong><br>依次查询键盘矩阵的每一行线，然后读取列数据确定按键是否在本行，具体方法如下：<br>首先使PA0=0，然后读取PB端口。<br>若PB=0FFH则表示行0没有按键按下，再使PA1=0再读取PB判断行2有无按键按下，依次扫描全部的行线。<br>当PB读取的数据不为0FFH，则表示该扫描行有按键按下，则再确定相应的按键序号。<br>时间复杂度：\(n^2\)<br><strong>行列交换法：</strong><br>使CPU通过A口向各行线上全部送低电平，然后从B口读入列线的值。<br>如果某按键按下，则必定会使某一列线值为0。然后，交换A口B口的输入输出方向，并将刚才读到的列线值从列线所接的并口输出。<br>再读取行线上的输入值，在闭合键所在的行线上的值必定为0。这样，当一个按键被按下时，必定可以读取一对唯一的行值和列值。<br>时间复杂度：\(2n\)</p>
</li>
<li><p><strong>七段数码管</strong><br>七段数码管就是并行接口8255，7个段分别对应8255的一个引脚，通过设置引脚电平来控制亮灭，示意图如下：<br><img src="/images/接口技术及应用/七段数码管.png" width="330" height="165" alt="七段数码管" align="center/"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/微机接口技术与应用/" data-id="cjmmeykxt000wd5qx1shijnto" class="article-share-link" data-share="baidu" data-title="微机接口技术与应用">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/微机接口技术与应用/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/课程笔记/">课程笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Algorithm/MOOC_C语言程序设计笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/13/Algorithm/MOOC_C语言程序设计笔记/" class="article-date">
  <time datetime="2018-09-13T07:49:58.000Z" itemprop="datePublished">2018-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/13/Algorithm/MOOC_C语言程序设计笔记/">MOOC_C语言笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="第一节-基础知识"><a href="#第一节-基础知识" class="headerlink" title="第一节_基础知识"></a>第一节_基础知识</h2><ul>
<li><strong>STL：</strong>C++中的标准模板库</li>
<li><p><strong>define和typedef</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 9999  <span class="comment">//宏定义，多用来替代常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; MAP; <span class="comment">//为复杂的类型定义取别名，简化程序，也便于修改。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型取值范围</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字节数</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">-2^31~2^31-1(-21亿~21亿)</td>
</tr>
<tr>
<td style="text-align:center">long long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-2^63~2^63-1(很大)</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3.4x10^-38~3.4x10^38(绝对值)</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1.7x10^-308~1.7x10^308(绝对值)</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127</td>
</tr>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">1</td>
<td style="text-align:center">true/false</td>
</tr>
</tbody>
</table>
<ul>
<li><p>double类型比较相等：相减-&gt;是否小于一个很小的数(0.00001)。<br>比大小：直接&gt; &lt; 比较即可。</p>
</li>
<li><p>求字节数：sizeof(int)/sizeof(n)</p>
</li>
<li><p>反斜杠\，转义字符、win下地址路径；正斜杠/，网址路径。</p>
</li>
<li><p>字符型和整型数据可以相互转换，整型-&gt;字符型：只留最右边8位，再转成ASCII码。</p>
</li>
<li><p>常用ASCII码：<br>‘0’-‘9’：48-57<br>‘A’-‘Z’：65-90<br>‘a’-‘z’：97-122</p>
</li>
<li><p>十六进制常量：0x打头,0xFFA，1个十六进制位对应4个二进制位。<br>表示二进制：转化为16进制。00101011-&gt;0x2b</p>
</li>
<li><p>八进制整型常量：0打头，0677,1个八进制位对应3个二进制位。</p>
</li>
<li><p><strong>位运算</strong><br>单独对某些比特进行操作<br><strong>与&amp;</strong>：将某些位置0、获取变量中的某一位<br>eg：判断n的第7位是否为为0，n&amp;0x80==ox80？</p>
</li>
</ul>
<p><strong>或|</strong>：将某些位置1</p>
<p><strong>异或^</strong>：相同为0不同为1。将某些位按位取反，其他位不变：取反的与1异或，其他与0异或。</p>
<p><strong>非~</strong>：按位取反。</p>
<p><strong>左移&lt;&lt;</strong>：左移n位即乘2的n次方，但比乘法要快很多。</p>
<p><strong>右移&gt;&gt;</strong>：除2的n次方，且向小取整。高位补符号位。</p>
<h2 id="第二节-数据结构"><a href="#第二节-数据结构" class="headerlink" title="第二节_数据结构"></a>第二节_数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>初始化：类型名 数组名[数量]={x1,x2,x3,x4..} 或 用for循环初始化。<br>数组越界编译器不会报错，会根据内存地址去访问，数组名即相当于内存地址。<br><strong>编程技巧：可用数组取代复杂的switch case分支结构</strong></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><strong>字符串三种形式</strong><br>1、字符串常量，双引号括起来””。<br>2、存放在char数组中，以’\0’结尾，多占一个数组元素。<br>3、string对象，c++标准模板库中的类。<br>注：char数组比string快，但char数组没法传字符串值，只能传数组首地址。因此在一些需要传值的场合，用string更合适。</li>
</ul>
<p>字符串在内存占的字节数等于字符数目加1(‘\0’的存在 )<br><strong>读入字符串</strong>：cin或scanf，读到空格为止。空格后内容在下一次cin读入。<br><strong>读一行</strong>：cin.getline(char buf[],int bufSize)，读入不超过bufsize-1个字符</p>
<h3 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> ID;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">float</span> fGPA;</span><br><span class="line">    Student* frd;<span class="comment">//成员可以是结构体的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s1 = &#123;<span class="number">1234</span>,<span class="string">"TOM"</span>,...&#125;;<span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1.ID;</span><br><span class="line">Student* s2;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2-&gt;ID; / <span class="built_in">cout</span>&lt;&lt;(*s2).ID;指针访问成员</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>局部变量：</strong>定义在函数内部、语句块内部的变量。<br><strong>全局变量：</strong>定义在函数外部(main函数外)，在所有函数中均可使用。默认初始化为0.<br><strong>静态变量：</strong>全局变量和static定义的变量。生存期一直持续到整个程序结束。<br><strong>PS：</strong>若未初始化，静态变量默认赋值为0，非静态变量值为随机的。</p>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> x1:</span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">//有无中括号都可以</span></span><br><span class="line">    <span class="keyword">case</span> x2:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三节-函数与输入输出"><a href="#第三节-函数与输入输出" class="headerlink" title="第三节_函数与输入输出"></a>第三节_函数与输入输出</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数定义：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">return</span> xx ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数声明：(无函数体，常写在开头)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;<span class="comment">//一维数组作形参，不用写大小。int a[]与int *a等价。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fan3</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>])</span><span class="comment">//二维数组作形参，行数不用写，列数必须写</span></span></span><br></pre></td></tr></table></figure>
<p>函数的形参是实参的<strong>拷贝</strong>，形参的改变不会影响实参。(除非形参是数组、引用或对象)<br>string类型也是传值<br>数组作形参传的是首地址，并非整个数组。</p>
<h3 id="printf、scanf格式化输入输出"><a href="#printf、scanf格式化输入输出" class="headerlink" title="printf、scanf格式化输入输出"></a>printf、scanf格式化输入输出</h3><p>比cin/cout效率高，尽量使用。<br>%：类型占位符</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">int类型</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">char类型</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">float类型</td>
</tr>
<tr>
<td style="text-align:center">%lf</td>
<td style="text-align:center">double类型</td>
</tr>
<tr>
<td style="text-align:center">%.xlf</td>
<td style="text-align:center">输出x位小数</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;   //头文件</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"这是字符型数据%c，这是int型数据%d"</span>，ch,i);  <span class="comment">//格式化输出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);  <span class="comment">//记得加&amp;，返回值是接收变量的个数</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,c); <span class="comment">//读入字符串，检测到/0结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值为EOF(-1)时说明输入结束</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(xxx) != EOF)&#123;</span><br><span class="line">    <span class="comment">//循环读入数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.peek()   <span class="comment">//看一个字符不取走</span></span><br><span class="line"><span class="built_in">cin</span>.putback(c)  <span class="comment">//把字符放回输入流头部</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>函数读空格和换行：</span><br><span class="line">如果是%d、%f数值类型，会自动跳过多余的空格和换行，如果是%c会读入空格和换行。</span><br></pre></td></tr></table></figure>
<h3 id="freopen重定向"><a href="#freopen重定向" class="headerlink" title="freopen重定向"></a>freopen重定向</h3><p>将输入由键盘重定向为文件(不用每次都输入测试数据)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">"c:\\xxx.txt"</span>，<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(...)!=EOF)&#123;</span><br><span class="line">    <span class="comment">//从txt文件中输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="cin函数"><a href="#cin函数" class="headerlink" title="cin函数"></a>cin函数</h3><p>cin &gt;&gt; n &gt;&gt; m;<br>返回True(成功接收所有输入)或false()<br>while(cin &gt;&gt; n){<br>    //循环读入数据<br>}<br>注：cin读入的格式由后面的变量决定，若为char即读入一个字符，int则读入一个整数(遇到空格/换行为止)</p>
<h2 id="第四节-指针"><a href="#第四节-指针" class="headerlink" title="第四节_指针"></a>第四节_指针</h2><ul>
<li><strong>指针</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指针变量，<span class="number">4</span>个字节，内容表示一个内存地址。</span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">//p类型：int *，*p的类型：int</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> *pc = &amp;c1; <span class="comment">//pc指向变量c1</span></span><br><span class="line"><span class="comment">//*：间接引用运算符。&amp;：取地址运算符。</span></span><br><span class="line"><span class="comment">//&amp;x：变量x的地址，就是指向x的指针，类型是 T*。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>指针的意义：不需要通过变量，即可自由访问内存空间。</p>
<ul>
<li><p><strong>指针互相赋值</strong><br>不同类型的指针，如果不经过强制类型转换，不能直接相互赋值。 (每个指针类型还代表着一次向内存读/写多少字节)<br>char <em>c = ‘A’;<br>int </em>p = (int <em>)c;
</em>p=122; //此时’A’后面三个字节的值也会被改变。</p>
</li>
<li><p><strong>指针的运算</strong></p>
</li>
</ul>
<ol>
<li>指针比大小：比p1和p2地址的大小</li>
<li>指针相减：p1-p2=(地址p1-地址p2)/sizeof(T)</li>
<li>p+n=p+n*sizeof(T)，结果还是指针。</li>
<li>p[n]=*(p+n)</li>
</ol>
<ul>
<li><p><strong>空指针</strong><br>指向地址0的指针，int *pn=NULL;</p>
</li>
<li><p><strong>指针和字符串</strong><br>字符串常量、字符数组的类型都是char*。</p>
</li>
<li><p><strong>void指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以用任何类型的指针对<span class="keyword">void</span>指针进行赋值</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">但*p、P+n、p++等均无意义</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>void*自动匹配</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>函数</span><br><span class="line">void* memset(void* dest,int ch,int n)：将dest开始的n个字节都设置为ch(取其最低位字节)，初始化数组。</span><br><span class="line"><span class="comment">//对char数组赋值时，结尾要加'\0'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>函数</span><br><span class="line">void* memcpy(void* dest,void* src,int n)：将n个字节拷贝src-&gt;dest。</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a1[<span class="number">10</span>]=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">char</span> a2[<span class="number">10</span>]=<span class="string">""</span>;</span><br><span class="line"><span class="built_in">memset</span>(a1, <span class="string">'a'</span>, <span class="keyword">sizeof</span>(a1)<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(a2, a1, <span class="keyword">sizeof</span>(a2));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出aaaaaaaaaa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向函数入口地址的指针</span></span><br><span class="line"><span class="keyword">int</span> (*Pf)(<span class="keyword">int</span>,<span class="keyword">char</span>)</span><br><span class="line">pf = fun_name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第五节-基本STL"><a href="#第五节-基本STL" class="headerlink" title="第五节_基本STL"></a>第五节_基本STL</h2><ul>
<li><strong>库函数和头文件</strong><br>库函数：编译器自带的函数<br>头文件：包含许多库函数的声明</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">//sort(数组名+n1,数组名+n2)，对数组[n1,n2)区间排序，默认从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">15</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;</span><br><span class="line">sort(a,a+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))  <span class="comment">//从小到大排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="comment">//#include &lt;functional&gt;头文件</span></span><br><span class="line">sort(a,a+<span class="number">7</span>,greater&lt;T&gt;())  </span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义排序规则</span></span><br><span class="line"><span class="keyword">bool</span> cmp(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a1,<span class="keyword">const</span> <span class="keyword">int</span> &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1 &gt; a2;</span><br><span class="line">    <span class="comment">//若a1应排在a2前面，则返回true。否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">15</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>&#125;</span><br><span class="line">sort(a,a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cmp());</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul>
<li><strong>前提条件</strong><br>所有的二分查找，都是应用在<strong>有序</strong>列表中的。</li>
<li><p><strong>binary_search函数</strong><br>两种使用方法：<br><code>bool binary_search(数组名+n1,数组名+n2,值)</code><br><code>bool binary_search(数组名+n1,数组名+n2,值,排序规则结构名())</code>，查找时的规则必须和排序时的规则一致。<br>对排好序的数组进行二分查找，返回值true：找到，false：没找到。<br><strong>查找的本质：</strong>查找x，即找到一个元素y，使得“x必须排在y前面”和“y必须排在x前面”都不成立（和 == 的含义不一样），这样就算找到了；没有找到元素y，就是没找到。<br>所以不存在的元素同样有可能查的到（eg：按个位排序，查找的元素只要个位相等就能查到，十位/百位不一定会相等），因此查找的结果要视具体排序规则来分析。</p>
</li>
<li><p><strong>lower_bound函数</strong><br><code>T* lower_bound(数组名+n1,数组名+n2,值)</code><br>返回序号p，使得[n1,p)中元素都小于查找值。<br>若比所有元素都小/大，则指向n1/n2。<br>为避免返回序号为n1时的歧义，查前要确保值在数组范围内。</p>
</li>
<li><p><strong>upper_bound函数</strong><br><code>T* upper_bound(数组名+n1,数组名+n2,值)</code><br>返回指针p，使得[p,n2)中元素都大于查找值。</p>
</li>
</ul>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>在log(n)内快速添加、删除、查找元素<br>应用了平衡二叉树的四种<strong>排序容器</strong>：<code>multiset</code>、<code>set</code>、<code>multimap</code>、<code>map</code></p>
<h3 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h3><ul>
<li><p><strong>主要作用</strong><br>自动对集合内元素排序(默认从小到大)，且允许元素重复，在一些需要动态增加、删除元素的排序场景下使用很方便。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //头文件</span></span></span><br><span class="line"><span class="built_in">multiset</span>&lt;T&gt; st;</span><br><span class="line">T a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">multiset</span>&lt;T&gt; st2(a,a+<span class="number">5</span>); <span class="comment">//用数组初始化</span></span><br><span class="line">st.insert(a); <span class="comment">//插入元素a，自动排序。插入的是复制值，并非引用。</span></span><br><span class="line">st.erase(a);  <span class="comment">//删除元素a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合，用迭代器</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  <span class="comment">//定义迭代器，类似指针</span></span><br><span class="line"><span class="keyword">for</span> (it = st.begin(); it != st.end(); it++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="comment">//end()为末尾指针，指向最后一个元素的后面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">it = st.find(a);   <span class="comment">//查找元素a，返回迭代器,没找到返回end()</span></span><br><span class="line"></span><br><span class="line">st.lower_bound(a);  <span class="comment">//返回迭代器it,使得[begin(),it)中元素都比a小，注意是前闭后开区间</span></span><br><span class="line"></span><br><span class="line">st.upper_bound(a)  <span class="comment">//返回迭代器it,使得[it,end())中元素都比a大</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义排序规则的multiset</strong><br>1、自定义规则结构体Rule，实现<code>bool operator()(const &amp; T,const &amp; T)</code>函数<br>2、定义容器multiset&lt;T,Rule&gt;<br>3、定义迭代器muliset&lt;T,Rule&gt;::iterator</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义规则结构体Rule方法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> &amp; T,<span class="keyword">const</span> &amp; T)</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h3><p>与multiset容器区别：不能有重复元素，其他都一样。<br>a和b重复的含义：a排在b前面、b排在a前面都不成立<br>注：因为不能重复，所以插入元素有可能不成功。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">set</span>&lt;T&gt;::iterator,<span class="keyword">bool</span>&gt; result = <span class="built_in">set</span>.insert(n);  </span><br><span class="line"><span class="comment">//result.second==true，插入成功；否则失败。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="multimap容器"><a href="#multimap容器" class="headerlink" title="multimap容器"></a>multimap容器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">键值对形式，<span class="built_in">multimap</span>中的元素都是pair形式。</span><br><span class="line">按first进行排序，一般不自定义排序。</span><br><span class="line"></span><br><span class="line">pair模板：pair&lt;T1,T2&gt;</span><br><span class="line">等价于</span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    T1 first;  <span class="comment">//关键字</span></span><br><span class="line">    T2 second; <span class="comment">//值 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="built_in">multimap</span>&lt;T1,T2&gt; mp;</span><br><span class="line">mp.insert(make_pair(T1变量,T2变量))  <span class="comment">//make_pair为转换pair模板的函数</span></span><br><span class="line">multima&lt;T1,T2&gt;::iterator it  <span class="comment">//迭代器</span></span><br></pre></td></tr></table></figure>
<h3 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h3><p>和multimap区别：不能有关键字重复的元素<br>可以使用[first]查找second值；若first不存在，则创建一个。<br>插入可能失败(first重复)。</p>
<h3 id="camath数学库"><a href="#camath数学库" class="headerlink" title="camath数学库"></a>camath数学库</h3><ol>
<li>abs(int x)：整数绝对值</li>
<li>fabs(double x)：浮点数绝对值</li>
<li>sqrt(double x)：求平方根</li>
<li>ceil(double x)：不小于x的最小整数(上取整)</li>
<li>sin(double x)/cos(double x)：x(弧度)的正/余弦</li>
</ol>
<h3 id="cstring字符串库"><a href="#cstring字符串库" class="headerlink" title="cstring字符串库"></a>cstring字符串库</h3><p>函数都是根据’\0’来判断字符串是否结束的。</p>
<ol>
<li>形参常为char c[]，实参可以为char数组或字符串常量。</li>
<li>int strcmp(char c1[],char c2[])：比较字符串，相等返回0，c1小返回负数。</li>
<li>char* strcpy(char dest[],char src[])：拷贝字符串src-&gt;dest，返回dest首地址。</li>
<li>int strlen(char c[])：求字符串长度</li>
<li>char<em> strchr(char </em>str,char c)：str中查字符c是否在str中，返回指向位置的指针，未查到为NULL。</li>
<li>char<em> strstr(char </em>str1,char *str2)：str1中查子串str2位置，返回指向位置的指针，未查到为NULL。</li>
<li>cbar<em> strtok(char </em>str1,char* str2)：str1中抽取被str2分隔的子串。(将str1中的分隔符用’/0’代替了)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = strtok(str1, str2);</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		p = strtok(<span class="literal">NULL</span>, str2);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="ctype-h字符库"><a href="#ctype-h字符库" class="headerlink" title="ctype.h字符库"></a>ctype.h字符库</h3><ol>
<li>bool isdigit(int c)：判断c是否是数字字符</li>
<li>bool isalpha(int c)：判断c是否是字母字符</li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/09/13/Algorithm/MOOC_C语言程序设计笔记/" data-id="cjmmeyky70016d5qxhgewtutx" class="article-share-link" data-share="baidu" data-title="MOOC_C语言笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/09/13/Algorithm/MOOC_C语言程序设计笔记/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-概率论与数理统计笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/25/概率论与数理统计笔记/" class="article-date">
  <time datetime="2018-06-25T07:14:00.000Z" itemprop="datePublished">2018-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/25/概率论与数理统计笔记/">概率论与数理统计笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

<hr>
<p>最近在学习数据挖掘、机器学习的相关算法时，感到统计知识的应用还是非常广泛且重要的，因此决定从新温习一遍概率论和数理统计，为进一步学习数据挖掘打下基础。</p>
<hr>
<h2 id="绪言"><a href="#绪言" class="headerlink" title="绪言"></a>绪言</h2><ul>
<li><p><strong>概率论</strong><br>数学的一个分支，研究如何定量描述随机现象及其规律。</p>
</li>
<li><p><strong>数理统计</strong><br>以数据为研究对象，包括数据的收集、整理、分析和建模，从而对随机现象的某些规律进行预测或决策。</p>
</li>
</ul>
<hr>
<h2 id="第一章-随机事件与概率"><a href="#第一章-随机事件与概率" class="headerlink" title="第一章_随机事件与概率"></a>第一章_随机事件与概率</h2><ul>
<li><p><strong>三个基本概念</strong><br>样本空间：随机试验中所有可能结果的集合称为样本空间，记为S。<br>样本点：S中的单个元素称为样本点，也称为基本事件。<br>随机事件：样本空间S的子集，称为随机事件，一个随机事件可以包含多个基本事件。</p>
</li>
<li><p><strong>事件的相互关系</strong>（若有事件A和事件B）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>记法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>合事件</td>
<td>\(A\cup B\)</td>
<td>A、B至少有一个发生</td>
</tr>
<tr>
<td>积事件</td>
<td>\(A\cap B\) 或简写为 \(AB\)</td>
<td>A、B同时发生</td>
</tr>
<tr>
<td>差事件</td>
<td>\(A-B\)</td>
<td>A发生且B不发生</td>
</tr>
<tr>
<td>互斥事件/不相容事件</td>
<td>\(AB=\phi\)</td>
<td>AB不能同时发生</td>
</tr>
<tr>
<td>对立事件/逆事件</td>
<td>\(\bar{A}\)</td>
<td>\(A\cup \bar{A} = S\)，\(A\cap \bar{A} = \phi\)</td>
</tr>
</tbody>
</table>
<p>注1：差事件有多种表示方法，如\(A-B = A\bar{B} = A-AB\)<br>注2：区分\(\overline{AB}\)和\(\bar{A}\bar{B}\)，\(\overline{AB}\)表示A、B不同时发生(可单独发生)，\(\bar{A}\bar{B}\)表示A、B都不发生</p>
<ul>
<li><p><strong>重要的事件运算定律</strong><br>结合律：<br>  \(A\cup (B\cap C) = (A\cup B)\cap (A\cup C)\)<br>  \(A\cap (B\cup C) = (A\cap B)\cup (A\cap C)\)<br>德摩根律：<br>  \(\overline{A\cup B} = \bar{A}\cap \bar{B}\)<br>  \(\overline{A\cap B} = \bar{A}\cup \bar{B}\)<br>注1：事件运算很多时候可通过画维恩图来表示<br>注2：两个公式都可扩展到多事件的情况</p>
</li>
<li><p><strong>频率与概率</strong><br>频率\(f_n(A)\)：表示事件A发生的次数占试验总次数的比例。<br>$$f_n(A) = \frac {n_A} {n}$$<br>概率\(P(A)\)：当实验次数增加时，频率的稳定值称为概率。<br>$$P(A) = lim_{n \rightarrow \infty} f_n(A)$$</p>
</li>
<li><p><strong>概率的性质</strong><br>对事件A和事件B<br>(1). \(P(B-A) = P(B)-P(AB)\)。若\(A \subset B\)，则有\(P(B-A) = P(B)-P(A)\)<br>(2). \(P(A \cup B) = P(A)+P(B)-P(AB)\)<br>(3). \(P(\bar{A}) = 1-P(A)\)</p>
</li>
<li><p><strong>古典概型</strong><br>两个特征：样本空间S中样本点有限(有限性) &amp; 每一个样本点的概率相等(等可能性)。<br>因此计算概率有：<br>$$P(A) = (A所包含的样本点数)/(S中的样本点总数)$$<br>注1：古典概率只需要计算不同事件对应的样本点个数即可。<br>注2：因为样本点个数有限，所有情况可枚举，因此古典概型经常转化为排列组合的问题求解。</p>
</li>
<li><p><strong>补充排列组合公式</strong><br>排列：$$A_n^m = n(n-1)\cdots(n-m+1)$$<br>组合：$$C_n^m = A_n^m/m!$$<br>$$C_n^m = C_n^{n-m}$$</p>
</li>
<li><p><strong>条件概率</strong><br>P(B|A)表示在事件A发生的前提下，事件B发生的概率。<br>计算方法：\(P(B|A) = \frac {P(AB)} {P(A)} \)，事件A的发生改变了样本空间。<br>注：注意区分P(AB)和P(B|A)，前者是在整个样本空间下计算，是“原始”的概率；后者是在A的样本空间下计算，是“二次影响”后的概率，条件概率即表征一种影响程度。</p>
</li>
<li><p><strong>乘法公式</strong>(计算多个事件同时发生的概率)<br>$$P(AB) = P(A)\cdot P(B|A) = P(B)\cdot P(A|B)$$<br>$$P(ABC) = P(A)\cdot P(B|A)\cdot P(C|AB)$$</p>
</li>
<li><p><strong>全概率公式</strong><br>定义划分：若有<br>(1). \(B_1\cup B_2\cup \cdots\cup B_n = S\)<br>(2). \(B_iB_j = \phi,i\not=j\)<br>则称\(B_1,B_2,\cdots,B_n \)为S的一个划分。<br>计算A事件概率就有：<br>$$P(A) = \sum_{j=1}^n P(AB_j) = \sum_{j=1}^n P(B_j)P(A|B_j)$$<br>公式的直观理解：“由因求果”，B1,B2…代表引起事件A发生的各种原因，因此事件A发生的总概率就是各种原因下发生概率的加和。</p>
</li>
<li><p><strong>贝叶斯公式</strong><br>\(B_1,B_2,\cdots,B_n \)为S的一个划分，<br>$$P(B_i|A) = \frac {P(B_iA)} {P(A)} = \frac {P(A|B_i)P(B_i)} {\sum_{j=1}^n P(A|B_j)P(B_j)}$$<br>P(B)称为先验概率，代表根据以往经验得到的引起某件事发生的原因的概率。<br>P(B|A)称为后验概率，代表<strong>事情已经发生</strong>，求这件事发生是由某个因素引起的可能性的大小。<br><strong>公式的直观理解</strong>：“执果寻因”，观测某事件已经发生，求导致该事件发生的各种原因的概率。<br>影响后验概率的有两个因素，一个是原因本身的概率P(B)，另一个是原因引起结果的概率P(A|B)，只有当各原因引起结果的概率有差别时，贝叶斯公式才有意义，否则计算出的仅仅就是各原因概率的比例而已。两个影响因素对结果的共同作用大，求出的后验概率P(B|A)就会大，这也是符合直观认知的。<br>此外，后验概率还代表着根据实际情况对先验概率的“修正”：通常情况下，依照经验求得的先验概率不会太准确，这时就需从实际中寻找相关事实对其进行修正。<br>更多贝叶斯公式的讲解：<a href="https://www.cnblogs.com/yemanxiaozu/p/7680761.html" target="_blank" rel="noopener">贝叶斯公式的直观理解(先验概率/后验概率)</a></p>
</li>
<li><p><strong>事件的独立性</strong><br><strong>定义</strong>：满足\(P(AB) = P(A)P(B)\)，则称事件A与事件B相互独立。若\(P(A)&gt;0,P(B)&gt;0\)，则有\(P(B|A) = P(B)\)（这个公式理解起来更直观些）。<br><strong>直观理解</strong>：在一次实验中，一个事件的发生不会影响到另一个事件发生的概率。<br><strong>注1</strong>：事件的独立性\(\not=\)互斥性。互斥性指事件不可能同时发生，即\(P(AB)=0\)；独立性指一个事件的发生不会影响到另一个事件发生的概率，即\(P(AB)=P(A)P(B)\)。在维恩图中，互斥事件没有交集，而独立事件则可以有交集，只是交集占B圈的概率与A圈占总体的概率相等罢了。<br><strong>注2</strong>：若多个事件相互独立，则有\(P(ABC) = P(A)P(B)P(C)\)，但注意<br>$$\left.<br>\begin{align}<br>P(AB)=P(A)P(B) \\<br>P(AC)=P(A)P(C) \\<br>P(BC)=P(B)P(C)<br>\end{align}<br>\right\rbrace<br>\not\Rightarrow P(ABC)=P(A)P(B)P(C)$$<br>即两两独立不能推出相互独立，因为相互独立还要求满足\(P(ABC)=P(A)P(BC)\)。</p>
</li>
</ul>
<hr>
<h2 id="第二章-离散型随机变量"><a href="#第二章-离散型随机变量" class="headerlink" title="第二章_离散型随机变量"></a>第二章_离散型随机变量</h2><ul>
<li><p><strong>随机变量</strong><br><strong>定义</strong>：样本空间S，样本点e，若\(X=X(e)\)为定义在S上的实值单值函数，则称\(X(e)\)为随机变量，简写为\(X\)。<br>注1：随机变量虽然叫变量，但实际是一个函数，是样本点到实数的一种映射。<br>注2：引入随机变量的原因，是为了将无法量化的随机事件用具有实际意义的数值来表示，便于量化研究随机现象的规律。如在抛硬币实验中，可将实验结果用“正面出现的次数”来表示。<br>注3：随机变量本质是函数，也要满足函数的性质，可以多个样本点对一个实数值，但不能一对多。<br>注4：随机变量一般用大写字母\(X,Y,Z\)或希腊字母\(\eta,\xi\)来表示，且都将\(X(e)\)简写为\(X\)，直接用\(X\)来表示映射后的实数值。</p>
</li>
<li><p><strong>离散型随机变量</strong><br>若随机变量X的取值为有限个或可数个，则称X为离散型随机变量。<br>“可数”指其中的元素可以被一一数到。(元素数可以是无限个，如整数集、正奇数集等，都是可数的)<br><strong>离散型随机变量的分布律：</strong>所有随机变量对应的概率，叫做分布律。需要满足两个条件：非负性 &amp; 加和为1。<br><strong>三种常见的离散分布：</strong>0-1分布、二项分布、泊松分布、几何分布。</p>
</li>
<li><p><strong>0-1分布</strong><br>若X的分布律满足<br><img src="\images\概率论与数理统计\0-1分布.png" width="200" height="80" align="center"><br>就称X服从参数为p的0-1分布(或两点分布)，即为\(X\sim 0-1(p)\)或\(X\sim B(1,p)\)<br>其分布律可写为：<br>$$P(X=k)=p^k(1-p)^{1-k},k=0,1$$</p>
</li>
<li><p><strong>伯努利实验(Bernoulli)</strong><br>设A是一随机事件，且\(P(A)=p(0&lt; p &lt;1)\)。若仅考虑事件A发生与否，就可定义一个服从参数p的0-1分布的随机变量X：<br>$$ X=\left\{<br>\begin{align}<br>0 &amp; , &amp; 若A发生 \\<br>1 &amp; , &amp; 若A不发生(即\bar{A}发生)<br>\end{align}<br>\right.<br>$$<br>来描述这个随机实验的结果。<br>这种只有两个可能结果的实验，称为伯努利实验。<br>注1：将伯努利实验独立重复地进行n次，就称为n重伯努利实验。<br>注2：设X表示n重伯努利实验中事件A发生的次数，则X的可能取值为0,1,…,n，概率为\(P\{X=k\}=C_n^kp^k(1-p)^{n-k}\)。</p>
</li>
<li><p><strong>二项分布(Binomial)</strong><br>定义：若随机变量X的概率分布律为<br>$$P\{X=k\}=C_n^kp^k(1-p)^{n-k},k=0,1,\cdots,n$$<br>即称X服从参数为n,p的二项分布，记为\(X\sim B(n,p)\)。<br>n代表进行伯努利实验的次数，p代表一次实验中事件A发生的概率。<br>二项分布作用：描述n重伯努利实验中，事件发生的次数。<br>注：0-1分布也是一种特殊的二项分布，即只进行一次伯努利实验。</p>
</li>
<li><p><strong>泊松分布(Poisson)</strong><br>设随机变量\(X\)的取值为0,1,2,…，而取各个值的概率为<br>$$P\{X=k\}=\frac {\lambda^ke^{-\lambda}} {k!},k=0,1,2,…$$<br>其中\(\lambda&gt;0\)且是常数，则称\(X\)服从参数为\(\lambda\)的泊松分布，记为\(X\sim \pi (\lambda)\)<br><strong>证明其满足分布律的两条件：</strong>对于非负性，明显满足；对于加和为1性质，有：<br>$$\sum_{k=0}^\infty P\{X=k\}=\sum_{k=0}^\infty \frac {\lambda^ke^{-\lambda}} {k!}=e^{-\lambda}\sum_{k=0}^\infty \frac {\lambda^k} {k!}=e^{-\lambda}\cdot e^\lambda = 1$$<br><strong>注1</strong>：上式证明所涉及定理：<br>$$e^x=1+x+\frac {x^2} {2!}+\cdots+\frac {x^k} {k!}+\cdots$$<br><strong>注2</strong>：若某事件以固定强度\(\lambda\)，随机且独立地出现，该事件在单位时间内出现的次数可认为服从泊松分布。<br>如公共汽车站到达的乘客数，一本书一页中的印刷错误数等。<br><strong>注3</strong>：不同参数\(\lambda\)的泊松分布概率图，横坐标为k值，纵坐标为概率值<br><img src="\images\概率论与数理统计\泊松分布.jpg" width="343" height="185" align="center"><br>更多泊松分布的解释见：<a href="https://www.zhihu.com/question/26441147" target="_blank" rel="noopener">泊松分布的现实意义是什么？</a><br><strong>注4</strong>：二项分布与泊松分布的近似关系：当\(n&gt;10,p&lt;0.1\)时，<br>$$C_n^k(1-p)^{n-k}\approx \frac {e^{-\lambda}\lambda^k} {k!}, \lambda=np. $$<br>即当\(n\)很大而\(p\)很小，且\(np\)大小适中时，可用泊松分布来近似二项分布。因为\(n\)很大时，二项分布公式中\(C_n^kp^k(1-p)^{n-k}\)计算次方和阶乘会很麻烦，因此用泊松来近似。</p>
</li>
<li><p><strong>几何分布(Geometric)</strong><br>定义：若\(X\)的概率分布律为：<br>$$P(X=k)=p(1-p)^{k-1},k=1,2,3,\cdots$$<br>则称\(X\)服从参数为\(p\)的几何分布，记为\(X\sim Grom(p)\)。<br><strong>用处</strong>：在重复多次的伯努利实验中，实验进行到某种结果出现第一次为止，此时实验总次数服从几何分布。</p>
</li>
</ul>
<hr>
<h2 id="第三章-连续型随机变量"><a href="#第三章-连续型随机变量" class="headerlink" title="第三章_连续型随机变量"></a>第三章_连续型随机变量</h2><ul>
<li><p><strong>分布函数</strong><br>如果随机变量不是离散型的，分布律就无法描述其取值规律了，因此引入分布函数，分布函数对所有类型的随机变量都适用。<br><strong>定义：</strong>随机变量X，对任意实数x，称函数\(F(x)=P(X\le x)\)为X的概率分布函数，简称分布函数。<br><strong>几何意义：</strong>表示X落到\((-\infty , x)\)区间上的概率。<br><img src="\images\概率论与数理统计\分布函数.png" width="400" height="60" align="center"><br><strong>如何表示落到任意区间的概率：</strong><br>$$ \begin{align}<br>P(a&lt;X\le b) &amp;=P(X\le b)-P(X\le a) \\<br>&amp;=F(b)-F(a)<br>\end{align}<br>$$</p>
</li>
<li><p><strong>概率密度</strong><br>对于随机变量\(X\)的分布函数\(F(X)\)，若存在非负函数\(f(x)\)，使对于任意实数\(x\)有：<br>$$F(x)=\int_{-\infty}^x f(t)dt$$<br>则称\(X\)为<strong>连续型随机变量</strong>，其中\(f(x)\)称为\(X\)的概率密度函数，简称<strong>概率密度</strong>。</p>
</li>
<li><p><strong>概率密度的性质</strong><br><strong>性质1：</strong>\(f(x)\ge 0\)<br><strong>性质2：</strong>\(\int_{-\infty}^{+\infty} f(x)dx=F(+\infty)=1 \)<br><strong>性质3：</strong>概率密度函数的面积值表示概率（分布函数是y值表示概率）<br>$$P(x_1 &lt; X\le x_2)=\int_{x_1}^{x_2} f(t)dt$$<br><img src="\images\概率论与数理统计\概率密度1.png" width="220" height="140" align="center"><br>因此当\(x_1,x_2\)重合的时候，面积为0，概率也为0，因此连续型随机变量中任意<strong>单点概率</strong>都为0，但并非是不可能事件，即不可能事件\(\Rightarrow\)概率为0，概率为0\(\not\Rightarrow\)不可能事件。<br><strong>性质4：</strong>若\(f(x)\)在点\(x\)连续，则有\(f(x)=F’(x)\)。<br>$$\begin{align}<br>&amp;f(x)=F’(x)=\lim_{\Delta x \rightarrow 0} \frac {F(x+\Delta x)-F(x)} {\Delta x}=\lim_{\Delta x\rightarrow 0} \frac {P(x&lt;X\le x+\Delta x)} {\Delta x}&amp;\\<br>\\<br>&amp;P(x&lt;X\le x+\Delta x)\approx f(x)\cdot \Delta x<br>\end{align}$$<br>表明\(X\)落在点\(x\)邻域附近的概率近似等于\(f(x)\cdot \Delta x\)</p>
</li>
<li><p><strong>对性质4的说明：</strong>下图是某概率密度函数<br><img src="\images\概率论与数理统计\概率密度2.png" width="250" height="120" align="center"><br>图中\(f(x_2)&lt;f(x_1)\)，但这并不表明\(x_1\)点的概率比\(x_2\)点的概率大(单点概率都为0)，其表明\(f(x_2)\cdot \Delta x&lt;f(x_1)\cdot \Delta x\)，即\(X\)落在\(x_1\)附近的概率比落在\(x_2\)附近的概率大。同理，在此图中，\(X\)落在\(0\)附近的概率是最大的。</p>
</li>
<li><p><strong>均匀分布(Uniform)</strong><br>若\(X\)的概率密度函数为<br>$$f(x)=<br>\left\{<br>  \begin{align}<br>  &amp;\frac {1} {b-a},&amp;x\in (a,b)\\<br>  &amp;0,&amp;其他<br>  \end{align}<br>\right.<br>$$<br>就称\(X\)服从\((a,b)\)上的均匀分布，记为\(X\sim U(a,b)\)。<br>概率密度函数图如下：<br><img src="\images\概率论与数理统计\均匀分布.png" width="280" height="140" align="center"><br><strong>注1：</strong>均匀分布的直观理解就是“均匀”的，具有等可能性，即对于任意的\(a&lt;k&lt;k+l&lt;b\)，有<br>$$P(k&lt; X&lt; k+l)=\int_{k}^{k+l} \frac {1} {b-a}dt=\frac {l} {b-a} $$<br>\(X\)落入\((a,b)\)中任意子区间上的概率，只与区间<strong>长度</strong>有关，与区间位置无关。<br><strong>注2：</strong>均匀分布的分布函数为：<br>$$F(x)=<br>\left\{<br>  \begin{align}<br>  &amp;0, &amp;x&lt; a;\\<br>  &amp;\frac {x-a} {b-a}, &amp;a\le x&lt; b;\\<br>  &amp;1, &amp;x\ge b.<br>  \end{align}<br>\right.<br>$$<br>图像如下所示：<br><img src="\images\概率论与数理统计\均匀分布2.png" width="217" height="134" align="center"></p>
</li>
<li><p><strong>指数分布</strong></p>
</li>
<li><p><strong>高斯分布</strong></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/06/25/概率论与数理统计笔记/" data-id="cjmmeykxv000yd5qxnjup2bso" class="article-share-link" data-share="baidu" data-title="概率论与数理统计笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/06/25/概率论与数理统计笔记/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MachineLearning/">MachineLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Network/计算机网络1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/28/Network/计算机网络1/" class="article-date">
  <time datetime="2018-05-28T07:14:00.000Z" itemprop="datePublished">2018-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/28/Network/计算机网络1/">计算机网络笔记（第一部分）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><br>本篇笔记主要包括概述、物理层和数据链路层这三章的内容。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><strong>三类网络</strong><br>电信网络：向用户提供电话、电报、传真等服务；<br>有限电视网络：向用户传送各种电视节目；<br>计算机网络：使用户可以在计算机之间传数据，由若干<strong>结点(node)</strong>和连接这些结点的<strong>链路(link)</strong>组成。<br>注：三类网络中起到核心作用是计算机网络，且有相互融合的趋势，即所谓的“三网融合”的概念。</li>
</ul>
<h3 id="互联网基本概念"><a href="#互联网基本概念" class="headerlink" title="互联网基本概念"></a>互联网基本概念</h3><h4 id="Internet的含义"><a href="#Internet的含义" class="headerlink" title="Internet的含义"></a>Internet的含义</h4><p>Internet指当前全球最大的、由众多网络相互连接而成的特定计算机网络，采用TCP/IP协议族作为通信规则，前身是美国的ARPANET。我们生活中的“上网”，即是指将某个电子设备连接到Internet。而关于Internet的译名，有以下两种：<br><strong>因特网：</strong>这是全国科学技术名词审定委员会推荐的译名，虽然准确，但未被广泛使用；<br><strong>互联网：</strong>使用最广泛的Internet译名，也更能体现出Internet的主要特征（连通性），因此《计算机网络》一书第七版之后都采用了这个译名，本笔记也是采用这种译名。<br>注1：Internet是计算机网络的代表，但并不等于计算机网络(还有很多其他类型的网络)。<br>注2：Internet相当于是“网络的网络”，其将全球众多的计算机网络相互连接起来。<br>注3：小写的internet，指“互连网”，任意将若干计算机网络连接起来，可以通信就行；而大写的Internet是专有名词，特指全球最大的那个“互联网”。</p>
<h4 id="互联网的架构"><a href="#互联网的架构" class="headerlink" title="互联网的架构"></a>互联网的架构</h4><p>当前互联网是<strong>多层次ISP</strong>的架构，ISP(Internet Service Provider)为互联网服务提供商，负责建造通信线路，从互联网管理机构申请IP地址并分配给用户，分为主干ISP、地区ISP和本地ISP（移动、联通、电信即国内三大主干ISP）。示意图如下：<br><img src="/images/计算机网络/ISP架构.png" width="500" height="250" alt="多层次ISP架构示意图" align="center"><br><strong>IXP：</strong>为了提升网络传输速率，出现了互联网交换点IXP(Internet eXchange Point)，使用数据链路层的网络交换机来实现。其主要作用是允许两个网络直接相连传输数据，而无需再通过ISP转发（如上图两个地区ISP之间的IXP），这样可使得互联网的数据流量分布更合理，减少传输时延。</p>
<h4 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h4><p>虽然互联网的拓扑结构非常复杂，但总体可以分为两大块：<br><strong>边缘部分：</strong>由所有连接在互联网上的主机(host)组成，这部分是用户可以直接接触到的，用来进行数据传输。<br><strong>核心部分：</strong>由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的。<br><strong>边缘部分主机的通信方式：</strong>可分为两大类：客户-服务器方式(C/S方式)和点对点方式（P2P方式）。<br>C/S方式中，客户端是服务请求方，主动向服务器发起通信，因此必须知道服务端的地址；而服务端是服务提供方，被动地等待各地的客户端的请求，因此服务端无需知道客户端的地址。<br>P2P方式中，只要两台主机都运行了对等连接软件（P2P软件），它们就可以平等地进行通信，没有客户端和服务端的区分，也可理解为每台主机既是客户端也是服务端。</p>
<h4 id="互联网核心部分的数据交换方式"><a href="#互联网核心部分的数据交换方式" class="headerlink" title="互联网核心部分的数据交换方式"></a>互联网核心部分的数据交换方式</h4><p>互联网核心部分主要作用是交换、传输数据，有三种交换方式。<br><strong>电路交换：</strong>电话的连接方式，两台电话要进行通信，必须经过“建立连接（占用通信资源）-&gt;通话（一直占用通信资源）-&gt;释放连接（归还通信资源）”三个阶段，两台电话间会建立一条专用的物理线路，通信时会一直占用，通信线路的利用较低。<br><strong>报文交换：</strong>运用了存储转发的原理，整个数据报文先传送到相邻结点，全部存储下来后查找转发表，再转发到下一个结点。<br><strong>分组交换：</strong>同样运用了存储转发(stroe and forward)的原理，将数据报文分成多个小的分组，每个分组在首部加上必要的控制信息，单独地在互联网中进行传输。当路由器收到一个分组后，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去(路由算法得出)，把分组交给下一个路由器，分组就这样一步步地到达目的地。<br><img src="/images/计算机网络/数据交换方式.png" width="500" height="350" alt="三种数据交换方式" align="center"></p>
<ul>
<li><strong>三种交换方式的比较：</strong><br>1、对于电路交换，是整个比特流连续地从原点直达终点，因此需要建立专用传输线路，如果要传送大量连续数据（传送时间远大于连接建立时间），则电路交换的效率较高；<br>2、对于报文交换和分组交换，不需要预先分配传输资源，因此非常适合传输计算机网络这种<strong>突发性</strong>的数据。另外报文传输是直接传输整个报文，因此时延比分组交换大，且如果报文中出了一点错，整个报文都要重传，开销会很大。<br>3、分组交换的优点：高效，对通信线路是<strong>逐段</strong>占用的，可以充分利用通信资源；灵活，每一个分组都可选择最适合的路由线路进行转发；可靠，当链路中某一结点出现故障，路由算法会自动选择合适的线路。<br>4、分组交换的缺点：使用存储转发(stroe and forward)的方式，分组在各个路由结点会有排队问题，产生一定的时延；分组必须携带的首部会产生一定的开销。</li>
</ul>
<h3 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h3><p><strong>按网络的作用范围分：</strong><br>    广域网WAN(Wide Area Network)：作用范围为几十到几千公里；<br>    城域网MAN(Metropolitan Area Networl)：城域网的作用范围一般是一个城市；<br>    局域网LAN(Local Area Network)：局域网在地理上局限在较小的范围内(1km左右)；<br>    个人区域网PAN(Personal Area Network)：在个人工作的地方把个人使用的电子设备（如笔记本电脑）用无线技术连接起来，如蓝牙技术。<br><strong>按网络使用者分：</strong><br>    分为公用网(public network)和专用网(private network)。<br><strong>用来把用户加入到互联网的网络：</strong><br>    这种网络叫接入网AN(Access Network)，处于从用户到互联网中第一个路由器之间的一种网络。在互联网初期，用户用电话线拨号接入互联网，速率很低，目前使用了接入网技术来连接，速率了有很大的提升。</p>
<h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><p><strong>速率：</strong>指比特率(bit/s)，并非Byte，而且多指<strong>额定速率</strong>。<br><strong>带宽：</strong>传统的带宽指的是频带宽度，单位是HZ。而在计算机网络中，带宽指网络的<strong>最高发送速率</strong>。<br><strong>吞吐量：</strong>单位时间内通过网络的实际数据量，指<strong>实际速率</strong>。<br>注：在存储领域，1k=1024；而在通信领域，1k=1000。<br><strong>往返时间：</strong>往返时间RTT(Round-Trip Time)表示双向交互一次所需要的时间。<br><strong>信道利用率：</strong>指信道有多长时间是被利用的（有数据通过），空闲的信道利用率为0。注：信道利用率并非越大越好，利用率增大，时延也会增加。</p>
<h4 id="网络时延"><a href="#网络时延" class="headerlink" title="网络时延"></a>网络时延</h4><p>时延是指数据从网络的一端传送到另一端所花费的时间，网络时延由以下几部分组成：<br><strong>发送时延：</strong>主机或路由器发送数据帧所花费的时间，发生在网卡中。$$发送时延=\frac {数据帧长度(bit)} {发送速率(bit/s)}$$<br><strong>传播时延：</strong>电磁波在信道中传播所花费的时间，发生在信道中。$$传播时延=\frac {信道长度(m)} {电磁波在信道中的传播速率(m/s)}$$<br>信号传播速率与信道有很大关系，如光纤、铜线等等。<br><strong>处理时延：</strong>在交换结点分组转发所需的时间，如分析首部、进行差错检验等，没有具体的计算公式。<br><strong>排队时延：</strong>分组在路由器的缓存队列中排队等待的时间，同样没有具体的计算公式。<br>因此网络总时延就是以上四种时延之和：$$总时延=发送时延+传播时延+处理时延+排队时延$$<br>注：高速网络链路，提高的是发送速率(带宽)，并不能提高传输速率。如我们所说的光纤传输速率高，是指可以用很高的速率向光纤信道发送数据，而光纤信道的传播速率实际上比铜线还要低。<br><img src="/images/计算机网络/时延.png" width="500" height="200" alt="四种时延产生的地方不一样" align="center"><br><strong>时延带宽积：</strong>时延带宽积=传播时延 X 带宽，如时延带宽积为\(2\times 10^5bit\)，相当于当发送的第一个比特到达终点时，发送端已经发送了20万个比特，而这20万个比特都未还在传输过程中，因此时延带宽积也表示从发送端发出的但尚未到达接收端的比特数。</p>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>无论哪种网络体系结构，都采用了“分层”的思想，目前主要有两种体系：OSI和TCP/IP，OSI非常权威，但因为过于复杂，更多被当作一种理论参考，工程上未广泛应用；运用最广泛的是TCP/IP协议，也是事实上的“国际标准”。OSI协议为7层，TCP/IP协议有4层，谢书中采用的是两者的结合版，即一种5层的网络结构。<br><img src="/images/计算机网络/网络体系结构.png" width="500" height="250" alt="三种网络体系结构" align="center"></p>
<ul>
<li><strong>五层协议结构</strong><br><strong>应用层：</strong>应用层协议定义的是<strong>进程</strong>间的交互规则，因为主机间通信的本质是主机上进程的通信（进程即为正在运行的程序）。具体的应用层协议有DNS、HTTP等。应用层数据单位：<strong>报文</strong>(message)。<br><strong>运输层：</strong>运输层负责为主机进程间的通信提供通用的数据传输服务，目前主要有两种协议：传输控制协议TCP和用户数据报协议UDP，TCP提供面向连接、可靠的数据传输服务，UDP提供无连接的、尽最大努力的数据传输服务。运输层数据单位：TCP为<strong>报文段</strong>(segment)，UDP为<strong>用户数据报</strong>。<br><strong>网络层：</strong>网络层负责分组交换网的数据传输服务，使用IP协议。与运输层的不同在于：运输层针对互联网的边缘部分，网络层针对互联网的核心部分，路由器在转发时最高就涉及到网络层，不涉及运输层和应用层。网络层数据单位：<strong>IP数据报</strong>（就是之前所说的分组）。<br><strong>数据链路层：</strong>数据链路层负责分组交换网中相邻结点的数据传输，与网络层的不同在于：网络层是源结点到目的结点(中间可能有多个结点)，而数据链路层是相邻结点。数据链路层数据单位：<strong>帧</strong>(framing)。<br><strong>物理层：</strong>负责物理硬件层面的数据传输，物理层数据单位：<strong>比特</strong>(bit)。<br>注：数据从上层到下层需要加首部，加上相关控制信息。另外，从网络层-&gt;链路层还要加尾部（做差错校验的工作）。<br><img src="/images/计算机网络/五层体系结构.png" width="350" height="200" alt="数据在各层的变化" align="center"></li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul>
<li><p><strong>物理层的主要任务</strong><br>物理层研究的是如何在各种传输媒体上传输比特流，如各个物理接口的尺寸、接口电缆上电压的范围、各种编码方式等，而不是具体的传输媒体（这属于通信领域的范畴）。</p>
</li>
<li><p><strong>物理层传输媒介</strong><br>导引型(有线)：双绞线、同轴电缆、光纤<br>非导引型(无线)：自由空间</p>
</li>
</ul>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><ul>
<li><strong>信道的基本概念</strong><br>信道指向某一个方向传送信息的媒体，是<strong>单向</strong>的，因此一条通信线路往往包含一条发送信道和一条接收信道。<br>单工通信（单向通信）：只能有一个方向通信，如收音机。<br>半双工通信（双向交替通信）：通信双方都可以发送信息，但不能同时发送，如对讲机。<br>全双工通信（双向同时通信）：通信双方可以同时发送/接收信息。<br>注：单工通信只需一条信道，半双工和全双工通信需要两条信道。</li>
</ul>
<h4 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h4><p>为什么要进行调制：来自信源的信号不适合进行长距离传输。<br><strong>基带调制：</strong>数字信号-&gt;另一种数字信号（没有变为模拟信号），也称为编码。具体有如下几种：<br>不归零编码：正电平代表1，负电平代表0。<br>归零编码：正脉冲代表1，负脉冲代表0。<br>曼彻斯特编码：位周期中心向上跳变代表0，位周期中心向下跳变代表1。<br>差分曼彻斯特编码：位开始边界有跳变代表0，位开始边界没有跳变代表1。<br><strong>带通调制：</strong>数字信号-&gt;模拟信号（加到载波上）。具体有如下几种：<br>调幅(AM)：载波的振幅随基带数字信号变化。<br>调频(FM)：载波的频率随基带数字信号变化。<br>调相(PM)：载波的初始相位随基带数字信号变化。</p>
<h4 id="信道的极限传输速率"><a href="#信道的极限传输速率" class="headerlink" title="信道的极限传输速率"></a>信道的极限传输速率</h4><p>如何提高数据在信道上的传输速率是一个被广泛关注的问题，大致可从以下几个方面来考虑：<br><strong>信道能通过的频率范围：</strong>由奈氏准则可知，在任何信道中，码元传输的速率都是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，因此可通过拓宽频带，来提高码元传输速率的上限。奈氏准则公式：$$极限波特率(baud/s)=2W\times log_2n$$<br>\(W\)为频带宽度，\(n\)为一个码元可表示几种值，\(log_2n\)即为一个码元携带的信息量。注意区分码元和比特的区别，1码元可以由多个bit位表示。<br><strong>信噪比：</strong>$$信噪比(dB)=10\times log_{10}(S/N)$$<br>\(S\)为信号的平均功率，\(N\)为噪声的平均功率。<br><strong>香农公式：</strong>信道的极限信息传输速率C为：$$C=W\times log_2(1+S/N)$$<br>C为比特率bit/s，W为信道的带宽(Hz)。由公式可知，信道带宽越大，信噪比越高，信息的极限传输速率就越高。<br><strong>比特率和波特率换算：</strong>$$比特率(bit/s)=波特率(baud/s)\times 码元信息量$$ $$码元信息量=log_2n$$<br>\(n\)为一个码元可表示几种值。奈氏准则的具体表示？奈氏准则和香农公式的换算？</p>
<h4 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h4><p>频分复用(FDM)：在同一时间占用不同的频带资源。<br>时分复用(TDM)：在不同时间占用相同的频带资源，类似时间片轮转。<br>统计时分复用(STDM)：与TDM的不同在于，其并非固定顺序分配时间，而是按需动态分配。<br>波分复用(WDM)：光的频分复用，用一根光纤同时传输多个光载波信号。<br>码分多址(CDMA)：具体介绍如下。</p>
<h4 id="码分多址-CDMA"><a href="#码分多址-CDMA" class="headerlink" title="码分多址(CDMA)"></a>码分多址(CDMA)</h4><p>各个用户使用经过挑选的不同码型，相互之间不会造成干扰，因此用户可在同一时间使用同样的频带进行通信。具体原理如下：<br><strong>码片：</strong>在CDMA中，每个用户被分配一个m位的码片序列(由+1和-1组成)，用户若要发送比特1，则直接发送这个m位码片序列；若要发送0，则发送该码片序列的反码。如码片序列为(-1-1-1+1+1-1+1+1)，则1对应的就是(-1-1-1+1+1-1+1+1)，0对应的就是(+1+1+1-1-1+1-1-1)，这个m位序列才是最终的发送结果。<br><strong>码片正交：</strong>码片的一个重要特点是，各个用户所分配的码片是正交的，如S代表某用户的码片，T代表其他用户的码片，两个码片正交，则有：<br>$$S\cdot T = \frac {1} {m} \sum_{i=1}^m S_iT_i=0$$<br>即两码片按位相乘最后结果为0。<br><strong>信号处理：</strong>不同用户码片合到一起发出去，若想从中分离出用户X的信号，则首先拿到X的码片，和收到的信号做内积运算(按位乘法)，结果为1：比特为1，结果为-1：比特为0，结果为0：其他用户的信号。按照这个方法即可把其他用户的信号剔除掉。</p>
<h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><p>用户要连接到互联网，必须先连接到ISP，以便获得上网所需的IP地址，因此即出现了宽带接入技术。我国之前多采用电话线+调制解调器(Modern，猫)的方式拨号上网，因速度有限而被逐渐淘汰，目前主流宽带接入方式的有三种。<br><strong>ADSL技术：</strong>ADSL(Asymmetric Digital Subscriber Line)，非对称数字用户线路，可直接利用原有的电话线路，无需从新布线，用户使用专门的Modern即可上网，且为电信专线，网速较稳定。<br><strong>光纤同轴混合网(HFC网)：</strong>基于有线电视网开发的宽带接入网，在传送电视节目的同时提供宽带服务。将原先有线电视网中的同轴电缆主干部分改换为光纤，一直延申到相应光纤结点后，光信号转换为电信号，再通过同轴电缆将信号传送到用户家庭。要使现有的模拟计算机能够接收数字电视信号，需要使用一个称为<strong>机顶盒(set-top box)</strong>的设备，同时机顶盒大多内嵌了一个叫电缆调制解调器的设备，通过此设备用户即可接入宽带。<br><strong>FTTx技术：</strong>最理想的宽带接入方式是<strong>光纤到户</strong>FTTH(Fiber To The Home)，将光纤一直铺设到用户家庭，只有在光纤进入家门后，才把光信号转换为电信号，这样做就可使用户获得最高的上网速率。但限于价格和用户需求等问题，光纤到户目前还未被广泛使用，但其衍生出了很多宽带光纤接入方式，称为<strong>FTTx</strong>，即Fiber To The…，x代表不同的光纤接入地点，即光电转换的地方。目前大中城市较普及的是光纤接入到楼（FTTB）或小区（FTTZ），再通过网线接入用户家，从而为整幢楼或小区提供共享带宽。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul>
<li><p><strong>数据链路层两种信道类型</strong><br>点对点信道：点对点通信方式（一对一），最常用的协议是PPP协议，多用于住宅主机的拨号上网。<br>广播信道：广播通信方式（一对多），因为主机数较多，必须用专用的共享信道协议(CSMA/CD)来协调主机间的数据发送，多用于<strong>局域网</strong>。</p>
</li>
<li><p><strong>链路和数据链路</strong><br>链路：无源的点到点的物理线路段，中间没有任何其他的交换结点。<br>数据链路：物理链路+通信协议，即硬件+软件。</p>
</li>
</ul>
<h3 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h3><ol>
<li>封装成帧(framing)</li>
<li>透明传输</li>
<li>差错检测</li>
</ol>
<h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>概念：在一段数据的前后分别添加首部和尾部，就构成了一个帧。首部和尾部的作用是进行<strong>帧定界</strong>，即确定帧的开始和结束。<br>具体实现：用控制字符完成帧定界，将控制字符SOH(Start Of Header)放在帧的首部表示帧的开始，将控制字符EOT(End Of Transmission)表示帧的结束。<br><img src="/images/计算机网络/帧首部和帧尾部.png" width="470" height="100" alt="帧首部和帧尾部" align="center"></p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>“封装成帧”的问题：如果数据中的某个字节的二进制代码恰好和SOH或EOT一样，帧就会错误地开始或结束。因此要对帧的数据部分出现的控制字符进行处理。<br>处理方法：字符填充(也称字节填充)，在帧数据部分的SOH/EOT前插入一个转义字符，这样接收时就不会把其当作控制字符来处理（防止帧提前结束掉），最后在数据送向网络层时删去转义字符即可。<br>注：如果转义字符也出现在数据当中，就在转义字符前也加一个转义字符。<br><img src="/images/计算机网络/字符填充.png" width="470" height="100" align="center"></p>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>问题背景：数据传输中可能会产生比特差错：1变成0或0变成1，因此要采用差错检测措施。<br><strong>循环冗余码CRC：</strong>重点！具体算法见《计算机网络》P74<br>注1：使用循环冗余码只能做到<strong>无比特差错</strong>，但还做不到可靠传输（CRC只能做到接受的帧都没有错误）。<br>注2：可靠传输包括两部分：无比特差错 &amp; 无传输差错。传输差错指帧丢失、帧重复和帧失序，要做到无传输差错，则必须要有确认和重传机制（由上层协议完成）。</p>
<h3 id="MAC层"><a href="#MAC层" class="headerlink" title="MAC层"></a>MAC层</h3><p>为了制订一个通用的协议模型，IEEE802委员会将数据链路层又拆分成了两个子层：<br>介质访问控制子层(MAC)：MAC层，负责与传输介质相关的部分，将相关操作封装好共LLC透明调用。<br>逻辑链路控制子层(LLC)：LLC层，负责逻辑控制，与传输介质无关，不管采用何种协议对LLC层都是<strong>透明</strong>的。</p>
<h4 id="MAC层地址"><a href="#MAC层地址" class="headerlink" title="MAC层地址"></a>MAC层地址</h4><p>在局域网中，每个网络适配器（网卡）都会有一个唯一的硬件地址，称为MAC地址。<br>MAC地址位数是48位，高24位为IEEE向网卡厂商分配，低24位为厂商自行指派。<br>在局域网外部传输，使用IP地址查找主机；进入局域网后，即是查找MAC地址。<br><img src="/images/计算机网络/IP地址和MAC地址关系.png" width="330" height="70" alt="IP地址和MAC地址关系" align="center"></p>
<h4 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h4><p><img src="/images/计算机网络/MAC帧格式.png" width="470" height="100" alt="MAC帧格式" align="center"><br>MAC帧数据部分长度范围：46-1500。<br>整个MAC帧长度范围：64-1518，首部和尾部总共18字节。<br><strong>最大传送单元MTU：</strong>指MAC帧中数据部分的最大长度，为1500。</p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul>
<li><p><strong>局域网和以太网的区别</strong><br>以太网是一种局域网，而局域网却不一定是以太网，只是由于目前大多数的局域网是以太网，所以一般说局域网，大家都默认为以太网。<br>所谓以太网，是一种<strong>总线型局域网</strong>，局域网的拓扑结构有很多实现方式，还有有星型、环形等，但目前应用最广泛的局域网标准还是以太网。</p>
</li>
<li><p><strong>以太网的通信特点</strong></p>
<ol>
<li>和其他种类局域网中的传播方式相同，采用广播的方式。</li>
<li>无连接的工作方式，也没有确认和重传机制，因为局域网的通信质量较好，发生错误的几率较小。</li>
<li>收到有差错的数据帧就丢弃，但不做纠错，纠错工作交给上层协议。因此以太网提供的服务是不可靠的交付。</li>
<li>发送的数据使用的是曼彻斯特编码，位周期中心向上跳变代表0，位周期中心向下跳变代表1 </li>
</ol>
</li>
</ul>
<h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p>定义：载波监听多点接入/碰撞检测(Carrier Sense Multiple Access with Collision Detection) ，是以太网上的一种通信协议。<br>多点接入：一根总线上解入多个计算机。<br>载波监听：指发送数据之前要先检测总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。<br>碰撞检测：检测信道上数据是否发生了碰撞。若发生碰撞，信号就会产生严重的失真，因此一旦检测出碰撞，计算机就会立即停止发送数据，等待一段随机时间后再重新发送。<br>而且也因为信号会发生碰撞，所以以太网只能进行<strong>半双工</strong>通信，而不能全双工。</p>
<h4 id="CSMA-CD中的碰撞检测"><a href="#CSMA-CD中的碰撞检测" class="headerlink" title="CSMA/CD中的碰撞检测"></a>CSMA/CD中的碰撞检测</h4><p>因为电磁波在信道上传播的速率是有限的，因此当监听到总线是空闲的时，总线可能并非真正的空闲（对方的信号正在信道上传输，还没传过来），因此不仅是在发数据前要检测碰撞，在发送数据的期间也要进行检测。<br><img src="/images/计算机网络/碰撞检测过程.png" width="470" height="100" alt="碰撞检测的过程" align="center"><br>由图可知，先发送数据的计算机，在发送后至多经过\(2\tau\)时间（两倍的端到端往返时延），就可知道发送的数据帧是否遭受了碰撞。<br>所以\(2\tau\)就称为争用期，只有经过争用期这段时间还没有检测到碰撞，才能肯定此次发送不会发生碰撞。<br>以太网取\(51.2\mu s\)为争用期长度，对于10Mbit/s以太网，在争用期内可发送 512 bit，即64字节。因此若发生冲突，一定是在发送的前64字节之内。<br>所以以太网规定<strong>最短有效帧长</strong>为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。</p>
<h4 id="二进制指数退避算法"><a href="#二进制指数退避算法" class="headerlink" title="二进制指数退避算法"></a>二进制指数退避算法</h4><p>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。<br>基本的退避时间为\(2\tau\)，之后从集合\([0, 1, … , (2^k-1)]\)中随机取一个数，记为r，重传所需的时延就是r倍的基本退避时间。<br>参数\(k\)的计算：\(k=Min[重传次数, 10]\)。<br>当重传达16次仍不能成功时即丢弃该帧，并向上层报告。 </p>
<ul>
<li><strong>强化碰撞</strong><br>检测到碰撞后，立即停止发送数据，之后继续发送若干比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。</li>
</ul>
<h4 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h4><p>集线器：用集线器将多个碰撞域组合成一个碰撞域。<br>网桥：用网桥将各网段隔离为单独的碰撞域，网桥工作在数据链路层，其根据MAC地址对收到的帧进行转发。<br>以太网交换机：相当于多接口网桥。</p>
<ul>
<li><strong>连接不同网络的中间设备</strong><br>物理层：集线器Hub，会扩大碰撞域，而且没法抑制广播风暴。<br>数据链路层：交换机。<br>网络层：路由器，由于历史的原因，许多有关 TCP/IP 的文献将网络层使用的路由器称为网关。<br>交换机和路由器的不同：交换机连接的是主机，路由器连接的是网络。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/05/28/Network/计算机网络1/" data-id="cjmmeykyf001id5qxkm1i6ubn" class="article-share-link" data-share="baidu" data-title="计算机网络笔记（第一部分）">Share</a>
      

      
        <a href="http://yoursite.com/2018/05/28/Network/计算机网络1/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Network/计算机网络2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/28/Network/计算机网络2/" class="article-date">
  <time datetime="2018-05-28T07:13:00.000Z" itemprop="datePublished">2018-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/28/Network/计算机网络2/">计算机网络笔记（第二部分）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><br>本笔记是基于学校所教授的课程和谢希仁《计算机网络》(第七版)整理的，包括概述、物理层和数据链路层这三章的内容。</p>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><ul>
<li><p><strong>网络层的主要任务</strong><br>网络层承担着主机找主机的任务(跨越多个链路节点)，向运输层提供无连接的、尽最大努力交付的数据报服务。<br>网络层及以下提供的都是无连接、不可靠的传输服务，通信的可靠性由运输层来保证。<br>因此网络层中的路由器可以做得比较简单，大大降低了网络造价。<br>本章主要包括IP及其配套协议、路由选择协议两大块内容。</p>
</li>
<li><p><strong>网际协议IP</strong><br>网际协议IP是TCP/IP体系中两个最主要的协议之一，与IP协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP(Address Resolution Protocol)</li>
<li>网际控制报文协议 ICMP(Internet Control Message Protocol)</li>
<li>网际组管理协议 IGMP(Internet Group Management Protocol)</li>
</ul>
</li>
<li><p><strong>IP地址及其编址方法</strong><br>IP地址概念：为每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的32位的标识符。<br>IP地址三种编址方法：分类IP地址、划分子网、构成超网。</p>
</li>
<li><p><strong>分类IP地址</strong><br>将IP地址划分为若干类，每一类IP地址都由<strong>网络号</strong>(net-id)和<strong>主机号</strong>(host-id)两部分组成，网络号标志着所连接到的网络，主机号即标志着主机，同一个网络中的主机网络号都相等。<br><img src="/images/计算机网络/各类IP地址.png" width="400" height="290" alt="各类IP地址" align="center"><br>整个IP地址采用点分十进制表示法，每８位为一组。<br><strong>常用的三类IP地址：</strong><br>A类地址，网络数\(2^7-2\)，0号表示“本网络”，127号作测试用；主机数\(2^{24}-2\)，扣除全0和全1的主机号，全0表示网络地址，比如一台主机的IP地址为5.6.7.8，那么该主机所在的网络地址就是5.0.0.0；全1表示表示该网络上的所有主机，多在广播时使用。<br>B类地址，网络数\(2^{14}-1\)，保留128.0.0.0，不指派；主机数\(2^{16}-2\)，扣除全0和全1。<br>C类地址，网络数\(2^{21}-1\)，保留192.0.0.0，不指派；主机数\(2^8-2\)，扣除全0和全1。<br><img src="/images/计算机网络/IP地址的指派范围.png" width="400" height="160" alt="IP地址的指派范围" align="center"><br><strong>IP地址的重要特性：</strong></p>
<ul>
<li>路由器转发分组时仅依据目的主机所连接的网络号，不考虑主机号，这样做可大大减少路由表的大小。</li>
<li>IP地址实质是标志主机/路由器和链路的接口，因此当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址。由于一个路由器至少应当连接两个网络，因此一个路由器至少有两个IP地址。 </li>
</ul>
</li>
<li><p><strong>IP地址和硬件地址</strong><br>硬件地址：即MAC地址，数据链路层和物理层使用的地址。<br>IP地址：网络层和以上各层使用的地址，是一种逻辑地址（称IP地址是逻辑地址是因为IP地址是用软件实现的）。<br><img src="/images/计算机网络/IP地址和硬件地址.png" width="400" height="160" alt="IP地址和硬件地址" align="center"><br>注：路由器是根据目的主机的IP地址进行转发的，因此路由器的IP地址并不会出现在IP数据报中，路由器之间使用的是MAC地址。</p>
</li>
<li><p><strong>地址解析协议ARP</strong><br>作用：将IP地址解析为MAC地址。<br>ARP Cache：ARP高速缓存，存储IP地址和MAC地址的映射关系。<br>当主机A欲向同一局域网中某个主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的MAC地址。<br>如有，就将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发往此硬件地址。<br>如没有，主机A就在本局域网上广播发送一个ARP请求分组。收到ARP响应分组后，将B的硬件地址写入其ARP高速缓存中，再发送数据。<br>注1：注意解析是单向的，并不能由MAC地址解析到IP地址。<br>注2：解析只能在同一个局域网中进行，不同的局域网要先通过路由器把IP数据报发到下一个网络，由下一个网络再查找。</p>
</li>
<li><p><strong>IP数据报格式</strong><br>IP数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。<br>首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。在固定部分的后面是一些可选字段，其长度是可变的，不经常使用。<br><img src="/images/计算机网络/IP数据报格式.png" width="500" height="300" alt="IP数据报格式" align="center"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>字段名称&nbsp;&nbsp;&nbsp;</th>
<th>位数&nbsp;&nbsp;&nbsp;</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本&nbsp;&nbsp;&nbsp;</td>
<td>4&nbsp;&nbsp;&nbsp;</td>
<td>IP协议的版本，大部分为IPv4</td>
</tr>
<tr>
<td>首部长度&nbsp;&nbsp;&nbsp;</td>
<td>4&nbsp;&nbsp;&nbsp;</td>
<td>固定部分+可变部分的总长度，一个单位为4字节，因此首部最长为15*4=60字节</td>
</tr>
<tr>
<td>区分服务&nbsp;&nbsp;&nbsp;</td>
<td>8&nbsp;&nbsp;&nbsp;</td>
<td>一般不使用</td>
</tr>
<tr>
<td>总长度&nbsp;&nbsp;&nbsp;</td>
<td>16&nbsp;&nbsp;&nbsp;</td>
<td>首部+数据部分总长度，最大为65535字节</td>
</tr>
<tr>
<td>标识&nbsp;&nbsp;&nbsp;</td>
<td>16&nbsp;&nbsp;&nbsp;</td>
<td>标识一个IP数据报</td>
</tr>
<tr>
<td>标志&nbsp;&nbsp;&nbsp;</td>
<td>3&nbsp;&nbsp;&nbsp;</td>
<td>只有前两位有意义，第一位是MF(MF=1，后面还有分片；MF=0，最后一个分片)，第二位是DF(DF=0才允许分片)</td>
</tr>
<tr>
<td>片偏移&nbsp;&nbsp;&nbsp;</td>
<td>13&nbsp;&nbsp;&nbsp;</td>
<td>分片后某片在原分组中的相对位置</td>
</tr>
<tr>
<td>生存时间&nbsp;&nbsp;&nbsp;</td>
<td>8&nbsp;&nbsp;&nbsp;</td>
<td>记为TTL(Time To Live)，指示数据报在网络中可通过的路由器数的最大值</td>
</tr>
<tr>
<td>协议&nbsp;&nbsp;&nbsp;</td>
<td>8&nbsp;&nbsp;&nbsp;</td>
<td>指出此数据报使用的何种协议，指出应交给上层哪一个进程</td>
</tr>
<tr>
<td>首部检验和&nbsp;&nbsp;&nbsp;</td>
<td>16&nbsp;&nbsp;&nbsp;</td>
<td>只检验数据报的首部，不检验数据部分，采用二进制反码求和算法(考试不作要求)</td>
</tr>
</tbody>
</table>
<p>注：<strong>片偏移</strong>是从数据部分开始计算的，且是以8个字节为单位，因此时要除以8。</p>
<ul>
<li><p><strong>路由器分组转发算法</strong><br><img src="/images/计算机网络/路由器分组转发算法.png" width="450" height="250" alt="路由器分组转发算法" align="center"><br>注1：整体思路，是否同网段-&gt;特定主机路由-&gt;是否有可到的路由-&gt;默认路由<br>注2：路由表中指出的是到某个网络应当先到哪个某个路由器，即下一跳的路由器。</p>
</li>
<li><p><strong>划分子网</strong><br>是对分类IP编址方法的改进，将IP地址由两级划分为三级，从主机号借用若干个位作为子网号subnet-id。<br><img src="/images/计算机网络/子网划分.png" width="300" height="100" alt="子网划分" align="center"><br>划分子网的优点：减少了IP地址的浪费，使网络的组织更加灵活，更便于维护和管理。<br>注：划分子网纯属一个单位内部的事情，对外透明，即仍表现为没有划分子网的一个网络。</p>
</li>
<li><p><strong>子网掩码</strong><br>子网掩码的作用是找出IP地址中的子网部分，子网掩码中1对应着网络号/子网号，0对应着主机号。<br>计算方法：将IP地址和子网掩码做<strong>与</strong>操作，即可得到网络号。<br>注：子网中主机号全0用于表示子网本身，全1用于广播，因此<code>子网可用主机数=总地址数-2</code>。</p>
</li>
<li><p><strong>无分类编址CIDR(构造超网)</strong><br>使用各种长度的网络前缀(network-prefix)来代替网络号和子网号。<br><img src="/images/计算机网络/网络前缀.png" width="260" height="65" alt="子网划分" align="center"><br>具体记法：128.14.32.0/20表示的地址块共有\(2^{12}\)个地址，最小地址为128.14.32.0，最大地址为128.14.47.255。<br>注1：CIDR消除了传统A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间。<br>注2：CIDR中仍然使用掩码，网络前缀的值即为掩码中1的个数。</p>
</li>
<li><p><strong>CIDR构造超网</strong><br>把多个小前缀的地址块合并成一个大前缀的地址块，这个合并过程叫路由聚合，由此产生的大地址块称为超网。</p>
</li>
<li><p><strong>CIDR匹配规则</strong><br>最长前缀匹配：CIDR在查找路由表时可能会得到不止一个匹配结果，应选择具有最长网络前缀的那项。因为网络前缀越长，其地址块就越小，因而路由就越具体 。</p>
</li>
<li><p><strong>网际控制报文协议ICMP</strong><br>由主机和路由器用于网络层面的信息通信，属于IP层协议，包括差错报告和回送请求和回答报文。<br>差错报告：不可达主机，网络，端口，协议。<br>询问报文：回送请求和回答报文 &amp; 时间戳请求和回答报文。<br>ICMP应用：ping命令，负责测试两个主机间的连通性。属于应用层，但越过了传输层，直接调用网络层的ICMP协议。使用了ICMP询问报文中的<strong>回送请求和回答报文</strong></p>
</li>
<li><p><strong>路由选择协议</strong><br>内部网关协议：RIP和OSPF<br>外部网关协议：BGP<br>注：网关即可理解为路由器</p>
</li>
<li><p><strong>内部网关协议RIP</strong><br>路由信息协议 RIP (Routing Information Protocol)<br>是一种分布式的、基于距离向量的路由选择协议，要求网络中的每一个路由器都要维护从它自己到其他所有网络的距离信息。<br>距离的定义：直接连接的网络距离为1，每经过一个路由器，距离数+1，即相当于拓扑图中的边数。</p>
</li>
<li><p><strong>RIP的特点</strong></p>
<ol>
<li>RIP总是选择<strong>距离最短</strong>的路由线路，哪怕存在另一条距离长但低时延的线路。</li>
<li>RIP中距离最大只能为15，距离为16表示目的地不可达，因此其只适用小型网络。</li>
<li>路由器仅和<strong>相邻</strong>的路由器交换信息，且交换的是路由表的全部信息，交换遵循一个固定的时间间隔。(跟谁交换，交换什么，什么时候交换)</li>
</ol>
</li>
<li><p><strong>RIP路由表建立过程</strong><br><img src="/images/计算机网络/RIP路由表的建立过程.png" width="490" height="180" alt="RIP路由表建立过程" align="center"><br>具体的路由表更新算法如下：<br><img src="/images/计算机网络/RIP路由表更新算法.png" width="500" height="240" alt="RIP路由表更新算法" align="center"></p>
</li>
<li><p><strong>RIP存在的问题</strong><br>好消息传播得快，坏消息传播得慢，出了故障会要花较长的时间才能通知到全网。<br>每次交换的是完整路由表，开销较大。<br>最大距离的存在限制了网络的规模。</p>
</li>
<li><p><strong>内部网关协议OSPF</strong><br>开放最短路径优先OSPF(Open Shortest Path First)<br>路由表更新时：和网络中的所有路由器交换信息（洪泛法），交换的是相邻路由器的链路状态，有更新时才交换，全网广播的方式。（跟谁交换，交换什么，什么时候交换）</p>
</li>
</ul>
<h2 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h2><ul>
<li><p><strong>运输层协议概述</strong><br>运输层提供的是进程到进程间的通信服务<br>因为一台主机经常有多个应用进程同时有通信需求，表明运输层有一个很重要的功能——复用和分用。<br>运输层提供两种协议：TCP和UDP</p>
</li>
<li><p><strong>TCP和UDP的对比</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>特点</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>全称</td>
<td>传输控制协议(Transmission Control Protocol)</td>
<td>用户数据报协议(User Datagram Protocol)</td>
</tr>
<tr>
<td>数据单位</td>
<td>TCP报文段</td>
<td>用户数据报</td>
</tr>
<tr>
<td>是否建立连接</td>
<td>面向连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠性</td>
<td>可靠</td>
<td>不可靠，尽最大努力</td>
</tr>
<tr>
<td>与应用层的数据接口</td>
<td>面向字节流，不需规定特定的数据格式</td>
<td>面向报文，上层的报文加上首部就传出去了</td>
</tr>
<tr>
<td>开销</td>
<td>较大</td>
<td>较小</td>
</tr>
<tr>
<td>传输速率</td>
<td>不如UDP高</td>
<td>高</td>
</tr>
<tr>
<td>适用场景</td>
<td>可靠性要求高的场景，如文件传输</td>
<td>可靠性要求不高的场景，如视频会议、IP电话</td>
</tr>
</tbody>
</table>
<ul>
<li><p><strong>端口号</strong><br>端口号标识了本计算机应用层中的各进程，通过IP地址+端口号就可以找到主机中的进程。</p>
</li>
<li><p><strong>用户数据报协议UDP</strong><br>UDP只在IP数据报服务上增加了很少一点的功能：复用、分用和差错检测<br>UDP主要特点：</p>
<ol>
<li>无连接的，减少传输开销，因此也不需要使用套接字。</li>
<li>面向报文，对于应用层交下来的报文，加上UDP首部后即进行发送，不合并也不拆分。对于IP层传上来的报文，也是去掉首部后直接交给应用层，不做修改。</li>
<li>没有拥塞控制</li>
<li>支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>首部只有<strong>8字节</strong>，开销很小</li>
<li>缺点：报文大小不容易控制，容易超长被拆分。</li>
</ol>
</li>
<li><p><strong>传输控制协议TCP</strong></p>
<ol>
<li>面向连接的传输，“连接”是TCP协议提供的一种抽象，连接的两端点被称为<strong>套接字</strong>，套接字由端口号和IP地址拼接而成。</li>
<li>只能一对一通信，提供全双工通信方式</li>
<li>面向字节流：虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用层交下来的数据仅仅看成是一串无结构的字节流。而且TCP不保证接收方和发送方的数据块完全一致，但保证字节流序列是完全一致的，怎样对字节流进行分块传输由TCP试网络情况决定。</li>
</ol>
</li>
<li><p><strong>TCP可靠传输的工作原理</strong><br>停止等待协议<br>连续 ARQ 协议</p>
</li>
<li><p><strong>停止等待协议</strong><br>每发送完一个分组就停止发送，等待对方的确认，收到确认后再发送下一个分组。<br>现假设A向B发送数据<br><strong>超时重传机制：</strong>A对每一个已发送的分组都设置了一个超时计时器，若在规定时间段内没有收到B的确认，就重新发送分组。像这种自动重传的机制称为自动重传请求ARQ。<br><strong>确认丢失：</strong>B收到了A的分组，但向A发送的确认在中途丢失了，因此A会向B重传分组，B此时要做的事：丢弃分组，重新发送确认。<br><strong>确认迟到：</strong>B向A发送的确认迟到了，A会重发分组，并收到重复的确认。因此A要丢弃重复的确认，B要丢弃重复的分组。</p>
</li>
<li><p><strong>TCP流量控制</strong><br>TCP的流量控制是用滑动窗口机制实现的：接收方根据自己的容量的大小设置接收窗口大小，然后将设的值以“窗口”字段的形式发给发送方，发送方根据这个值设置发送窗口的大小，从而实现流量控制。<br>具体窗口怎么动：发送窗口表示在没有得到对方确认的情况下，可以把窗口内的所有数据都发出去。收到确认后，窗口会向后移，具体移动的位置根据确认序号来确定。</p>
</li>
</ul>
<p>报头8位<br>UDP支持一对多，TCP只支持一对一<br>为什么要三报文握手、为什么四报文握手，一定要会！防止失效链接报文突然传到，会导致错误。（简答题）</p>
<h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><ul>
<li><p><strong>域名服务器</strong></p>
<ul>
<li>域名服务器DNS负责域名到IP地址的解析工作</li>
<li>最基本的管辖单位是“区”而非“域”，区可以等于域，也可以小于域。</li>
<li>每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。<br><img src="/images/计算机网络/域名服务器类别.png" width="500" height="240" alt="域名服务器类别" align="center"><br>此外最下层还有本地域名服务器。</li>
</ul>
</li>
<li><p><strong>域名服务器解析过程</strong></p>
<ol>
<li>在本地域名服务器中查找，<strong>递归</strong>的方式，本地若查不到，本地服务器就会作为DNS客户，向根服务器发出查询请求。</li>
<li>本地服务器向根服务器发查询请求，分为两种：<strong>迭代和递归</strong>。迭代：根域名服务器不会什么都管，只负责告诉你去找谁；递归：所有的事情根服务器帮你搞定，帮你访问顶级域名服务器、权限域名服务器，最后把结果返回给你。递归方式用得较少，因为这样根域名服务器太累。<br>具体图示见PPT</li>
</ol>
</li>
<li><p><strong>FTP文件传输服务</strong><br>FTP采用客户端服务器模式，使用TCP的可靠运输服务，而且建立了两个TCP连接，一个是<strong>控制连接</strong>，一个是<strong>数据连接</strong>。控制连接控制各种FTP请求，数据连接负责数据传输服务。</p>
</li>
<li><p><strong>邮件服务</strong><br>主要构成部分：用户代理(客户端软件)、邮件服务器、邮件协议。<br>所用到的协议有：发邮件：<strong>SMTP</strong>简单邮件传送协议，收邮件：<strong>POP3</strong>(Post Office Protocol)和<strong>IMAP</strong>(Internet Message Access Protocol)网际报文存取协议<br><img src="/images/计算机网络/邮件服务(基于用户代理).png" width="480" height="140" alt="邮件服务(基于用户代理)" align="center"></p>
</li>
<li><p><strong>邮件发送步骤</strong></p>
<ol>
<li>发件人使用用户代理撰写要发送的邮件。</li>
<li>发件人的用户代理把邮件用SMTP协议发给发送方邮件服务器。</li>
<li>邮件服务器把邮件临时存放在邮件缓存队列中，等待发送。</li>
<li>发送邮件服务器与接收方邮件服务器建立连接，然后把邮件发出去。   </li>
<li>接收方邮件服务器收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。 </li>
<li>收件人在打算收信时，就运行PC机中的用户代理，使用POP3或IMAP协议读取邮件。</li>
</ol>
</li>
<li><p><strong>基于万维网的邮件服务：</strong><br>用浏览器发送，用户和邮件服务器之间是HTTP协议，邮件服务器之间是SMTP。<br><img src="/images/计算机网络/邮件服务(基于万维网).png" width="480" height="140" alt="邮件服务(基于万维网)" align="center"></p>
</li>
</ul>
<h2 id="第七章-网络安全层"><a href="#第七章-网络安全层" class="headerlink" title="第七章 网络安全层"></a>第七章 网络安全层</h2><ul>
<li><strong>网络攻击的类别</strong><br>被动攻击：主要是截获，即从网络上窃听他人的通信内容，又称为流量攻击。<br>主动攻击：主要包括：<ol>
<li>篡改：故意篡改网络上传送的报文。</li>
<li>恶意程序：包括计算机病毒、计算机蠕虫、特洛伊木马和逻辑炸弹、后门入侵等。</li>
<li>拒绝服务：如分布式拒绝服务。指攻击者向互联网的某个服务器不停发送大量分组而导致该服务器无法正常工作。<br>在信息的安全领域中，对付被动攻击的重要措施是<strong>加密</strong>，而对付主动攻击中的篡改和伪造则要用<strong>鉴别</strong>。 </li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>两类加密体制</strong><br>对称密钥密码体制和公钥密码体制。</p>
</li>
<li><p><strong>对称密码体制</strong><br>加密和解密的密钥是相等的，用同一把钥匙加密和解密，密钥是保密的，但加密算法是公开的。<br>因为两边密钥都是一样的，无法确定改了之后是谁改的。虽然安全性不高，但加密效率高。</p>
</li>
<li><p><strong>公钥密码体制</strong><br>加密密钥和解密密钥不一样，公钥、算法都公开，只有收信方的私钥是保密的。<br>为保证以下三点：<br>(1) 报文鉴别——接收者能够核实发送者对报文的签名；<br>(2) 报文的完整性——发送者事后不能抵赖对报文的签名；<br>(3) 不可否认——接收者不能伪造对报文的签名。<br>出台了<strong>数字签名</strong>的概念。</p>
</li>
<li><p><strong>数字签名</strong><br><img src="/images/计算机网络/数字签名流程.png" width="480" height="160" alt="数字签名流程" align="center"></p>
</li>
</ul>
<p>数字签名的工作原理：<br>(1) 因为除A外没有别人具有私钥，所以除A外没有别人能产生这个密文。因此B相信报文X是A签名发送的。<br>(2) 若A要抵赖曾发送报文给B，B可将明文和对应的密文出示给第三者。第三者很容易用A的公钥证实A确实发送X给B。<br>(3) 反之，若B将X伪造成X‘，则B不能在第三者前出示对应的密文，这样就证明了B伪造了报文。  </p>
<ul>
<li><strong>鉴别体制</strong><br>对付主动攻击中的篡改和伪造要用鉴别，鉴别报文的真伪性，分为两类：实体鉴别和报文鉴别。<br>实体鉴别：又称为端点鉴别，鉴别报文确实是对方发的。<br>报文鉴别：包含端点鉴别和报文完整性鉴别，除了鉴别报文是否是对方发的，还要鉴别报文中途是否被篡改，即是可靠的消息源发出的可靠消息。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/05/28/Network/计算机网络2/" data-id="cjmmeykyi001nd5qxpttt2h7g" class="article-share-link" data-share="baidu" data-title="计算机网络笔记（第二部分）">Share</a>
      

      
        <a href="http://yoursite.com/2018/05/28/Network/计算机网络2/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Network/TCPIP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/26/Network/TCPIP/" class="article-date">
  <time datetime="2018-05-26T07:14:00.000Z" itemprop="datePublished">2018-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/26/Network/TCPIP/">TCPIP笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>本笔记是主要是根据学校《TCP/IP和网络软件编程》课的课件整理的，因为部分内容与计算机网络课重合，因此笔记只记录了计算机网络课上没讲的内容，主要作补充之用，更详细的内容可见《计算机网络》笔记。</p>
<h2 id="第一章-TCP-IP协议概述"><a href="#第一章-TCP-IP协议概述" class="headerlink" title="第一章 TCP/IP协议概述"></a>第一章 TCP/IP协议概述</h2><p>TCP/IP协议起源于ARPNET，ARPNET最初用于国防网络研究。随着连入ARPNET的电脑数量增加，就需要一种新的网络通信协议来管理，TCP/IP就出现了。<br>TCP/IP协议主要分为两部分：检测网络中传输差错的传输控制协议TCP，负责对不同网络进行互连的协议IP。</p>
<ul>
<li><p><strong>TCP/IP的体系结构</strong><br>TCP/IP协议采用了分层的思想，将网络系统按功能分为四层，称为<strong>协议栈</strong>，每一层都向它的上层提供服务，并使用下层所提供的功能。<br>从下到上为网络接口层、网络层、传输层、应用层。<br><strong>网络接口层：</strong>协议栈的最底层，表示能够传输数据的物理网络。<br><strong>网络层：</strong>主要功能是将源主机上的IP数据报发到另一台主机，端到端的通信，主要协议是IP协议。两大块内容：IP地址和路由选择。IP层提供的是一种“尽力而为”的传输服务，并不是可靠传输。<br><strong>传输层：</strong>应用进程间的通信<br><strong>应用层：</strong>提供面向用户的网络服务，如HTTP/DNS等。</p>
</li>
<li><p><strong>Internet整体架构</strong><br>Internet整体可看成是由三个级别的网络组成，国家主干网-地区级网络-企业或校园网，三层网络通过路由器连接起来。</p>
</li>
<li><p><strong>TCP/IP中的封装和解封</strong><br>传输数据时，从首部开始，由上到下依次通过协议栈的每一层，直到数据被当作一串比特流送入物理网络，其中每一层对收到的数据都会增加一些<strong>首部</strong>信息，称为<strong>封装/打包</strong>。<br>接收数据时，从下到上通过协议栈的每一层，每一层会对数据首部进行提取和处理，称为<strong>解封/拆包</strong>。</p>
</li>
<li><p><strong>OSI七层模型</strong><br><img src="/images/计算机网络/OSI和TCP对比.png" width="380" height="210" alt="OSI和TCP对比" align="center"><br>会话层：在传输层的基础上提供应用进程间的会话控制机制，包括建立和维持会话、同步会话等。<br>表示层：不同的计算机体系结构所使用的数据表示法不同，表示层就为异构的计算机通信提供一种公共表示方法。<br>应用层：面向用户，包含使用网络服务的各种应用程序。<br>注：OSI强调严格的层次划分，因此灵活性较差；TCPIP更强调功能分布而非层次划分，因此其更为灵活，但也因此层次间的分界不是那么明晰。</p>
</li>
</ul>
<h3 id="网络与通信相关组织机构"><a href="#网络与通信相关组织机构" class="headerlink" title="网络与通信相关组织机构"></a>网络与通信相关组织机构</h3><p><strong>ISO：</strong>国际标准化组织(International Organization for Standard)，是目前最大的国际标准化组织。<br><strong>ITU：</strong>国际电信联盟(International Telecommunication Union)，研究电信领域的技术、业务和资费问题，并制定国际标准建议。<br><strong>IEEE：</strong>电子电气工程师协会(Institute of Electrical and Electronics Engineers)，是国际电子电信行业最大的专业学会，网络与通信中很多标准就是IEEE制订的，如IEEE 802.2：局域网中逻辑链路层的控制协议；IEEE 802.11系列：无线通信的系列协议标准。<br><strong>ELA：</strong>美国电子工业协会(Electronic Industries Association)，其制订的最著名的标准是目前在PC机和通信设备上广泛使用的RS-232接口。<br><strong>RFC文档：</strong>请求评价文档(Request for Comments)，针对一些协议和建议标准的征求意见稿。</p>
<h2 id="第二章-网络接口层和网络层"><a href="#第二章-网络接口层和网络层" class="headerlink" title="第二章 网络接口层和网络层"></a>第二章 网络接口层和网络层</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul>
<li><p><strong>传输介质</strong><br>有线介质：同轴电缆、双绞线(使用RJ45接头)、光缆；无线介质：IEEE 802.11系列标准。</p>
</li>
<li><p><strong>同步传输与异步传输</strong><br><strong>同步传输：</strong><br>通信过程中发送方和接收方在时间上保持步调一致，如：何时检测跳变信号、上升沿还是下降沿、检测频率是多少等。<br>同步传输在发数据前先发送一串同步字符SYN，接收方只要检测到两个以上的SYN，就可以确认已进入同步状态，双方即在同一时钟频率下工作了。<br>这种方式仅在数据开始传送前添加控制字符SYN，因此传送连续、大量数据的效率比异步传输高。<br><strong>异步传输：</strong><br>把各个字符分开传输，字符与字符间插入起止信息，通信双方无需同步频率(依靠检测起止位来接收数据)，适合传送不连续的、突发的信息。<br><img src="/images/计算机网络/异步传输数据格式.png" width="335" height="80" alt="异步传输数据格式" align="center"></p>
</li>
<li><p><strong>信道复用</strong><br>频分复用(FDM)：在同一时间占用不同的频带资源。<br>时分复用(TDM)：在不同时间占用相同的频带资源，类似时间片轮转。<br>统计时分复用(STDM)：与TDM的不同在于，其并非固定顺序分配时间，而是按需动态分配。<br>波分复用(WDM)：光的频分复用，用一根光纤同时传输多个光载波信号。<br>码分多址(CDMA)：根据不同编码方式来复用。</p>
</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ul>
<li><p><strong>基本概念</strong><br>物理层上的第一层，提供基本的流量控制和差错校验功能，将不可靠的物理链路变为可靠的数据链路(无比特差错)。</p>
</li>
<li><p><strong>局域网</strong><br>地理范围、互连设备有限的计算机网络，多由单一组织机构建。<br><strong>基本组成：</strong><br>服务器：为局域网提供服务，如资源共享服务。<br>网路适配器/网卡：NIC(Network Interface Controller)，提供通信连接，发送和接受数据。<br>相关协议软件、驱动程序</p>
</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li><p><strong>网络层的两种连接方式</strong><br><strong>面向连接：</strong>在路由器上建立固定的线路，好像在通信的源和目标之间建立了一条逻辑通路，称为<strong>虚电路</strong>，接收端会收到顺序严格一致的数据分组。<br><strong>无连接：</strong>源端和目标端之间没有逻辑通路，但是送入网络的每一个分组都带有完整的目标主机地址，路由器会根据目标地址和当前网络状况选择合适的线路。<br>IP协议实现了无连接的通信，TCP协议实现了面向连接的通信。为什么这样设计？IP无连接保证了网络层的简单和灵活、TCP面向连接保证了传输的质量。</p>
</li>
<li><p><strong>网络互连技术</strong><br>网络互连主要通过路由器来实现，将异构网络连接起来，构成一个整体同一的互联网。<br>路由转发算法：见《计算机网络》笔记。<br><strong>路由器实现的功能：</strong><br>1、为网际通信选择合适的路由线路；<br>2、根据需要对数据包进行拆分和组装；<br>3、将使用不同协议的网络连接起来，构成统一的互联网；<br>4、网络安全，目前大部分路由器具备一定的防火墙功能。</p>
</li>
</ul>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP互联网中的计算机没有主次之分，唯一标识主机的是IP地址，因此各主机地位平等。<br>IP互联网没有确定的拓扑结构。<br>每个接入互联网的设备都需要有IP地址，因此路由器、网关也会有IP地址，主机至少有一个IP地址（实质是一个网卡一个IP地址）。</p>
<ul>
<li><p><strong>IP数据报</strong><br>数据在内存中字节序：大端模式，高字节在低地址，低字节在高地址；小端模式：低字节在低地址，高字节在高地址。<br>IP数据报传输的字节序：最高位在左记为第0位，最低位在右记为第31位。网络传输时，先传0-7位，再传24-31位。<br>各标志字段具体作用见《计算机网络》笔记</p>
</li>
<li><p><strong>IP数据报的分片和重组</strong><br>网络在进行数据传输时，对帧的最大长度会有限制，这个限制被称为最大传输单元MTU。<br>不同网络的MTU值可能不同，如果主机通信要经过多个网络，通常取最小的MTU值，被称为<strong>路径MTU</strong>，以太网的MTU为1500（数据链路层帧加头加尾最长为1518）。<br>若IP数据报的长度大于MTU，则IP层就需要对IP数据报分片，不同分片：标识字段相同，标志字段都是DF=0，MF=1后面还有分片，MF=0后面没有分片。</p>
</li>
</ul>
<h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><p>Internet控制报文协议(Internet Control Message Protocol)，介于网络层和传输层之间，作为IP协议的补充而存在。<br>主要有两类消息：Error，错误信息；Informational，消息/咨询性质。<br>ICMP报文封装在IP数据报中传输，但一般不认为其是高层协议，因为：ICMP仅传送差错与控制信息，且处理都需要IP层来执行，因此把它看作是IP层的补充协议。</p>
<ul>
<li><p><strong>ICMP报文的特点</strong><br>ICMP差错报文都是由路由器发送到<strong>源主机</strong>的（向源主机报告差错信息）。<br>ICMP差错报文只负责报告，不负责对各类差错采取什么处理措施。<br>ICMP差错报文是伴随着抛弃出错的IP数据报而产生的（如TTL减为0时，路由器将丢弃数据报，返回ICMP差错报文）。<br>ICMP差错报文不享有任何优先权。</p>
</li>
<li><p><strong>其他</strong><br>TCPIP课中IP地址没讲CIDR，其他和计算机网络课内容相同，具体内容参见计算机网络笔记</p>
</li>
</ul>
<h2 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h2><ul>
<li><strong>端口号的分配</strong><br>端口号：16位二进制数(0-65535)，分为保留端口号和自由端口号。<br>保留端口号：0-1023，系统保留，用户一般不适用<br>其中0-255为一些众所周知的服务，如21-FTP，23-Telnet，80-HTTP等。<br>256-1023通常由Unix服务占用，提供一些特殊的Unix服务。<br>1024以上为自由端口号，由程序进行通信之前动态地向系统申请。</li>
</ul>
<p>TCP各字段作用<br>建立连接为什么三报文握手？理论上三次是能够在不可靠信道上双方达成一致的最小值。</p>
<h2 id="第四章-Socket编程"><a href="#第四章-Socket编程" class="headerlink" title="第四章 Socket编程"></a>第四章 Socket编程</h2><p>Socket为一种网络编程规范，具体指网络通信的逻辑端点，由IP地址+端口号组成，位于传输层与应用层之间。<br>通信时应用程序将数据写入Socket中，Socket通过网卡将信息发送到另一台主机的Socket，再传到相应的接收方应用程序，即完成了通信。</p>
<h3 id="TCP通信过程"><a href="#TCP通信过程" class="headerlink" title="TCP通信过程"></a>TCP通信过程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一步：初始化Socket</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">HOST = <span class="string">'xxx.xxx.xxx.xxx'</span></span><br><span class="line">PORT = xxx</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment"># SOCK_STREAM表明是TCP模式</span></span><br><span class="line"><span class="comment">#第二步：Socket与地址、端口号绑定</span></span><br><span class="line">s.bind((HOST, PORT))</span><br><span class="line"><span class="comment">#第三步：监听请求消息</span></span><br><span class="line">s.listen(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#第四步：接收请求消息</span></span><br><span class="line">conn,address = s.accept()</span><br><span class="line"><span class="comment">#第五步：收发数据</span></span><br><span class="line"><span class="comment">#从缓冲器获得数据,参数为最大读取数量</span></span><br><span class="line">raw = conn.recv(<span class="number">100</span>)</span><br><span class="line"><span class="comment">#第六步、关闭连接</span></span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">HOST = <span class="string">'xxx.xxx.xxx.xxx'</span></span><br><span class="line">PORT = xxx</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">c.connect((HOST,PORT))</span><br><span class="line"><span class="comment"># 发送数据, 必须是byte类型的的数据</span></span><br><span class="line"><span class="comment"># 使用encode函数,将字符串通过UTF8编码为字节类型</span></span><br><span class="line">c.send(<span class="string">'Hello World!'</span>.encode())</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>
<h3 id="UDP通信过程"><a href="#UDP通信过程" class="headerlink" title="UDP通信过程"></a>UDP通信过程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">sPORT = <span class="number">9976</span></span><br><span class="line">cPORT = <span class="number">9975</span></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)    <span class="comment"># SOCK_DGRAM表明是UDP模式</span></span><br><span class="line">s.bind((HOST,sPORT))</span><br><span class="line"><span class="comment"># 此函数一直阻塞当前线程, 直到收到数据</span></span><br><span class="line"><span class="comment"># 返回值：(b'Hello From UDP', ('127.0.0.1', 9975))，给出了收到的数据以及来源信息(IP地址和端口号)</span></span><br><span class="line">s.recvfrom(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket  </span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">sPORT = <span class="number">9976</span></span><br><span class="line">cPORT = <span class="number">9975</span></span><br><span class="line">c = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">c.bind((HOST,cPORT))</span><br><span class="line">c.sendto(<span class="string">'Hello By UDP'</span>.encode(), (HOST,sPORT))</span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">14</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>三种不同类型的Socket：</strong><br>1、<strong>流套接字(SOCK_STREAM)：</strong>使用TCP来实现，提供可靠的、面向连接的传输服务，适用于大批量的数据<br>2、<strong>数据报套接字(SOCK_DGRAM)：</strong>使用UDP来实现，无连接、不可靠的数据传输服务，数据以独立报文的形式发送，效率高，适合出现差错可能性小的网络。<br>3、<strong>原始套接字(SOCK_RAW)：</strong>可以读写内核没有处理的IP数据报。因为流套接字只针对TCP协议，数据报套接字只针对UDP协议，若要传输其他协议发送的数据必须用原始套接字。</p>
</li>
<li><p><strong>阻塞和非阻塞通信模式</strong><br>对于发送端：都是阻塞模式，即如果底层协议没有足够的空间存放数据，则应用程序会一致等待。<br>对于接收端：在阻塞模式下，若没有到达的数据，则I/O会一直阻塞等待着数据到达；在非阻塞模式下，应用程序定时查询或者有数据到达时通知程序处理。<br>注：因为UDP没有发送缓冲，因此即使在阻塞模式下也不会发生阻塞，即UDP没有真正的阻塞模式。</p>
</li>
</ul>
<h3 id="关闭Socket"><a href="#关闭Socket" class="headerlink" title="关闭Socket"></a>关闭Socket</h3><p>在TCP中，关闭连接比建立连接更为关键，因为涉及到两方向数据传输的断开。<br>如果一方直接调用<code>.close()</code>函数，会直接将所有数据都断掉，另一方若还有数据则无法发送。<br>因此采用<strong>半关闭</strong>的方式，之关闭一部分数据交换中的流，如无法发送数据，但还可以接收数据。</p>
<h3 id="TCP-IP网络应用"><a href="#TCP-IP网络应用" class="headerlink" title="TCP/IP网络应用"></a>TCP/IP网络应用</h3><ul>
<li><p><strong>DNS地址信息查询</strong><br>实现域名-&gt;IP地址的转换，DNS服务由域名空间、域名服务器和解析器三部分组成。</p>
</li>
<li><p><strong>Telnet远程登陆协议</strong><br><strong>远程登陆系统需要具备的条件：</strong><br>一个本地系统、一个远程系统、本地系统和远程系统间可以相互通信、本地系统的用户在远程多用户系统中由用户账号、本地系统和远程系统可能是不同的操作系统，因此Telnet要能运行在不同的操作系统上。<br><strong>Telnet工作模式：</strong><br>Telnet采用C/S模式，通过TCP进行通信，服务端为23端口。<br>1、本地客户提出远程登陆请求，通过三次握手与远程系统建立连接。<br>2、客户端Telnet向远程Telnet发数据（通过TCP协议），远程Telnet收到数据后，并不直接处理数据，而是将数据转发给内核，由内核进行处理。<br>3、同时远程Telnet也接收服务端要传送的数据，发给客户端。</p>
</li>
<li><p><strong>Email服务</strong><br>采用了SMTP协议，通过TCP进行通信，服务端为25端口。<br>客户端邮件服务器和接收端邮件服务器建立TCP连接后，通过各种命令实现邮件服务。</p>
</li>
<li><p><strong>FTP文件传输协议</strong><br>FTP用来把一台主机上的文件传到另一台主机上，基于C/S模式，通过TCP进行通信。</p>
</li>
<li><p><strong>www服务和http协议</strong><br><strong>www和http的关系：</strong><br><strong>www：</strong>www是World Wide Web的缩写，也可以简称为Web，中文为“万维网”。是一个由许多互相链接的超文本组成的系统，通过互联网传输数据，系统中的资源由URL地址来唯一标识和访问。<br>www主要是提供基于浏览器的Web服务，并不等同互联网，万维网只是互联网所能提供的服务其中之一（还有很多其他服务如FTP、Telnet、邮件服务等等）。<br><strong>http：</strong>http是HyperText Transfer Protocol的缩写，译为超文本传输协议。其设计主要是为了提供一种传输HTML页面的标准（HTML：超文本标记语言，与HTTP超文本传输协议是对应的），用于浏览器和网页服务器之间交换数据，所有的www文件都必须遵守这个标准。如一般网址前<code>https://www.baidu.com</code>都会有http/https。<br><strong>https：</strong>安全套接字层超文本传输协议，数据不再是明文传输，更为安全。原理：在http的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。<br><strong>工作流程：</strong><br>1、用户在浏览器中输入网页的URL地址<br>2、浏览器向DNS服务器发出请求，请求解析URL地址<br>3、DNS服务器解析完成，向浏览器返回解析后的IP地址<br>4、浏览器向对应IP地址的80端口（HTTP端口）发出建立TCP连接的请求，连接建立后即可进行数据传输。</p>
</li>
</ul>
<h2 id="IO复用与并行程序"><a href="#IO复用与并行程序" class="headerlink" title="IO复用与并行程序"></a>IO复用与并行程序</h2><h3 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h3><p>示例代码[转]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, select  </span><br><span class="line">  </span><br><span class="line">s=socket.socket()  </span><br><span class="line">print(<span class="string">'s:'</span>,s)  </span><br><span class="line">host=socket.gethostname()  </span><br><span class="line">port= <span class="number">4321</span></span><br><span class="line">s.bind((host,port))    </span><br><span class="line">s.listen(<span class="number">5</span>)  </span><br><span class="line"><span class="comment">#设置监听对象，最初只有当前主机（还未与客户端建立连接）  </span></span><br><span class="line">inputs=[s]  </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:  </span><br><span class="line">    <span class="comment"># select函数阻塞当前线程,直到监听列表的对象发生改变</span></span><br><span class="line">    <span class="comment"># select输入参数：可读列表，可写列表，异常列表</span></span><br><span class="line">    <span class="comment"># select返回参数：发生改变的对应列表</span></span><br><span class="line">    rs,ws,es=select.select(inputs,[],[])</span><br><span class="line">                                          </span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> rs:  </span><br><span class="line">        <span class="comment"># 如果服务器套接字被触发，表明是出现建立新连接的请求</span></span><br><span class="line">        <span class="comment"># 第一次触发肯定是建立新连接的情况</span></span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">is</span> s:                          </span><br><span class="line">            c, addr = s.accept()  </span><br><span class="line">            print(<span class="string">'Got connection from'</span>, addr)  </span><br><span class="line">            <span class="comment"># 将新建的socket加入监听列表</span></span><br><span class="line">            inputs.append(c)               </span><br><span class="line">        <span class="comment"># 如果客户端套接字被触发，表明是有数据传来</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:  </span><br><span class="line">                data = r.recv(<span class="number">1024</span>)    <span class="comment"># 接收数据</span></span><br><span class="line">                disconnected = <span class="keyword">not</span> data  </span><br><span class="line">            <span class="keyword">except</span> socket.error:  </span><br><span class="line">                disconnected = <span class="keyword">True</span>  </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> disconnected:  </span><br><span class="line">                <span class="comment"># data为空，表明数据已传完，断开连接，将对象移除监听列表</span></span><br><span class="line">                print(r.getpeername(),<span class="string">'disconnected'</span>)  </span><br><span class="line">                inputs.remove(r)</span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                print(data)</span><br></pre></td></tr></table></figure></p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程是资源分配的单位，线程是调度运行的单位，线程共享同一进程的资源。<br>进程可理解为操作系统所完成的任务，线程表示完成该任务的许多可能的子任务。<br>创建进程：<code>fork()</code>函数，只在Linux平台下有，Win下没有。<br>创建当前进程的副本，函数之后的语句通过fork()函数返回的pid来判断是是父进程or子进程，子进程：0，父进程：子进程的进程号。<br><img src="/images/计算机网络/fork函数.png" width="500" height="400" alt="fork函数示例" align="center"><br>在子进程中，gval复制为11，lval复制为25。<br>最后输出结果为：<br>Child Proc: 27, 13<br>Parent Proc: 23, 9</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2018/05/26/Network/TCPIP/" data-id="cjmmeykyh001md5qxyzcjlbuv" class="article-share-link" data-share="baidu" data-title="TCPIP笔记">Share</a>
      

      
        <a href="http://yoursite.com/2018/05/26/Network/TCPIP/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-Sharp/">C_Sharp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English/">English</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/">JSP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lingo/">Lingo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MachineLearning/">MachineLearning</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/">Network</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Paper-Notes/">Paper Notes</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/课程笔记/">课程笔记</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 14px;">Algorithm</a> <a href="/tags/C/" style="font-size: 12px;">C++</a> <a href="/tags/C-Sharp/" style="font-size: 10px;">C_Sharp</a> <a href="/tags/English/" style="font-size: 16px;">English</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Lingo/" style="font-size: 10px;">Lingo</a> <a href="/tags/MachineLearning/" style="font-size: 18px;">MachineLearning</a> <a href="/tags/Network/" style="font-size: 14px;">Network</a> <a href="/tags/Other/" style="font-size: 20px;">Other</a> <a href="/tags/Paper-Notes/" style="font-size: 14px;">Paper Notes</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/python/" style="font-size: 12px;">python</a> <a href="/tags/课程笔记/" style="font-size: 10px;">课程笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">24</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/13/Paper Notes/Notes of On Availability For Blockchain based Systems/">On Availability For Blockchain based Systems读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/09/13/Paper Notes/Notes of Efficient Estimation of Word Representations in Vector Space/">Notes of Efficient Estimation of Word Representations in Vector Space读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/09/13/Paper Notes/Notes of Personal Recommendation Using Deep Recurrent Neural Networks in NetEase/">Personal Recommendation Using Deep Recurrent Neural Networks in NetEase读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/09/13/深度学习与Tensorflow/">深度学习与TensorFlow</a>
          </li>
        
          <li>
            <a href="/2018/09/13/微机接口技术与应用/">微机接口技术与应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Ren Li<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
